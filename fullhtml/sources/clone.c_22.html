
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (C) 2004 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * This library is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU Lesser General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2.1 of the License, or (at your option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This library is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * Lesser General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU Lesser General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;crm_internal.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;crm/pengine/rules.h&gt;</a>
<a name="ln26">#include &lt;crm/pengine/status.h&gt;</a>
<a name="ln27">#include &lt;crm/pengine/internal.h&gt;</a>
<a name="ln28">#include &lt;unpack.h&gt;</a>
<a name="ln29">#include &lt;crm/msg_xml.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#define VARIANT_CLONE 1</a>
<a name="ln32">#include &quot;./variant.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">void force_non_unique_clone(resource_t * rsc, const char *rid, pe_working_set_t * data_set);</a>
<a name="ln35">resource_t *create_child_clone(resource_t * rsc, int sub_id, pe_working_set_t * data_set);</a>
<a name="ln36"> </a>
<a name="ln37">static void</a>
<a name="ln38">mark_as_orphan(resource_t * rsc)</a>
<a name="ln39">{</a>
<a name="ln40">    GListPtr gIter = rsc-&gt;children;</a>
<a name="ln41"> </a>
<a name="ln42">    set_bit(rsc-&gt;flags, pe_rsc_orphan);</a>
<a name="ln43"> </a>
<a name="ln44">    for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln45">        resource_t *child = (resource_t *) gIter-&gt;data;</a>
<a name="ln46"> </a>
<a name="ln47">        mark_as_orphan(child);</a>
<a name="ln48">    }</a>
<a name="ln49">}</a>
<a name="ln50"> </a>
<a name="ln51">void</a>
<a name="ln52">force_non_unique_clone(resource_t * rsc, const char *rid, pe_working_set_t * data_set)</a>
<a name="ln53">{</a>
<a name="ln54">    if (pe_rsc_is_clone(rsc)) {</a>
<a name="ln55">        clone_variant_data_t *clone_data = NULL;</a>
<a name="ln56"> </a>
<a name="ln57">        get_clone_variant_data(clone_data, rsc);</a>
<a name="ln58"> </a>
<a name="ln59">        crm_config_warn(&quot;Clones %s contains non-OCF resource %s and so &quot;</a>
<a name="ln60">                        &quot;can only be used as an anonymous clone. &quot;</a>
<a name="ln61">                        &quot;Set the &quot; XML_RSC_ATTR_UNIQUE &quot; meta attribute to false&quot;, rsc-&gt;id, rid);</a>
<a name="ln62"> </a>
<a name="ln63">        clone_data-&gt;clone_node_max = 1;</a>
<a name="ln64">        clone_data-&gt;clone_max = g_list_length(data_set-&gt;nodes);</a>
<a name="ln65">        clear_bit_recursive(rsc, pe_rsc_unique);</a>
<a name="ln66">    }</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">resource_t *</a>
<a name="ln70">find_clone_instance(resource_t * rsc, const char *sub_id, pe_working_set_t * data_set)</a>
<a name="ln71">{</a>
<a name="ln72">    char *child_id = NULL;</a>
<a name="ln73">    resource_t *child = NULL;</a>
<a name="ln74">    const char *child_base = NULL;</a>
<a name="ln75">    clone_variant_data_t *clone_data = NULL;</a>
<a name="ln76"> </a>
<a name="ln77">    get_clone_variant_data(clone_data, rsc);</a>
<a name="ln78"> </a>
<a name="ln79">    child_base = ID(clone_data-&gt;xml_obj_child);</a>
<a name="ln80">    child_id = crm_concat(child_base, sub_id, ':');</a>
<a name="ln81">    child = pe_find_resource(rsc-&gt;children, child_id);</a>
<a name="ln82"> </a>
<a name="ln83">    free(child_id);</a>
<a name="ln84">    return child;</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87">resource_t *</a>
<a name="ln88">create_child_clone(resource_t * rsc, int sub_id, pe_working_set_t * data_set)</a>
<a name="ln89">{</a>
<a name="ln90">    gboolean as_orphan = FALSE;</a>
<a name="ln91">    char *inc_num = NULL;</a>
<a name="ln92">    char *inc_max = NULL;</a>
<a name="ln93">    resource_t *child_rsc = NULL;</a>
<a name="ln94">    xmlNode *child_copy = NULL;</a>
<a name="ln95">    clone_variant_data_t *clone_data = NULL;</a>
<a name="ln96"> </a>
<a name="ln97">    get_clone_variant_data(clone_data, rsc);</a>
<a name="ln98"> </a>
<a name="ln99">    CRM_CHECK(clone_data-&gt;xml_obj_child != NULL, return FALSE);</a>
<a name="ln100"> </a>
<a name="ln101">    if (sub_id &lt; 0) {</a>
<a name="ln102">        as_orphan = TRUE;</a>
<a name="ln103">        sub_id = clone_data-&gt;total_clones;</a>
<a name="ln104">    }</a>
<a name="ln105">    inc_num = crm_itoa(sub_id);</a>
<a name="ln106">    inc_max = crm_itoa(clone_data-&gt;clone_max);</a>
<a name="ln107"> </a>
<a name="ln108">    child_copy = copy_xml(clone_data-&gt;xml_obj_child);</a>
<a name="ln109"> </a>
<a name="ln110">    crm_xml_add(child_copy, XML_RSC_ATTR_INCARNATION, inc_num);</a>
<a name="ln111"> </a>
<a name="ln112">    if (common_unpack(child_copy, &amp;child_rsc, rsc, data_set) == FALSE) {</a>
<a name="ln113">        pe_err(&quot;Failed unpacking resource %s&quot;, crm_element_value(child_copy, XML_ATTR_ID));</a>
<a name="ln114">        child_rsc = NULL;</a>
<a name="ln115">        goto bail;</a>
<a name="ln116">    }</a>
<a name="ln117">/*  child_rsc-&gt;globally_unique = rsc-&gt;globally_unique; */</a>
<a name="ln118"> </a>
<a name="ln119">    CRM_ASSERT(child_rsc);</a>
<a name="ln120">    clone_data-&gt;total_clones += 1;</a>
<a name="ln121">    pe_rsc_trace(child_rsc, &quot;Setting clone attributes for: %s&quot;, child_rsc-&gt;id);</a>
<a name="ln122">    rsc-&gt;children = g_list_append(rsc-&gt;children, child_rsc);</a>
<a name="ln123">    if (as_orphan) {</a>
<a name="ln124">        mark_as_orphan(child_rsc);</a>
<a name="ln125">    }</a>
<a name="ln126"> </a>
<a name="ln127">    add_hash_param(child_rsc-&gt;meta, XML_RSC_ATTR_INCARNATION_MAX, inc_max);</a>
<a name="ln128"> </a>
<a name="ln129">    print_resource(LOG_DEBUG_3, &quot;Added &quot;, child_rsc, FALSE);</a>
<a name="ln130"> </a>
<a name="ln131">  bail:</a>
<a name="ln132">    free(inc_num);</a>
<a name="ln133">    free(inc_max);</a>
<a name="ln134"> </a>
<a name="ln135">    return child_rsc;</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138">gboolean</a>
<a name="ln139">master_unpack(resource_t * rsc, pe_working_set_t * data_set)</a>
<a name="ln140">{</a>
<a name="ln141">    const char *master_max = g_hash_table_lookup(rsc-&gt;meta, XML_RSC_ATTR_MASTER_MAX);</a>
<a name="ln142">    const char *master_node_max = g_hash_table_lookup(rsc-&gt;meta, XML_RSC_ATTR_MASTER_NODEMAX);</a>
<a name="ln143"> </a>
<a name="ln144">    g_hash_table_replace(rsc-&gt;meta, strdup(&quot;stateful&quot;), strdup(XML_BOOLEAN_TRUE));</a>
<a name="ln145">    if (clone_unpack(rsc, data_set)) {</a>
<a name="ln146">        clone_variant_data_t *clone_data = NULL;</a>
<a name="ln147"> </a>
<a name="ln148">        get_clone_variant_data(clone_data, rsc);</a>
<a name="ln149">        clone_data-&gt;master_max = crm_parse_int(master_max, &quot;1&quot;);</a>
<a name="ln150">        clone_data-&gt;master_node_max = crm_parse_int(master_node_max, &quot;1&quot;);</a>
<a name="ln151">        return TRUE;</a>
<a name="ln152">    }</a>
<a name="ln153">    return FALSE;</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">gboolean</a>
<a name="ln157">clone_unpack(resource_t * rsc, pe_working_set_t * data_set)</a>
<a name="ln158">{</a>
<a name="ln159">    int lpc = 0;</a>
<a name="ln160">    const char *type = NULL;</a>
<a name="ln161">    int num_xml_children = 0;</a>
<a name="ln162">    xmlNode *a_child = NULL;</a>
<a name="ln163">    xmlNode *xml_obj = rsc-&gt;xml;</a>
<a name="ln164">    clone_variant_data_t *clone_data = NULL;</a>
<a name="ln165"> </a>
<a name="ln166">    const char *ordered = g_hash_table_lookup(rsc-&gt;meta, XML_RSC_ATTR_ORDERED);</a>
<a name="ln167">    const char *interleave = g_hash_table_lookup(rsc-&gt;meta, XML_RSC_ATTR_INTERLEAVE);</a>
<a name="ln168">    const char *max_clones = g_hash_table_lookup(rsc-&gt;meta, XML_RSC_ATTR_INCARNATION_MAX);</a>
<a name="ln169">    const char *max_clones_node = g_hash_table_lookup(rsc-&gt;meta, XML_RSC_ATTR_INCARNATION_NODEMAX);</a>
<a name="ln170"> </a>
<a name="ln171">    pe_rsc_trace(rsc, &quot;Processing resource %s...&quot;, rsc-&gt;id);</a>
<a name="ln172"> </a>
<a name="ln173">    clone_data = calloc(1, sizeof(clone_variant_data_t));</a>
<a name="ln174">    rsc-&gt;variant_opaque = clone_data;</a>
<a name="ln175">    clone_data-&gt;interleave = FALSE;</a>
<a name="ln176">    clone_data-&gt;ordered = FALSE;</a>
<a name="ln177"> </a>
<a name="ln178">    clone_data-&gt;active_clones = 0;</a>
<a name="ln179">    clone_data-&gt;xml_obj_child = NULL;</a>
<a name="ln180">    clone_data-&gt;clone_node_max = crm_parse_int(max_clones_node, &quot;1&quot;);</a>
<a name="ln181"> </a>
<a name="ln182">    if (max_clones) {</a>
<a name="ln183">        clone_data-&gt;clone_max = crm_parse_int(max_clones, &quot;1&quot;);</a>
<a name="ln184"> </a>
<a name="ln185">    } else if (g_list_length(data_set-&gt;nodes) &gt; 0) {</a>
<a name="ln186">        clone_data-&gt;clone_max = g_list_length(data_set-&gt;nodes);</a>
<a name="ln187"> </a>
<a name="ln188">    } else {</a>
<a name="ln189">        clone_data-&gt;clone_max = 1;      /* Handy during crm_verify */</a>
<a name="ln190">    }</a>
<a name="ln191"> </a>
<a name="ln192">    if (crm_is_true(interleave)) {</a>
<a name="ln193">        clone_data-&gt;interleave = TRUE;</a>
<a name="ln194">    }</a>
<a name="ln195">    if (crm_is_true(ordered)) {</a>
<a name="ln196">        clone_data-&gt;ordered = TRUE;</a>
<a name="ln197">    }</a>
<a name="ln198">    if ((rsc-&gt;flags &amp; pe_rsc_unique) == 0 &amp;&amp; clone_data-&gt;clone_node_max &gt; 1) {</a>
<a name="ln199">        crm_config_err(&quot;Anonymous clones (%s) may only support one copy per node&quot;, rsc-&gt;id);</a>
<a name="ln200">        clone_data-&gt;clone_node_max = 1;</a>
<a name="ln201">    }</a>
<a name="ln202"> </a>
<a name="ln203">    pe_rsc_trace(rsc, &quot;Options for %s&quot;, rsc-&gt;id);</a>
<a name="ln204">    pe_rsc_trace(rsc, &quot;\tClone max: %d&quot;, clone_data-&gt;clone_max);</a>
<a name="ln205">    pe_rsc_trace(rsc, &quot;\tClone node max: %d&quot;, clone_data-&gt;clone_node_max);</a>
<a name="ln206">    pe_rsc_trace(rsc, &quot;\tClone is unique: %s&quot;,</a>
<a name="ln207">                 is_set(rsc-&gt;flags, pe_rsc_unique) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln208"> </a>
<a name="ln209">    clone_data-&gt;xml_obj_child = find_xml_node(xml_obj, XML_CIB_TAG_GROUP, FALSE);</a>
<a name="ln210"> </a>
<a name="ln211">    if (clone_data-&gt;xml_obj_child == NULL) {</a>
<a name="ln212">        clone_data-&gt;xml_obj_child = find_xml_node(xml_obj, XML_CIB_TAG_RESOURCE, TRUE);</a>
<a name="ln213">        for (a_child = __xml_first_child(xml_obj); a_child != NULL; a_child = __xml_next_element(a_child)) {</a>
<a name="ln214">            if (crm_str_eq((const char *)a_child-&gt;name, XML_CIB_TAG_RESOURCE, TRUE)) {</a>
<a name="ln215">                num_xml_children++;</a>
<a name="ln216">            }</a>
<a name="ln217">        }</a>
<a name="ln218">    }</a>
<a name="ln219"> </a>
<a name="ln220">    if (clone_data-&gt;xml_obj_child == NULL) {</a>
<a name="ln221">        crm_config_err(&quot;%s has nothing to clone&quot;, rsc-&gt;id);</a>
<a name="ln222">        return FALSE;</a>
<a name="ln223">    }</a>
<a name="ln224"> </a>
<a name="ln225">    for (a_child = __xml_first_child(xml_obj); a_child != NULL; a_child = __xml_next_element(a_child)) {</a>
<a name="ln226">        if (crm_str_eq((const char *)a_child-&gt;name, type, TRUE)) {</a>
<a name="ln227">            num_xml_children++;</a>
<a name="ln228">        }</a>
<a name="ln229">    }</a>
<a name="ln230"> </a>
<a name="ln231">    if (num_xml_children &gt; 1) {</a>
<a name="ln232">        crm_config_err(&quot;%s has too many children.  Only the first (%s) will be cloned.&quot;,</a>
<a name="ln233">                       rsc-&gt;id, ID(clone_data-&gt;xml_obj_child));</a>
<a name="ln234">    }</a>
<a name="ln235"> </a>
<a name="ln236">    /*</a>
<a name="ln237">     * Make clones ever so slightly sticky by default</a>
<a name="ln238">     *</a>
<a name="ln239">     * This helps ensure clone instances are not shuffled around the cluster</a>
<a name="ln240">     * for no benefit in situations when pre-allocation is not appropriate</a>
<a name="ln241">     */</a>
<a name="ln242">    if (g_hash_table_lookup(rsc-&gt;meta, XML_RSC_ATTR_STICKINESS) == NULL) {</a>
<a name="ln243">        add_hash_param(rsc-&gt;meta, XML_RSC_ATTR_STICKINESS, &quot;1&quot;);</a>
<a name="ln244">    }</a>
<a name="ln245"> </a>
<a name="ln246">    pe_rsc_trace(rsc, &quot;\tClone is unique (fixed): %s&quot;,</a>
<a name="ln247">                 is_set(rsc-&gt;flags, pe_rsc_unique) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln248">    clone_data-&gt;notify_confirm = is_set(rsc-&gt;flags, pe_rsc_notify);</a>
<a name="ln249">    add_hash_param(rsc-&gt;meta, XML_RSC_ATTR_UNIQUE,</a>
<a name="ln250">                   is_set(rsc-&gt;flags, pe_rsc_unique) ? XML_BOOLEAN_TRUE : XML_BOOLEAN_FALSE);</a>
<a name="ln251"> </a>
<a name="ln252">    for (lpc = 0; lpc &lt; clone_data-&gt;clone_max; lpc++) {</a>
<a name="ln253">        if (create_child_clone(rsc, lpc, data_set) == NULL) {</a>
<a name="ln254">            return FALSE;</a>
<a name="ln255">        }</a>
<a name="ln256">    }</a>
<a name="ln257"> </a>
<a name="ln258">    if (clone_data-&gt;clone_max == 0) {</a>
<a name="ln259">        /* create one so that unpack_find_resource() will hook up</a>
<a name="ln260">         * any orphans up to the parent correctly</a>
<a name="ln261">         */</a>
<a name="ln262">        if (create_child_clone(rsc, -1, data_set) == NULL) {</a>
<a name="ln263">            return FALSE;</a>
<a name="ln264">        }</a>
<a name="ln265">    }</a>
<a name="ln266"> </a>
<a name="ln267">    pe_rsc_trace(rsc, &quot;Added %d children to resource %s...&quot;, clone_data-&gt;clone_max, rsc-&gt;id);</a>
<a name="ln268">    return TRUE;</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">gboolean</a>
<a name="ln272">clone_active(resource_t * rsc, gboolean all)</a>
<a name="ln273">{</a>
<a name="ln274">    GListPtr gIter = rsc-&gt;children;</a>
<a name="ln275"> </a>
<a name="ln276">    for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln277">        resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln278">        gboolean child_active = child_rsc-&gt;fns-&gt;active(child_rsc, all);</a>
<a name="ln279"> </a>
<a name="ln280">        if (all == FALSE &amp;&amp; child_active) {</a>
<a name="ln281">            return TRUE;</a>
<a name="ln282">        } else if (all &amp;&amp; child_active == FALSE) {</a>
<a name="ln283">            return FALSE;</a>
<a name="ln284">        }</a>
<a name="ln285">    }</a>
<a name="ln286"> </a>
<a name="ln287">    if (all) {</a>
<a name="ln288">        return TRUE;</a>
<a name="ln289">    } else {</a>
<a name="ln290">        return FALSE;</a>
<a name="ln291">    }</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">static void</a>
<a name="ln295">short_print(char *list, const char *prefix, const char *type, const char *suffix, long options, void *print_data)</a>
<a name="ln296">{</a>
<a name="ln297">    if(suffix == NULL) {</a>
<a name="ln298">        suffix = &quot;&quot;;</a>
<a name="ln299">    }</a>
<a name="ln300"> </a>
<a name="ln301">    if (list) {</a>
<a name="ln302">        if (options &amp; pe_print_html) {</a>
<a name="ln303">            status_print(&quot;&lt;li&gt;&quot;);</a>
<a name="ln304">        }</a>
<a name="ln305">        status_print(&quot;%s%s: [%s ]%s&quot;, prefix, type, list, suffix);</a>
<a name="ln306"> </a>
<a name="ln307">        if (options &amp; pe_print_html) {</a>
<a name="ln308">            status_print(&quot;&lt;/li&gt;\n&quot;);</a>
<a name="ln309"> </a>
<a name="ln310">        } else if (options &amp; pe_print_suppres_nl) {</a>
<a name="ln311">            /* nothing */</a>
<a name="ln312">        } else if ((options &amp; pe_print_printf) || (options &amp; pe_print_ncurses)) {</a>
<a name="ln313">            status_print(&quot;\n&quot;);</a>
<a name="ln314">        }</a>
<a name="ln315"> </a>
<a name="ln316">    }</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">static const char *</a>
<a name="ln320">configured_role_str(resource_t * rsc)</a>
<a name="ln321">{</a>
<a name="ln322">    const char *target_role = g_hash_table_lookup(rsc-&gt;meta,</a>
<a name="ln323">                                                  XML_RSC_ATTR_TARGET_ROLE);</a>
<a name="ln324"> </a>
<a name="ln325">    if ((target_role == NULL) &amp;&amp; rsc-&gt;children &amp;&amp; rsc-&gt;children-&gt;data) {</a>
<a name="ln326">        target_role = g_hash_table_lookup(((resource_t*)rsc-&gt;children-&gt;data)-&gt;meta,</a>
<a name="ln327">                                          XML_RSC_ATTR_TARGET_ROLE);</a>
<a name="ln328">    }</a>
<a name="ln329">    return target_role;</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332">static enum rsc_role_e</a>
<a name="ln333">configured_role(resource_t * rsc)</a>
<a name="ln334">{</a>
<a name="ln335">    const char *target_role = configured_role_str(rsc);</a>
<a name="ln336"> </a>
<a name="ln337">    if (target_role) {</a>
<a name="ln338">        return text2role(target_role);</a>
<a name="ln339">    }</a>
<a name="ln340">    return RSC_ROLE_UNKNOWN;</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">static void</a>
<a name="ln344">clone_print_xml(resource_t * rsc, const char *pre_text, long options, void *print_data)</a>
<a name="ln345">{</a>
<a name="ln346">    int is_master_slave = rsc-&gt;variant == pe_master ? 1 : 0;</a>
<a name="ln347">    char *child_text = crm_concat(pre_text, &quot;   &quot;, ' ');</a>
<a name="ln348">    const char *target_role = configured_role_str(rsc);</a>
<a name="ln349">    GListPtr gIter = rsc-&gt;children;</a>
<a name="ln350"> </a>
<a name="ln351">    status_print(&quot;%s&lt;clone &quot;, pre_text);</a>
<a name="ln352">    status_print(&quot;id=\&quot;%s\&quot; &quot;, rsc-&gt;id);</a>
<a name="ln353">    status_print(&quot;multi_state=\&quot;%s\&quot; &quot;, is_master_slave ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln354">    status_print(&quot;unique=\&quot;%s\&quot; &quot;, is_set(rsc-&gt;flags, pe_rsc_unique) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln355">    status_print(&quot;managed=\&quot;%s\&quot; &quot;, is_set(rsc-&gt;flags, pe_rsc_managed) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln356">    status_print(&quot;failed=\&quot;%s\&quot; &quot;, is_set(rsc-&gt;flags, pe_rsc_failed) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln357">    status_print(&quot;failure_ignored=\&quot;%s\&quot; &quot;,</a>
<a name="ln358">                 is_set(rsc-&gt;flags, pe_rsc_failure_ignored) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln359">    if (target_role) {</a>
<a name="ln360">        status_print(&quot;target_role=\&quot;%s\&quot; &quot;, target_role);</a>
<a name="ln361">    }</a>
<a name="ln362">    status_print(&quot;&gt;\n&quot;);</a>
<a name="ln363"> </a>
<a name="ln364">    for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln365">        resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln366"> </a>
<a name="ln367">        child_rsc-&gt;fns-&gt;print(child_rsc, child_text, options, print_data);</a>
<a name="ln368">    }</a>
<a name="ln369"> </a>
<a name="ln370">    status_print(&quot;%s&lt;/clone&gt;\n&quot;, pre_text);</a>
<a name="ln371">    free(child_text);</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">bool is_set_recursive(resource_t * rsc, long long flag, bool any)</a>
<a name="ln375">{</a>
<a name="ln376">    GListPtr gIter;</a>
<a name="ln377">    bool all = !any;</a>
<a name="ln378"> </a>
<a name="ln379">    if(is_set(rsc-&gt;flags, flag)) {</a>
<a name="ln380">        if(any) {</a>
<a name="ln381">            return TRUE;</a>
<a name="ln382">        }</a>
<a name="ln383">    } else if(all) {</a>
<a name="ln384">        return FALSE;</a>
<a name="ln385">    }</a>
<a name="ln386"> </a>
<a name="ln387">    for (gIter = rsc-&gt;children; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln388">        if(is_set_recursive(gIter-&gt;data, flag, any)) {</a>
<a name="ln389">            if(any) {</a>
<a name="ln390">                return TRUE;</a>
<a name="ln391">            }</a>
<a name="ln392"> </a>
<a name="ln393">        } else if(all) {</a>
<a name="ln394">            return FALSE;</a>
<a name="ln395">        }</a>
<a name="ln396">    }</a>
<a name="ln397"> </a>
<a name="ln398">    if(all) {</a>
<a name="ln399">        return TRUE;</a>
<a name="ln400">    }</a>
<a name="ln401">    return FALSE;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">void</a>
<a name="ln405">clone_print(resource_t * rsc, const char *pre_text, long options, void *print_data)</a>
<a name="ln406">{</a>
<a name="ln407">    char *list_text = NULL;</a>
<a name="ln408">    char *child_text = NULL;</a>
<a name="ln409">    char *stopped_list = NULL;</a>
<a name="ln410">    const char *type = &quot;Clone&quot;;</a>
<a name="ln411"> </a>
<a name="ln412">    GListPtr master_list = NULL;</a>
<a name="ln413">    GListPtr started_list = NULL;</a>
<a name="ln414">    GListPtr gIter = rsc-&gt;children;</a>
<a name="ln415"> </a>
<a name="ln416">    clone_variant_data_t *clone_data = NULL;</a>
<a name="ln417">    int active_instances = 0;</a>
<a name="ln418"> </a>
<a name="ln419">    if (pre_text == NULL) {</a>
<a name="ln420">        pre_text = &quot; &quot;;</a>
<a name="ln421">    }</a>
<a name="ln422"> </a>
<a name="ln423">    if (options &amp; pe_print_xml) {</a>
<a name="ln424">        clone_print_xml(rsc, pre_text, options, print_data);</a>
<a name="ln425">        return;</a>
<a name="ln426">    }</a>
<a name="ln427"> </a>
<a name="ln428">    get_clone_variant_data(clone_data, rsc);</a>
<a name="ln429"> </a>
<a name="ln430">    child_text = crm_concat(pre_text, &quot;   &quot;, ' ');</a>
<a name="ln431"> </a>
<a name="ln432">    if (rsc-&gt;variant == pe_master) {</a>
<a name="ln433">        type = &quot;Master/Slave&quot;;</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    status_print(&quot;%s%s Set: %s [%s]%s%s&quot;,</a>
<a name="ln437">                 pre_text ? pre_text : &quot;&quot;, type, rsc-&gt;id, ID(clone_data-&gt;xml_obj_child),</a>
<a name="ln438">                 is_set(rsc-&gt;flags, pe_rsc_unique) ? &quot; (unique)&quot; : &quot;&quot;,</a>
<a name="ln439">                 is_set(rsc-&gt;flags, pe_rsc_managed) ? &quot;&quot; : &quot; (unmanaged)&quot;);</a>
<a name="ln440"> </a>
<a name="ln441">    if (options &amp; pe_print_html) {</a>
<a name="ln442">        status_print(&quot;\n&lt;ul&gt;\n&quot;);</a>
<a name="ln443"> </a>
<a name="ln444">    } else if ((options &amp; pe_print_log) == 0) {</a>
<a name="ln445">        status_print(&quot;\n&quot;);</a>
<a name="ln446">    }</a>
<a name="ln447"> </a>
<a name="ln448">    for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln449">        gboolean print_full = FALSE;</a>
<a name="ln450">        resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln451"> </a>
<a name="ln452">        if (options &amp; pe_print_clone_details) {</a>
<a name="ln453">            print_full = TRUE;</a>
<a name="ln454">        }</a>
<a name="ln455"> </a>
<a name="ln456">        if (child_rsc-&gt;fns-&gt;active(child_rsc, FALSE) == FALSE) {</a>
<a name="ln457">            /* Inactive clone */</a>
<a name="ln458">            if (is_set(child_rsc-&gt;flags, pe_rsc_orphan)) {</a>
<a name="ln459">                continue;</a>
<a name="ln460"> </a>
<a name="ln461">            } else if (is_set(rsc-&gt;flags, pe_rsc_unique)) {</a>
<a name="ln462">                print_full = TRUE;</a>
<a name="ln463"> </a>
<a name="ln464">            } else if (is_not_set(options, pe_print_clone_active)) {</a>
<a name="ln465">                stopped_list = add_list_element(stopped_list, child_rsc-&gt;id);</a>
<a name="ln466">            }</a>
<a name="ln467"> </a>
<a name="ln468">        } else if (is_set_recursive(child_rsc, pe_rsc_unique, TRUE)</a>
<a name="ln469">                   || is_set_recursive(child_rsc, pe_rsc_orphan, TRUE)</a>
<a name="ln470">                   || is_set_recursive(child_rsc, pe_rsc_managed, FALSE) == FALSE</a>
<a name="ln471">                   || is_set_recursive(child_rsc, pe_rsc_failed, TRUE)) {</a>
<a name="ln472"> </a>
<a name="ln473">            /* Unique, unmanaged or failed clone */</a>
<a name="ln474">            print_full = TRUE;</a>
<a name="ln475"> </a>
<a name="ln476">        } else if (is_set(options, pe_print_pending) &amp;&amp; child_rsc-&gt;pending_task != NULL) {</a>
<a name="ln477">            /* In a pending state */</a>
<a name="ln478">            print_full = TRUE;</a>
<a name="ln479"> </a>
<a name="ln480">        } else if (child_rsc-&gt;fns-&gt;active(child_rsc, TRUE)) {</a>
<a name="ln481">            /* Fully active anonymous clone */</a>
<a name="ln482">            node_t *location = child_rsc-&gt;fns-&gt;location(child_rsc, NULL, TRUE);</a>
<a name="ln483"> </a>
<a name="ln484">            if (location) {</a>
<a name="ln485">                enum rsc_role_e a_role = child_rsc-&gt;fns-&gt;state(child_rsc, TRUE);</a>
<a name="ln486"> </a>
<a name="ln487">                if (location-&gt;details-&gt;online == FALSE &amp;&amp; location-&gt;details-&gt;unclean) {</a>
<a name="ln488">                    print_full = TRUE;</a>
<a name="ln489"> </a>
<a name="ln490">                } else if (a_role &gt; RSC_ROLE_SLAVE) {</a>
<a name="ln491">                    /* And active on a single node as master */</a>
<a name="ln492">                    master_list = g_list_append(master_list, location);</a>
<a name="ln493"> </a>
<a name="ln494">                } else {</a>
<a name="ln495">                    /* And active on a single node as started/slave */</a>
<a name="ln496">                    started_list = g_list_append(started_list, location);</a>
<a name="ln497">                }</a>
<a name="ln498"> </a>
<a name="ln499">            } else {</a>
<a name="ln500">                /* uncolocated group - bleh */</a>
<a name="ln501">                print_full = TRUE;</a>
<a name="ln502">            }</a>
<a name="ln503"> </a>
<a name="ln504">        } else {</a>
<a name="ln505">            /* Partially active anonymous clone */</a>
<a name="ln506">            print_full = TRUE;</a>
<a name="ln507">        }</a>
<a name="ln508"> </a>
<a name="ln509">        if (print_full) {</a>
<a name="ln510">            if (options &amp; pe_print_html) {</a>
<a name="ln511">                status_print(&quot;&lt;li&gt;\n&quot;);</a>
<a name="ln512">            }</a>
<a name="ln513">            child_rsc-&gt;fns-&gt;print(child_rsc, child_text, options, print_data);</a>
<a name="ln514">            if (options &amp; pe_print_html) {</a>
<a name="ln515">                status_print(&quot;&lt;/li&gt;\n&quot;);</a>
<a name="ln516">            }</a>
<a name="ln517">        }</a>
<a name="ln518">    }</a>
<a name="ln519"> </a>
<a name="ln520">    /* Masters */</a>
<a name="ln521">    master_list = g_list_sort(master_list, sort_node_uname);</a>
<a name="ln522">    for (gIter = master_list; gIter; gIter = gIter-&gt;next) {</a>
<a name="ln523">        node_t *host = gIter-&gt;data;</a>
<a name="ln524"> </a>
<a name="ln525">        list_text = add_list_element(list_text, host-&gt;details-&gt;uname);</a>
<a name="ln526">	active_instances++;</a>
<a name="ln527">    }</a>
<a name="ln528"> </a>
<a name="ln529">    short_print(list_text, child_text, &quot;Masters&quot;, NULL, options, print_data);</a>
<a name="ln530">    g_list_free(master_list);</a>
<a name="ln531">    free(list_text);</a>
<a name="ln532">    list_text = NULL;</a>
<a name="ln533"> </a>
<a name="ln534">    /* Started/Slaves */</a>
<a name="ln535">    started_list = g_list_sort(started_list, sort_node_uname);</a>
<a name="ln536">    for (gIter = started_list; gIter; gIter = gIter-&gt;next) {</a>
<a name="ln537">        node_t *host = gIter-&gt;data;</a>
<a name="ln538"> </a>
<a name="ln539">        list_text = add_list_element(list_text, host-&gt;details-&gt;uname);</a>
<a name="ln540">	active_instances++;</a>
<a name="ln541">    }</a>
<a name="ln542"> </a>
<a name="ln543">    if(rsc-&gt;variant == pe_master) {</a>
<a name="ln544">        enum rsc_role_e role = configured_role(rsc);</a>
<a name="ln545"> </a>
<a name="ln546">        if(role == RSC_ROLE_SLAVE) {</a>
<a name="ln547">            short_print(list_text, child_text, &quot;Slaves (target-role)&quot;, NULL, options, print_data);</a>
<a name="ln548">        } else {</a>
<a name="ln549">            short_print(list_text, child_text, &quot;Slaves&quot;, NULL, options, print_data);</a>
<a name="ln550">        }</a>
<a name="ln551"> </a>
<a name="ln552">    } else {</a>
<a name="ln553">        short_print(list_text, child_text, &quot;Started&quot;, NULL, options, print_data);</a>
<a name="ln554">    }</a>
<a name="ln555"> </a>
<a name="ln556">    g_list_free(started_list);</a>
<a name="ln557">    free(list_text);</a>
<a name="ln558">    list_text = NULL;</a>
<a name="ln559"> </a>
<a name="ln560">    if (is_not_set(options, pe_print_clone_active)) {</a>
<a name="ln561">        const char *state = &quot;Stopped&quot;;</a>
<a name="ln562">        enum rsc_role_e role = configured_role(rsc);</a>
<a name="ln563"> </a>
<a name="ln564">        if (role == RSC_ROLE_STOPPED) {</a>
<a name="ln565">            state = &quot;Stopped (disabled)&quot;;</a>
<a name="ln566">        }</a>
<a name="ln567"> </a>
<a name="ln568">        if (is_not_set(rsc-&gt;flags, pe_rsc_unique)</a>
<a name="ln569">            &amp;&amp; (clone_data-&gt;clone_max &gt; active_instances)) {</a>
<a name="ln570"> </a>
<a name="ln571">            GListPtr nIter;</a>
<a name="ln572">            GListPtr list = g_hash_table_get_values(rsc-&gt;allowed_nodes);</a>
<a name="ln573"> </a>
<a name="ln574">            /* Custom stopped list for non-unique clones */</a>
<a name="ln575">            free(stopped_list); stopped_list = NULL;</a>
<a name="ln576"> </a>
<a name="ln577">            if (g_list_length(list) == 0) {</a>
<a name="ln578">                /* Clusters with symmetrical=false haven't calculated allowed_nodes yet</a>
<a name="ln579">                 * If we've not probed for them yet, the Stopped list will be empty</a>
<a name="ln580">                 */</a>
<a name="ln581">                list = g_hash_table_get_values(rsc-&gt;known_on);</a>
<a name="ln582">            }</a>
<a name="ln583"> </a>
<a name="ln584">            list = g_list_sort(list, sort_node_uname);</a>
<a name="ln585">            for (nIter = list; nIter != NULL; nIter = nIter-&gt;next) {</a>
<a name="ln586">                node_t *node = (node_t *)nIter-&gt;data;</a>
<a name="ln587"> </a>
<a name="ln588">                if (pe_find_node(rsc-&gt;running_on, node-&gt;details-&gt;uname) == NULL) {</a>
<a name="ln589">                    stopped_list = add_list_element(stopped_list, node-&gt;details-&gt;uname);</a>
<a name="ln590">                }</a>
<a name="ln591">            }</a>
<a name="ln592">            g_list_free(list);</a>
<a name="ln593">        }</a>
<a name="ln594"> </a>
<a name="ln595">        short_print(stopped_list, child_text, state, NULL, options, print_data);</a>
<a name="ln596">        free(stopped_list);</a>
<a name="ln597">    }</a>
<a name="ln598"> </a>
<a name="ln599">    if (options &amp; pe_print_html) {</a>
<a name="ln600">        status_print(&quot;&lt;/ul&gt;\n&quot;);</a>
<a name="ln601">    }</a>
<a name="ln602"> </a>
<a name="ln603">    free(child_text);</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">void</a>
<a name="ln607">clone_free(resource_t * rsc)</a>
<a name="ln608">{</a>
<a name="ln609">    GListPtr gIter = rsc-&gt;children;</a>
<a name="ln610">    clone_variant_data_t *clone_data = NULL;</a>
<a name="ln611"> </a>
<a name="ln612">    get_clone_variant_data(clone_data, rsc);</a>
<a name="ln613"> </a>
<a name="ln614">    pe_rsc_trace(rsc, &quot;Freeing %s&quot;, rsc-&gt;id);</a>
<a name="ln615"> </a>
<a name="ln616">    for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln617">        resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln618"> </a>
<a name="ln619">        CRM_ASSERT(child_rsc);</a>
<a name="ln620">        pe_rsc_trace(child_rsc, &quot;Freeing child %s&quot;, child_rsc-&gt;id);</a>
<a name="ln621">        free_xml(child_rsc-&gt;xml);</a>
<a name="ln622">        child_rsc-&gt;xml = NULL;</a>
<a name="ln623">        /* There could be a saved unexpanded xml */</a>
<a name="ln624">        free_xml(child_rsc-&gt;orig_xml);</a>
<a name="ln625">        child_rsc-&gt;orig_xml = NULL;</a>
<a name="ln626">        child_rsc-&gt;fns-&gt;free(child_rsc);</a>
<a name="ln627">    }</a>
<a name="ln628"> </a>
<a name="ln629">    g_list_free(rsc-&gt;children);</a>
<a name="ln630"> </a>
<a name="ln631">    if (clone_data) {</a>
<a name="ln632">        CRM_ASSERT(clone_data-&gt;demote_notify == NULL);</a>
<a name="ln633">        CRM_ASSERT(clone_data-&gt;stop_notify == NULL);</a>
<a name="ln634">        CRM_ASSERT(clone_data-&gt;start_notify == NULL);</a>
<a name="ln635">        CRM_ASSERT(clone_data-&gt;promote_notify == NULL);</a>
<a name="ln636">    }</a>
<a name="ln637"> </a>
<a name="ln638">    common_free(rsc);</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641">enum rsc_role_e</a>
<a name="ln642">clone_resource_state(const resource_t * rsc, gboolean current)</a>
<a name="ln643">{</a>
<a name="ln644">    enum rsc_role_e clone_role = RSC_ROLE_UNKNOWN;</a>
<a name="ln645">    GListPtr gIter = rsc-&gt;children;</a>
<a name="ln646"> </a>
<a name="ln647">    for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln648">        resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln649">        enum rsc_role_e a_role = child_rsc-&gt;fns-&gt;state(child_rsc, current);</a>
<a name="ln650"> </a>
<a name="ln651">        if (a_role &gt; clone_role) {</a>
<a name="ln652">            clone_role = a_role;</a>
<a name="ln653">        }</a>
<a name="ln654">    }</a>
<a name="ln655"> </a>
<a name="ln656">    pe_rsc_trace(rsc, &quot;%s role: %s&quot;, rsc-&gt;id, role2text(clone_role));</a>
<a name="ln657">    return clone_role;</a>
<a name="ln658">}</a>

</code></pre>
<div class="balloon" rel="144"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_replace' function. Inspect the second argument. Check lines: 144, 144.</p></div>
<div class="balloon" rel="175"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'clone_data'. Check lines: 175, 173.</p></div>
<div class="balloon" rel="303"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V571/" target="_blank">V571</a> Recurring check. The 'if (options & pe_print_html)' condition was already verified in line 302.</p></div>
<div class="balloon" rel="308"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V571/" target="_blank">V571</a> Recurring check. The 'if (options & pe_print_html)' condition was already verified in line 307.</p></div>
<div class="balloon" rel="442"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V571/" target="_blank">V571</a> Recurring check. The 'if (options & pe_print_html)' condition was already verified in line 441.</p></div>
<div class="balloon" rel="511"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V571/" target="_blank">V571</a> Recurring check. The 'if (options & pe_print_html)' condition was already verified in line 510.</p></div>
<div class="balloon" rel="515"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V571/" target="_blank">V571</a> Recurring check. The 'if (options & pe_print_html)' condition was already verified in line 514.</p></div>
<div class="balloon" rel="581"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V773/" target="_blank">V773</a> The 'list' pointer was assigned values twice without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="600"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V571/" target="_blank">V571</a> Recurring check. The 'if (options & pe_print_html)' condition was already verified in line 599.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
