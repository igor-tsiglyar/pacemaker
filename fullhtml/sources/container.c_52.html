
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/* </a>
<a name="ln6"> * Copyright (C) 2004 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> * </a>
<a name="ln8"> * This program is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2 of the License, or (at your option) any later version.</a>
<a name="ln12"> * </a>
<a name="ln13"> * This software is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> * </a>
<a name="ln18"> * You should have received a copy of the GNU General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;crm_internal.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;crm/msg_xml.h&gt;</a>
<a name="ln26">#include &lt;allocate.h&gt;</a>
<a name="ln27">#include &lt;notif.h&gt;</a>
<a name="ln28">#include &lt;utils.h&gt;</a>
<a name="ln29">#include &lt;allocate.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#define VARIANT_CONTAINER 1</a>
<a name="ln32">#include &lt;lib/pengine/variant.h&gt;</a>
<a name="ln33"> </a>
<a name="ln34">static bool</a>
<a name="ln35">is_child_container_node(container_variant_data_t *data, pe_node_t *node)</a>
<a name="ln36">{</a>
<a name="ln37">    for (GListPtr gIter = data-&gt;tuples; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln38">        container_grouping_t *tuple = (container_grouping_t *)gIter-&gt;data;</a>
<a name="ln39">        if(node-&gt;details == tuple-&gt;node-&gt;details) {</a>
<a name="ln40">            return TRUE;</a>
<a name="ln41">        }</a>
<a name="ln42">    }</a>
<a name="ln43">    return FALSE;</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46">gint sort_clone_instance(gconstpointer a, gconstpointer b, gpointer data_set);</a>
<a name="ln47">void distribute_children(resource_t *rsc, GListPtr children, GListPtr nodes,</a>
<a name="ln48">                         int max, int per_host_max, pe_working_set_t * data_set);</a>
<a name="ln49"> </a>
<a name="ln50">node_t *</a>
<a name="ln51">container_color(resource_t * rsc, node_t * prefer, pe_working_set_t * data_set)</a>
<a name="ln52">{</a>
<a name="ln53">    GListPtr containers = NULL;</a>
<a name="ln54">    GListPtr nodes = NULL;</a>
<a name="ln55">    container_variant_data_t *container_data = NULL;</a>
<a name="ln56"> </a>
<a name="ln57">    CRM_CHECK(rsc != NULL, return NULL);</a>
<a name="ln58"> </a>
<a name="ln59">    get_container_variant_data(container_data, rsc);</a>
<a name="ln60"> </a>
<a name="ln61">    set_bit(rsc-&gt;flags, pe_rsc_allocating);</a>
<a name="ln62"> </a>
<a name="ln63">    for (GListPtr gIter = container_data-&gt;tuples; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln64">        container_grouping_t *tuple = (container_grouping_t *)gIter-&gt;data;</a>
<a name="ln65">        containers = g_list_append(containers, tuple-&gt;docker);</a>
<a name="ln66">    }</a>
<a name="ln67"> </a>
<a name="ln68">    dump_node_scores(show_scores ? 0 : scores_log_level, rsc, __FUNCTION__, rsc-&gt;allowed_nodes);</a>
<a name="ln69"> </a>
<a name="ln70">    nodes = g_hash_table_get_values(rsc-&gt;allowed_nodes);</a>
<a name="ln71">    nodes = g_list_sort_with_data(nodes, sort_node_weight, NULL);</a>
<a name="ln72">    containers = g_list_sort_with_data(containers, sort_clone_instance, data_set);</a>
<a name="ln73">    distribute_children(rsc, containers, nodes,</a>
<a name="ln74">                        container_data-&gt;replicas, container_data-&gt;replicas_per_host, data_set);</a>
<a name="ln75">    g_list_free(nodes);</a>
<a name="ln76">    g_list_free(containers);</a>
<a name="ln77"> </a>
<a name="ln78">    for (GListPtr gIter = container_data-&gt;tuples; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln79">        container_grouping_t *tuple = (container_grouping_t *)gIter-&gt;data;</a>
<a name="ln80"> </a>
<a name="ln81">        CRM_ASSERT(tuple);</a>
<a name="ln82">        if(tuple-&gt;ip) {</a>
<a name="ln83">            tuple-&gt;ip-&gt;cmds-&gt;allocate(tuple-&gt;ip, prefer, data_set);</a>
<a name="ln84">        }</a>
<a name="ln85">        if(tuple-&gt;remote) {</a>
<a name="ln86">            tuple-&gt;remote-&gt;cmds-&gt;allocate(tuple-&gt;remote, prefer, data_set);</a>
<a name="ln87">        }</a>
<a name="ln88"> </a>
<a name="ln89">        // Explicitly allocate tuple-&gt;child before the container-&gt;child</a>
<a name="ln90">        if(tuple-&gt;child) {</a>
<a name="ln91">            pe_node_t *node = NULL;</a>
<a name="ln92">            GHashTableIter iter;</a>
<a name="ln93">            g_hash_table_iter_init(&amp;iter, tuple-&gt;child-&gt;allowed_nodes);</a>
<a name="ln94">            while (g_hash_table_iter_next(&amp;iter, NULL, (gpointer *) &amp; node)) {</a>
<a name="ln95">                if(node-&gt;details != tuple-&gt;node-&gt;details) {</a>
<a name="ln96">                    node-&gt;weight = -INFINITY;</a>
<a name="ln97">                } else {</a>
<a name="ln98">                    node-&gt;weight = INFINITY;</a>
<a name="ln99">                }</a>
<a name="ln100">            }</a>
<a name="ln101"> </a>
<a name="ln102">            set_bit(tuple-&gt;child-&gt;parent-&gt;flags, pe_rsc_allocating);</a>
<a name="ln103">            tuple-&gt;child-&gt;cmds-&gt;allocate(tuple-&gt;child, tuple-&gt;node, data_set);</a>
<a name="ln104">            clear_bit(tuple-&gt;child-&gt;parent-&gt;flags, pe_rsc_allocating);</a>
<a name="ln105">        }</a>
<a name="ln106">    }</a>
<a name="ln107"> </a>
<a name="ln108">    if(container_data-&gt;child) {</a>
<a name="ln109">        pe_node_t *node = NULL;</a>
<a name="ln110">        GHashTableIter iter;</a>
<a name="ln111">        g_hash_table_iter_init(&amp;iter, container_data-&gt;child-&gt;allowed_nodes);</a>
<a name="ln112">        while (g_hash_table_iter_next(&amp;iter, NULL, (gpointer *) &amp; node)) {</a>
<a name="ln113">            if(is_child_container_node(container_data, node)) {</a>
<a name="ln114">                node-&gt;weight = 0;</a>
<a name="ln115">            } else {</a>
<a name="ln116">                node-&gt;weight = -INFINITY;</a>
<a name="ln117">            }</a>
<a name="ln118">        }</a>
<a name="ln119">        container_data-&gt;child-&gt;cmds-&gt;allocate(container_data-&gt;child, prefer, data_set);</a>
<a name="ln120">    }</a>
<a name="ln121"> </a>
<a name="ln122">    clear_bit(rsc-&gt;flags, pe_rsc_allocating);</a>
<a name="ln123">    return NULL;</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">void</a>
<a name="ln127">container_create_actions(resource_t * rsc, pe_working_set_t * data_set)</a>
<a name="ln128">{</a>
<a name="ln129">    container_variant_data_t *container_data = NULL;</a>
<a name="ln130"> </a>
<a name="ln131">    CRM_CHECK(rsc != NULL, return);</a>
<a name="ln132"> </a>
<a name="ln133">    get_container_variant_data(container_data, rsc);</a>
<a name="ln134">    for (GListPtr gIter = container_data-&gt;tuples; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln135">        container_grouping_t *tuple = (container_grouping_t *)gIter-&gt;data;</a>
<a name="ln136"> </a>
<a name="ln137">        CRM_ASSERT(tuple);</a>
<a name="ln138">        if(tuple-&gt;ip) {</a>
<a name="ln139">            tuple-&gt;ip-&gt;cmds-&gt;create_actions(tuple-&gt;ip, data_set);</a>
<a name="ln140">        }</a>
<a name="ln141">        if(tuple-&gt;docker) {</a>
<a name="ln142">            tuple-&gt;docker-&gt;cmds-&gt;create_actions(tuple-&gt;docker, data_set);</a>
<a name="ln143">        }</a>
<a name="ln144">        if(tuple-&gt;remote) {</a>
<a name="ln145">            tuple-&gt;remote-&gt;cmds-&gt;create_actions(tuple-&gt;remote, data_set);</a>
<a name="ln146">        }</a>
<a name="ln147">    }</a>
<a name="ln148"> </a>
<a name="ln149">    if(container_data-&gt;child) {</a>
<a name="ln150">        container_data-&gt;child-&gt;cmds-&gt;create_actions(container_data-&gt;child, data_set);</a>
<a name="ln151">    }</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">void</a>
<a name="ln155">container_internal_constraints(resource_t * rsc, pe_working_set_t * data_set)</a>
<a name="ln156">{</a>
<a name="ln157">    container_variant_data_t *container_data = NULL;</a>
<a name="ln158"> </a>
<a name="ln159">    CRM_CHECK(rsc != NULL, return);</a>
<a name="ln160"> </a>
<a name="ln161">    get_container_variant_data(container_data, rsc);</a>
<a name="ln162">    for (GListPtr gIter = container_data-&gt;tuples; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln163">        char *id = NULL;</a>
<a name="ln164">        container_grouping_t *tuple = (container_grouping_t *)gIter-&gt;data;</a>
<a name="ln165"> </a>
<a name="ln166">        CRM_ASSERT(tuple);</a>
<a name="ln167">        if(tuple-&gt;docker) {</a>
<a name="ln168">            tuple-&gt;docker-&gt;cmds-&gt;internal_constraints(tuple-&gt;docker, data_set);</a>
<a name="ln169">        }</a>
<a name="ln170"> </a>
<a name="ln171">        if(tuple-&gt;ip) {</a>
<a name="ln172">            tuple-&gt;ip-&gt;cmds-&gt;internal_constraints(tuple-&gt;ip, data_set);</a>
<a name="ln173"> </a>
<a name="ln174">            // Start ip then docker</a>
<a name="ln175">            new_rsc_order(tuple-&gt;ip, RSC_START, tuple-&gt;docker, RSC_START, pe_order_runnable_left, data_set);</a>
<a name="ln176">            new_rsc_order(tuple-&gt;docker, RSC_STOP, tuple-&gt;ip, RSC_STOP, pe_order_implies_first, data_set);</a>
<a name="ln177"> </a>
<a name="ln178">            id = crm_strdup_printf(&quot;%s-ip-with-docker-%d&quot;, rsc-&gt;id, tuple-&gt;offset);</a>
<a name="ln179">            rsc_colocation_new(id, NULL, INFINITY, tuple-&gt;ip, tuple-&gt;docker, NULL, NULL, data_set);</a>
<a name="ln180">            free(id);</a>
<a name="ln181">        }</a>
<a name="ln182"> </a>
<a name="ln183">        if(tuple-&gt;remote) {</a>
<a name="ln184">            tuple-&gt;remote-&gt;cmds-&gt;internal_constraints(tuple-&gt;remote, data_set);</a>
<a name="ln185">            // Start docker then remote</a>
<a name="ln186">            new_rsc_order(</a>
<a name="ln187">                tuple-&gt;docker, RSC_START, tuple-&gt;remote, RSC_START, pe_order_runnable_left, data_set);</a>
<a name="ln188">            new_rsc_order(</a>
<a name="ln189">                tuple-&gt;remote, RSC_STOP, tuple-&gt;docker, RSC_STOP, pe_order_implies_first, data_set);</a>
<a name="ln190"> </a>
<a name="ln191">            if(tuple-&gt;ip) {</a>
<a name="ln192">                id = crm_strdup_printf(&quot;%s-remote-with-ip-%d&quot;, rsc-&gt;id, tuple-&gt;offset);</a>
<a name="ln193">                rsc_colocation_new(id, NULL, INFINITY, tuple-&gt;remote, tuple-&gt;ip, NULL, NULL, data_set);</a>
<a name="ln194">                free(id);</a>
<a name="ln195">//            } else {</a>
<a name="ln196">                // remote-with-docker is already handled in native_internal_constraints() by 'resource-with-container'</a>
<a name="ln197">            }</a>
<a name="ln198">        }</a>
<a name="ln199"> </a>
<a name="ln200">        if(tuple-&gt;child) {</a>
<a name="ln201">            CRM_ASSERT(tuple-&gt;remote);</a>
<a name="ln202"> </a>
<a name="ln203">            // Start of the remote then child is implicit in the PE's remote logic</a>
<a name="ln204">        }</a>
<a name="ln205"> </a>
<a name="ln206">    }</a>
<a name="ln207"> </a>
<a name="ln208">    if(container_data-&gt;child) {</a>
<a name="ln209">        container_data-&gt;child-&gt;cmds-&gt;internal_constraints(container_data-&gt;child, data_set);</a>
<a name="ln210">    }</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">void</a>
<a name="ln214">container_rsc_colocation_lh(resource_t * rsc_lh, resource_t * rsc_rh, rsc_colocation_t * constraint)</a>
<a name="ln215">{</a>
<a name="ln216">    pe_err(&quot;Container %s cannot be colocated with anything&quot;, rsc_lh-&gt;id);</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">void</a>
<a name="ln220">container_rsc_colocation_rh(resource_t * rsc_lh, resource_t * rsc_rh, rsc_colocation_t * constraint)</a>
<a name="ln221">{</a>
<a name="ln222">    pe_err(&quot;Container %s cannot be colocated with anything&quot;, rsc_rh-&gt;id);</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">enum pe_action_flags</a>
<a name="ln226">container_action_flags(action_t * action, node_t * node)</a>
<a name="ln227">{</a>
<a name="ln228">    enum pe_action_flags flags = (pe_action_optional | pe_action_runnable | pe_action_pseudo);</a>
<a name="ln229">    return flags;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232"> </a>
<a name="ln233">enum pe_graph_flags</a>
<a name="ln234">container_update_actions(action_t * first, action_t * then, node_t * node, enum pe_action_flags flags,</a>
<a name="ln235">                     enum pe_action_flags filter, enum pe_ordering type)</a>
<a name="ln236">{</a>
<a name="ln237">    enum pe_graph_flags changed = pe_graph_none;</a>
<a name="ln238">    return changed;</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">void</a>
<a name="ln242">container_rsc_location(resource_t * rsc, rsc_to_node_t * constraint)</a>
<a name="ln243">{</a>
<a name="ln244">    GListPtr gIter = rsc-&gt;children;</a>
<a name="ln245"> </a>
<a name="ln246">    pe_rsc_trace(rsc, &quot;Processing location constraint %s for %s&quot;, constraint-&gt;id, rsc-&gt;id);</a>
<a name="ln247"> </a>
<a name="ln248">    native_rsc_location(rsc, constraint);</a>
<a name="ln249"> </a>
<a name="ln250">    for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln251">        resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln252"> </a>
<a name="ln253">        child_rsc-&gt;cmds-&gt;rsc_location(child_rsc, constraint);</a>
<a name="ln254">    }</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">void</a>
<a name="ln258">container_expand(resource_t * rsc, pe_working_set_t * data_set)</a>
<a name="ln259">{</a>
<a name="ln260">    container_variant_data_t *container_data = NULL;</a>
<a name="ln261"> </a>
<a name="ln262">    CRM_CHECK(rsc != NULL, return);</a>
<a name="ln263"> </a>
<a name="ln264">    get_container_variant_data(container_data, rsc);</a>
<a name="ln265">    for (GListPtr gIter = container_data-&gt;tuples; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln266">        container_grouping_t *tuple = (container_grouping_t *)gIter-&gt;data;</a>
<a name="ln267"> </a>
<a name="ln268"> </a>
<a name="ln269">        CRM_ASSERT(tuple);</a>
<a name="ln270">        if(fix_remote_addr(tuple-&gt;remote) &amp;&amp; tuple-&gt;docker-&gt;allocated_to) {</a>
<a name="ln271">            // REMOTE_CONTAINER_HACK: Allow remote nodes that start containers with pacemaker remote inside</a>
<a name="ln272">            xmlNode *nvpair = get_xpath_object(&quot;//nvpair[@name='addr']&quot;, tuple-&gt;remote-&gt;xml, LOG_ERR);</a>
<a name="ln273"> </a>
<a name="ln274">            g_hash_table_replace(tuple-&gt;remote-&gt;parameters, strdup(&quot;addr&quot;), strdup(tuple-&gt;docker-&gt;allocated_to-&gt;details-&gt;uname));</a>
<a name="ln275">            crm_xml_add(nvpair, &quot;value&quot;, tuple-&gt;docker-&gt;allocated_to-&gt;details-&gt;uname);</a>
<a name="ln276">        }</a>
<a name="ln277">        if(tuple-&gt;ip) {</a>
<a name="ln278">            tuple-&gt;ip-&gt;cmds-&gt;expand(tuple-&gt;ip, data_set);</a>
<a name="ln279">        }</a>
<a name="ln280">        if(tuple-&gt;child) {</a>
<a name="ln281">            tuple-&gt;child-&gt;cmds-&gt;expand(tuple-&gt;child, data_set);</a>
<a name="ln282">        }</a>
<a name="ln283">        if(tuple-&gt;docker) {</a>
<a name="ln284">            tuple-&gt;docker-&gt;cmds-&gt;expand(tuple-&gt;docker, data_set);</a>
<a name="ln285">        }</a>
<a name="ln286">        if(tuple-&gt;remote) {</a>
<a name="ln287">            tuple-&gt;remote-&gt;cmds-&gt;expand(tuple-&gt;remote, data_set);</a>
<a name="ln288">        }</a>
<a name="ln289">    }</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">gboolean</a>
<a name="ln293">container_create_probe(resource_t * rsc, node_t * node, action_t * complete,</a>
<a name="ln294">                   gboolean force, pe_working_set_t * data_set)</a>
<a name="ln295">{</a>
<a name="ln296">    bool any_created = FALSE;</a>
<a name="ln297">    container_variant_data_t *container_data = NULL;</a>
<a name="ln298"> </a>
<a name="ln299">    CRM_CHECK(rsc != NULL, return FALSE);</a>
<a name="ln300"> </a>
<a name="ln301">    get_container_variant_data(container_data, rsc);</a>
<a name="ln302">    for (GListPtr gIter = container_data-&gt;tuples; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln303">        container_grouping_t *tuple = (container_grouping_t *)gIter-&gt;data;</a>
<a name="ln304"> </a>
<a name="ln305">        CRM_ASSERT(tuple);</a>
<a name="ln306">        if(tuple-&gt;ip) {</a>
<a name="ln307">            any_created |= tuple-&gt;ip-&gt;cmds-&gt;create_probe(tuple-&gt;ip, node, complete, force, data_set);</a>
<a name="ln308">        }</a>
<a name="ln309">        if(tuple-&gt;child &amp;&amp; node-&gt;details == tuple-&gt;node-&gt;details) {</a>
<a name="ln310">            any_created |= tuple-&gt;child-&gt;cmds-&gt;create_probe(tuple-&gt;child, node, complete, force, data_set);</a>
<a name="ln311">        }</a>
<a name="ln312">        if(tuple-&gt;docker) {</a>
<a name="ln313">            bool created = tuple-&gt;docker-&gt;cmds-&gt;create_probe(tuple-&gt;docker, node, complete, force, data_set);</a>
<a name="ln314"> </a>
<a name="ln315">            if(created) {</a>
<a name="ln316">                any_created = TRUE;</a>
<a name="ln317">                /* If we're limited to one replica per host (due to</a>
<a name="ln318">                 * the lack of an IP range probably), then we don't</a>
<a name="ln319">                 * want any of our peer containers starting until</a>
<a name="ln320">                 * we've established that no other copies are already</a>
<a name="ln321">                 * running.</a>
<a name="ln322">                 *</a>
<a name="ln323">                 * Partly this is to ensure that replicas_per_host is</a>
<a name="ln324">                 * observed, but also to ensure that the containers</a>
<a name="ln325">                 * don't fail to start because the necessary port</a>
<a name="ln326">                 * mappings (which won't include an IP for uniqueness)</a>
<a name="ln327">                 * are already taken</a>
<a name="ln328">                 */</a>
<a name="ln329"> </a>
<a name="ln330">                for (GListPtr tIter = container_data-&gt;tuples; tIter != NULL &amp;&amp; container_data-&gt;replicas_per_host == 1; tIter = tIter-&gt;next) {</a>
<a name="ln331">                    container_grouping_t *other = (container_grouping_t *)tIter-&gt;data;</a>
<a name="ln332"> </a>
<a name="ln333">                    if ((other != tuple) &amp;&amp; (other != NULL)</a>
<a name="ln334">                        &amp;&amp; (other-&gt;docker != NULL)) {</a>
<a name="ln335"> </a>
<a name="ln336">                        custom_action_order(tuple-&gt;docker, generate_op_key(tuple-&gt;docker-&gt;id, RSC_STATUS, 0), NULL,</a>
<a name="ln337">                                            other-&gt;docker, generate_op_key(other-&gt;docker-&gt;id, RSC_START, 0), NULL,</a>
<a name="ln338">                                            pe_order_optional, data_set);</a>
<a name="ln339">                    }</a>
<a name="ln340">                }</a>
<a name="ln341">            }</a>
<a name="ln342">        }</a>
<a name="ln343">        if(FALSE &amp;&amp; tuple-&gt;remote) {</a>
<a name="ln344">            // TODO: Needed?</a>
<a name="ln345">            any_created |= tuple-&gt;remote-&gt;cmds-&gt;create_probe(tuple-&gt;remote, node, complete, force, data_set);</a>
<a name="ln346">        }</a>
<a name="ln347">    }</a>
<a name="ln348">    return any_created;</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">void</a>
<a name="ln352">container_append_meta(resource_t * rsc, xmlNode * xml)</a>
<a name="ln353">{</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">GHashTable *</a>
<a name="ln357">container_merge_weights(resource_t * rsc, const char *rhs, GHashTable * nodes, const char *attr,</a>
<a name="ln358">                    float factor, enum pe_weights flags)</a>
<a name="ln359">{</a>
<a name="ln360">    return rsc_merge_weights(rsc, rhs, nodes, attr, factor, flags);</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">void container_LogActions(</a>
<a name="ln364">    resource_t * rsc, pe_working_set_t * data_set, gboolean terminal)</a>
<a name="ln365">{</a>
<a name="ln366">    container_variant_data_t *container_data = NULL;</a>
<a name="ln367"> </a>
<a name="ln368">    CRM_CHECK(rsc != NULL, return);</a>
<a name="ln369"> </a>
<a name="ln370">    get_container_variant_data(container_data, rsc);</a>
<a name="ln371">    for (GListPtr gIter = container_data-&gt;tuples; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln372">        container_grouping_t *tuple = (container_grouping_t *)gIter-&gt;data;</a>
<a name="ln373"> </a>
<a name="ln374">        CRM_ASSERT(tuple);</a>
<a name="ln375">        if(tuple-&gt;ip) {</a>
<a name="ln376">            LogActions(tuple-&gt;ip, data_set, terminal);</a>
<a name="ln377">        }</a>
<a name="ln378">        if(tuple-&gt;docker) {</a>
<a name="ln379">            LogActions(tuple-&gt;docker, data_set, terminal);</a>
<a name="ln380">        }</a>
<a name="ln381">        if(tuple-&gt;remote) {</a>
<a name="ln382">            LogActions(tuple-&gt;remote, data_set, terminal);</a>
<a name="ln383">        }</a>
<a name="ln384">        if(tuple-&gt;child) {</a>
<a name="ln385">            LogActions(tuple-&gt;child, data_set, terminal);</a>
<a name="ln386">        }</a>
<a name="ln387">    }</a>
<a name="ln388">}</a>

</code></pre>
<div class="balloon" rel="274"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_replace' function. Inspect the second argument. Check lines: 274, 274.</p></div>
<div class="balloon" rel="275"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V595/" target="_blank">V595</a> The 'tuple->docker' pointer was utilized before it was verified against nullptr. Check lines: 275, 283.</p></div>
<div class="balloon" rel="274"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V595/" target="_blank">V595</a> The 'tuple->remote' pointer was utilized before it was verified against nullptr. Check lines: 274, 286.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
