
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (C) 2004 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * This program is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2 of the License, or (at your option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This software is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;crm_internal.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;sys/param.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;crm/crm.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;crm/msg_xml.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &lt;crm/pengine/rules.h&gt;</a>
<a name="ln32">#include &lt;crm/cluster/internal.h&gt;</a>
<a name="ln33">#include &lt;crm/cluster/election.h&gt;</a>
<a name="ln34">#include &lt;crm/common/ipcs.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;crmd.h&gt;</a>
<a name="ln37">#include &lt;crmd_fsa.h&gt;</a>
<a name="ln38">#include &lt;fsa_proto.h&gt;</a>
<a name="ln39">#include &lt;crmd_messages.h&gt;</a>
<a name="ln40">#include &lt;crmd_callbacks.h&gt;</a>
<a name="ln41">#include &lt;crmd_lrm.h&gt;</a>
<a name="ln42">#include &lt;tengine.h&gt;</a>
<a name="ln43">#include &lt;throttle.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;sys/types.h&gt;</a>
<a name="ln46">#include &lt;sys/stat.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">qb_ipcs_service_t *ipcs = NULL;</a>
<a name="ln49"> </a>
<a name="ln50">extern gboolean crm_connect_corosync(crm_cluster_t * cluster);</a>
<a name="ln51">extern void crmd_ha_connection_destroy(gpointer user_data);</a>
<a name="ln52"> </a>
<a name="ln53">void crm_shutdown(int nsig);</a>
<a name="ln54">gboolean crm_read_options(gpointer user_data);</a>
<a name="ln55"> </a>
<a name="ln56">gboolean fsa_has_quorum = FALSE;</a>
<a name="ln57">crm_trigger_t *fsa_source = NULL;</a>
<a name="ln58">crm_trigger_t *config_read = NULL;</a>
<a name="ln59">bool no_quorum_suicide_escalation = FALSE;</a>
<a name="ln60"> </a>
<a name="ln61">static gboolean</a>
<a name="ln62">election_timeout_popped(gpointer data)</a>
<a name="ln63">{</a>
<a name="ln64">    /* Not everyone voted */</a>
<a name="ln65">    crm_info(&quot;Election failed: Declaring ourselves the winner&quot;);</a>
<a name="ln66">    register_fsa_input(C_TIMER_POPPED, I_ELECTION_DC, NULL);</a>
<a name="ln67">    return FALSE;</a>
<a name="ln68">}</a>
<a name="ln69"> </a>
<a name="ln70">/*	 A_HA_CONNECT	*/</a>
<a name="ln71">void</a>
<a name="ln72">do_ha_control(long long action,</a>
<a name="ln73">              enum crmd_fsa_cause cause,</a>
<a name="ln74">              enum crmd_fsa_state cur_state,</a>
<a name="ln75">              enum crmd_fsa_input current_input, fsa_data_t * msg_data)</a>
<a name="ln76">{</a>
<a name="ln77">    gboolean registered = FALSE;</a>
<a name="ln78">    static crm_cluster_t *cluster = NULL;</a>
<a name="ln79"> </a>
<a name="ln80">    if (cluster == NULL) {</a>
<a name="ln81">        cluster = calloc(1, sizeof(crm_cluster_t));</a>
<a name="ln82">    }</a>
<a name="ln83"> </a>
<a name="ln84">    if (action &amp; A_HA_DISCONNECT) {</a>
<a name="ln85">        crm_cluster_disconnect(cluster);</a>
<a name="ln86">        crm_info(&quot;Disconnected from the cluster&quot;);</a>
<a name="ln87"> </a>
<a name="ln88">        set_bit(fsa_input_register, R_HA_DISCONNECTED);</a>
<a name="ln89">    }</a>
<a name="ln90"> </a>
<a name="ln91">    if (action &amp; A_HA_CONNECT) {</a>
<a name="ln92">        crm_set_status_callback(&amp;peer_update_callback);</a>
<a name="ln93">        crm_set_autoreap(FALSE);</a>
<a name="ln94"> </a>
<a name="ln95">        if (is_openais_cluster()) {</a>
<a name="ln96">#if SUPPORT_COROSYNC</a>
<a name="ln97">            registered = crm_connect_corosync(cluster);</a>
<a name="ln98">#endif</a>
<a name="ln99">        } else if (is_heartbeat_cluster()) {</a>
<a name="ln100">#if SUPPORT_HEARTBEAT</a>
<a name="ln101">            cluster-&gt;destroy = crmd_ha_connection_destroy;</a>
<a name="ln102">            cluster-&gt;hb_dispatch = crmd_ha_msg_callback;</a>
<a name="ln103"> </a>
<a name="ln104">            registered = crm_cluster_connect(cluster);</a>
<a name="ln105">            fsa_cluster_conn = cluster-&gt;hb_conn;</a>
<a name="ln106"> </a>
<a name="ln107">            crm_trace(&quot;Be informed of Node Status changes&quot;);</a>
<a name="ln108">            if (registered &amp;&amp;</a>
<a name="ln109">                fsa_cluster_conn-&gt;llc_ops-&gt;set_nstatus_callback(fsa_cluster_conn,</a>
<a name="ln110">                                                                crmd_ha_status_callback,</a>
<a name="ln111">                                                                fsa_cluster_conn) != HA_OK) {</a>
<a name="ln112"> </a>
<a name="ln113">                crm_err(&quot;Cannot set nstatus callback: %s&quot;,</a>
<a name="ln114">                        fsa_cluster_conn-&gt;llc_ops-&gt;errmsg(fsa_cluster_conn));</a>
<a name="ln115">                registered = FALSE;</a>
<a name="ln116">            }</a>
<a name="ln117"> </a>
<a name="ln118">            crm_trace(&quot;Be informed of CRM Client Status changes&quot;);</a>
<a name="ln119">            if (registered &amp;&amp;</a>
<a name="ln120">                fsa_cluster_conn-&gt;llc_ops-&gt;set_cstatus_callback(fsa_cluster_conn,</a>
<a name="ln121">                                                                crmd_client_status_callback,</a>
<a name="ln122">                                                                fsa_cluster_conn) != HA_OK) {</a>
<a name="ln123"> </a>
<a name="ln124">                crm_err(&quot;Cannot set cstatus callback: %s&quot;,</a>
<a name="ln125">                        fsa_cluster_conn-&gt;llc_ops-&gt;errmsg(fsa_cluster_conn));</a>
<a name="ln126">                registered = FALSE;</a>
<a name="ln127">            }</a>
<a name="ln128"> </a>
<a name="ln129">            if (registered) {</a>
<a name="ln130">                crm_trace(&quot;Requesting an initial dump of CRMD client_status&quot;);</a>
<a name="ln131">                fsa_cluster_conn-&gt;llc_ops-&gt;client_status(fsa_cluster_conn, NULL, CRM_SYSTEM_CRMD,</a>
<a name="ln132">                                                         -1);</a>
<a name="ln133">            }</a>
<a name="ln134">#endif</a>
<a name="ln135">        }</a>
<a name="ln136">        fsa_election = election_init(NULL, cluster-&gt;uname, 60000/*60s*/, election_timeout_popped);</a>
<a name="ln137">        fsa_our_uname = cluster-&gt;uname;</a>
<a name="ln138">        fsa_our_uuid = cluster-&gt;uuid;</a>
<a name="ln139">        if(cluster-&gt;uuid == NULL) {</a>
<a name="ln140">            crm_err(&quot;Could not obtain local uuid&quot;);</a>
<a name="ln141">            registered = FALSE;</a>
<a name="ln142">        }</a>
<a name="ln143"> </a>
<a name="ln144">        if (registered == FALSE) {</a>
<a name="ln145">            set_bit(fsa_input_register, R_HA_DISCONNECTED);</a>
<a name="ln146">            register_fsa_error(C_FSA_INTERNAL, I_ERROR, NULL);</a>
<a name="ln147">            return;</a>
<a name="ln148">        }</a>
<a name="ln149"> </a>
<a name="ln150">        populate_cib_nodes(node_update_none, __FUNCTION__);</a>
<a name="ln151">        clear_bit(fsa_input_register, R_HA_DISCONNECTED);</a>
<a name="ln152">        crm_info(&quot;Connected to the cluster&quot;);</a>
<a name="ln153">    }</a>
<a name="ln154"> </a>
<a name="ln155">    if (action &amp; ~(A_HA_CONNECT | A_HA_DISCONNECT)) {</a>
<a name="ln156">        crm_err(&quot;Unexpected action %s in %s&quot;, fsa_action2string(action), __FUNCTION__);</a>
<a name="ln157">    }</a>
<a name="ln158">}</a>
<a name="ln159"> </a>
<a name="ln160">static bool</a>
<a name="ln161">need_spawn_pengine_from_crmd(void)</a>
<a name="ln162">{</a>
<a name="ln163">	static int result = -1;</a>
<a name="ln164"> </a>
<a name="ln165">	if (result != -1)</a>
<a name="ln166">		return result;</a>
<a name="ln167">	if (!is_heartbeat_cluster()) {</a>
<a name="ln168">		result = 0;</a>
<a name="ln169">		return result;</a>
<a name="ln170">	}</a>
<a name="ln171"> </a>
<a name="ln172">	/* NULL, or &quot;strange&quot; value: rather spawn from here. */</a>
<a name="ln173">	result = TRUE;</a>
<a name="ln174">	crm_str_to_boolean(daemon_option(&quot;crmd_spawns_pengine&quot;), &amp;result);</a>
<a name="ln175">	return result;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">/*	 A_SHUTDOWN	*/</a>
<a name="ln179">void</a>
<a name="ln180">do_shutdown(long long action,</a>
<a name="ln181">            enum crmd_fsa_cause cause,</a>
<a name="ln182">            enum crmd_fsa_state cur_state, enum crmd_fsa_input current_input, fsa_data_t * msg_data)</a>
<a name="ln183">{</a>
<a name="ln184">    /* just in case */</a>
<a name="ln185">    set_bit(fsa_input_register, R_SHUTDOWN);</a>
<a name="ln186"> </a>
<a name="ln187">    if (need_spawn_pengine_from_crmd()) {</a>
<a name="ln188">        if (is_set(fsa_input_register, pe_subsystem-&gt;flag_connected)) {</a>
<a name="ln189">            crm_info(&quot;Terminating the %s&quot;, pe_subsystem-&gt;name);</a>
<a name="ln190">            if (stop_subsystem(pe_subsystem, TRUE) == FALSE) {</a>
<a name="ln191">                /* its gone... */</a>
<a name="ln192">                crm_err(&quot;Faking %s exit&quot;, pe_subsystem-&gt;name);</a>
<a name="ln193">                clear_bit(fsa_input_register, pe_subsystem-&gt;flag_connected);</a>
<a name="ln194">            } else {</a>
<a name="ln195">                crm_info(&quot;Waiting for subsystems to exit&quot;);</a>
<a name="ln196">                crmd_fsa_stall(FALSE);</a>
<a name="ln197">            }</a>
<a name="ln198">        }</a>
<a name="ln199">        crm_info(&quot;All subsystems stopped, continuing&quot;);</a>
<a name="ln200">    }</a>
<a name="ln201"> </a>
<a name="ln202">    if (stonith_api) {</a>
<a name="ln203">        /* Prevent it from coming up again */</a>
<a name="ln204">        clear_bit(fsa_input_register, R_ST_REQUIRED);</a>
<a name="ln205"> </a>
<a name="ln206">        crm_info(&quot;Disconnecting STONITH...&quot;);</a>
<a name="ln207">        stonith_api-&gt;cmds-&gt;disconnect(stonith_api);</a>
<a name="ln208">    }</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">/*	 A_SHUTDOWN_REQ	*/</a>
<a name="ln212">void</a>
<a name="ln213">do_shutdown_req(long long action,</a>
<a name="ln214">                enum crmd_fsa_cause cause,</a>
<a name="ln215">                enum crmd_fsa_state cur_state,</a>
<a name="ln216">                enum crmd_fsa_input current_input, fsa_data_t * msg_data)</a>
<a name="ln217">{</a>
<a name="ln218">    xmlNode *msg = NULL;</a>
<a name="ln219"> </a>
<a name="ln220">    set_bit(fsa_input_register, R_SHUTDOWN);</a>
<a name="ln221">    crm_info(&quot;Sending shutdown request to all peers (DC is %s)&quot;,</a>
<a name="ln222">             (fsa_our_dc? fsa_our_dc : &quot;not set&quot;));</a>
<a name="ln223">    msg = create_request(CRM_OP_SHUTDOWN_REQ, NULL, NULL, CRM_SYSTEM_CRMD, CRM_SYSTEM_CRMD, NULL);</a>
<a name="ln224"> </a>
<a name="ln225">/* 	set_bit(fsa_input_register, R_STAYDOWN); */</a>
<a name="ln226">    if (send_cluster_message(NULL, crm_msg_crmd, msg, TRUE) == FALSE) {</a>
<a name="ln227">        register_fsa_error(C_FSA_INTERNAL, I_ERROR, NULL);</a>
<a name="ln228">    }</a>
<a name="ln229">    free_xml(msg);</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">extern crm_ipc_t *attrd_ipc;</a>
<a name="ln233">extern char *max_generation_from;</a>
<a name="ln234">extern xmlNode *max_generation_xml;</a>
<a name="ln235">extern GHashTable *resource_history;</a>
<a name="ln236">extern GHashTable *voted;</a>
<a name="ln237">extern char *te_client_id;</a>
<a name="ln238">extern regex_t *version_format_regex;</a>
<a name="ln239"> </a>
<a name="ln240">void log_connected_client(gpointer key, gpointer value, gpointer user_data);</a>
<a name="ln241"> </a>
<a name="ln242">void</a>
<a name="ln243">log_connected_client(gpointer key, gpointer value, gpointer user_data)</a>
<a name="ln244">{</a>
<a name="ln245">    crm_client_t *client = value;</a>
<a name="ln246"> </a>
<a name="ln247">    crm_err(&quot;%s is still connected at exit&quot;, crm_client_name(client));</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">int</a>
<a name="ln251">crmd_fast_exit(int rc) </a>
<a name="ln252">{</a>
<a name="ln253">    if (is_set(fsa_input_register, R_STAYDOWN)) {</a>
<a name="ln254">        crm_warn(&quot;Inhibiting respawn &quot;CRM_XS&quot; remapping exit code %d to %d&quot;,</a>
<a name="ln255">                 rc, DAEMON_RESPAWN_STOP);</a>
<a name="ln256">        rc = DAEMON_RESPAWN_STOP;</a>
<a name="ln257">    }</a>
<a name="ln258"> </a>
<a name="ln259">    if (rc == pcmk_ok &amp;&amp; is_set(fsa_input_register, R_IN_RECOVERY)) {</a>
<a name="ln260">        crm_err(&quot;Could not recover from internal error&quot;);</a>
<a name="ln261">        rc = pcmk_err_generic;</a>
<a name="ln262">    }</a>
<a name="ln263">    return crm_exit(rc);</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">int</a>
<a name="ln267">crmd_exit(int rc)</a>
<a name="ln268">{</a>
<a name="ln269">    GListPtr gIter = NULL;</a>
<a name="ln270">    GMainLoop *mloop = crmd_mainloop;</a>
<a name="ln271"> </a>
<a name="ln272">    static bool in_progress = FALSE;</a>
<a name="ln273"> </a>
<a name="ln274">    if(in_progress &amp;&amp; rc == 0) {</a>
<a name="ln275">        crm_debug(&quot;Exit is already in progress&quot;);</a>
<a name="ln276">        return rc;</a>
<a name="ln277"> </a>
<a name="ln278">    } else if(in_progress) {</a>
<a name="ln279">        crm_notice(&quot;Error during shutdown process, terminating now with status %d: %s&quot;,</a>
<a name="ln280">                   rc, pcmk_strerror(rc));</a>
<a name="ln281">        crm_write_blackbox(SIGTRAP, NULL);</a>
<a name="ln282">        crmd_fast_exit(rc);</a>
<a name="ln283">    }</a>
<a name="ln284"> </a>
<a name="ln285">    in_progress = TRUE;</a>
<a name="ln286">    crm_trace(&quot;Preparing to exit: %d&quot;, rc);</a>
<a name="ln287"> </a>
<a name="ln288">    /* Suppress secondary errors resulting from us disconnecting everything */</a>
<a name="ln289">    set_bit(fsa_input_register, R_HA_DISCONNECTED);</a>
<a name="ln290"> </a>
<a name="ln291">/* Close all IPC servers and clients to ensure any and all shared memory files are cleaned up */</a>
<a name="ln292"> </a>
<a name="ln293">    if(ipcs) {</a>
<a name="ln294">        crm_trace(&quot;Closing IPC server&quot;);</a>
<a name="ln295">        mainloop_del_ipc_server(ipcs);</a>
<a name="ln296">        ipcs = NULL;</a>
<a name="ln297">    }</a>
<a name="ln298"> </a>
<a name="ln299">    if (attrd_ipc) {</a>
<a name="ln300">        crm_trace(&quot;Closing attrd connection&quot;);</a>
<a name="ln301">        crm_ipc_close(attrd_ipc);</a>
<a name="ln302">        crm_ipc_destroy(attrd_ipc);</a>
<a name="ln303">        attrd_ipc = NULL;</a>
<a name="ln304">    }</a>
<a name="ln305"> </a>
<a name="ln306">    if (pe_subsystem &amp;&amp; pe_subsystem-&gt;client &amp;&amp; pe_subsystem-&gt;client-&gt;ipcs) {</a>
<a name="ln307">        crm_trace(&quot;Disconnecting Policy Engine&quot;);</a>
<a name="ln308">        qb_ipcs_disconnect(pe_subsystem-&gt;client-&gt;ipcs);</a>
<a name="ln309">    }</a>
<a name="ln310"> </a>
<a name="ln311">    if(stonith_api) {</a>
<a name="ln312">        crm_trace(&quot;Disconnecting fencing API&quot;);</a>
<a name="ln313">        clear_bit(fsa_input_register, R_ST_REQUIRED);</a>
<a name="ln314">        stonith_api-&gt;cmds-&gt;free(stonith_api); stonith_api = NULL;</a>
<a name="ln315">    }</a>
<a name="ln316"> </a>
<a name="ln317">    if (rc == pcmk_ok &amp;&amp; crmd_mainloop == NULL) {</a>
<a name="ln318">        crm_debug(&quot;No mainloop detected&quot;);</a>
<a name="ln319">        rc = EPROTO;</a>
<a name="ln320">    }</a>
<a name="ln321"> </a>
<a name="ln322">    /* On an error, just get out.</a>
<a name="ln323">     *</a>
<a name="ln324">     * Otherwise, make the effort to have mainloop exit gracefully so</a>
<a name="ln325">     * that it (mostly) cleans up after itself and valgrind has less</a>
<a name="ln326">     * to report on - allowing real errors stand out</a>
<a name="ln327">     */</a>
<a name="ln328">    if(rc != pcmk_ok) {</a>
<a name="ln329">        crm_notice(&quot;Forcing immediate exit with status %d: %s&quot;,</a>
<a name="ln330">                   rc, pcmk_strerror(rc));</a>
<a name="ln331">        crm_write_blackbox(SIGTRAP, NULL);</a>
<a name="ln332">        return crmd_fast_exit(rc);</a>
<a name="ln333">    }</a>
<a name="ln334"> </a>
<a name="ln335">/* Clean up as much memory as possible for valgrind */</a>
<a name="ln336"> </a>
<a name="ln337">    for (gIter = fsa_message_queue; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln338">        fsa_data_t *fsa_data = gIter-&gt;data;</a>
<a name="ln339"> </a>
<a name="ln340">        crm_info(&quot;Dropping %s: [ state=%s cause=%s origin=%s ]&quot;,</a>
<a name="ln341">                 fsa_input2string(fsa_data-&gt;fsa_input),</a>
<a name="ln342">                 fsa_state2string(fsa_state),</a>
<a name="ln343">                 fsa_cause2string(fsa_data-&gt;fsa_cause), fsa_data-&gt;origin);</a>
<a name="ln344">        delete_fsa_input(fsa_data);</a>
<a name="ln345">    }</a>
<a name="ln346"> </a>
<a name="ln347">    clear_bit(fsa_input_register, R_MEMBERSHIP);</a>
<a name="ln348">    g_list_free(fsa_message_queue); fsa_message_queue = NULL;</a>
<a name="ln349"> </a>
<a name="ln350">    free(pe_subsystem); pe_subsystem = NULL;</a>
<a name="ln351">    free(te_subsystem); te_subsystem = NULL;</a>
<a name="ln352">    free(cib_subsystem); cib_subsystem = NULL;</a>
<a name="ln353"> </a>
<a name="ln354">    if (version_format_regex) {</a>
<a name="ln355">        regfree(version_format_regex);</a>
<a name="ln356">        free(version_format_regex);</a>
<a name="ln357">    }</a>
<a name="ln358"> </a>
<a name="ln359">    election_fini(fsa_election);</a>
<a name="ln360">    fsa_election = NULL;</a>
<a name="ln361"> </a>
<a name="ln362">    /* Tear down the CIB connection, but don't free it yet -- it could be used</a>
<a name="ln363">     * when we drain the mainloop later.</a>
<a name="ln364">     */</a>
<a name="ln365">    cib_free_callbacks(fsa_cib_conn);</a>
<a name="ln366">    fsa_cib_conn-&gt;cmds-&gt;signoff(fsa_cib_conn);</a>
<a name="ln367"> </a>
<a name="ln368">    verify_stopped(fsa_state, LOG_WARNING);</a>
<a name="ln369">    clear_bit(fsa_input_register, R_LRM_CONNECTED);</a>
<a name="ln370">    lrm_state_destroy_all();</a>
<a name="ln371"> </a>
<a name="ln372">    /* This basically will not work, since mainloop has a reference to it */</a>
<a name="ln373">    mainloop_destroy_trigger(fsa_source); fsa_source = NULL;</a>
<a name="ln374"> </a>
<a name="ln375">    mainloop_destroy_trigger(config_read); config_read = NULL;</a>
<a name="ln376">    mainloop_destroy_trigger(stonith_reconnect); stonith_reconnect = NULL;</a>
<a name="ln377">    mainloop_destroy_trigger(transition_trigger); transition_trigger = NULL;</a>
<a name="ln378"> </a>
<a name="ln379">    crm_client_cleanup();</a>
<a name="ln380">    crm_peer_destroy();</a>
<a name="ln381"> </a>
<a name="ln382">    crm_timer_stop(transition_timer);</a>
<a name="ln383">    crm_timer_stop(integration_timer);</a>
<a name="ln384">    crm_timer_stop(finalization_timer);</a>
<a name="ln385">    crm_timer_stop(election_trigger);</a>
<a name="ln386">    election_timeout_stop(fsa_election);</a>
<a name="ln387">    crm_timer_stop(shutdown_escalation_timer);</a>
<a name="ln388">    crm_timer_stop(wait_timer);</a>
<a name="ln389">    crm_timer_stop(recheck_timer);</a>
<a name="ln390"> </a>
<a name="ln391">    free(transition_timer); transition_timer = NULL;</a>
<a name="ln392">    free(integration_timer); integration_timer = NULL;</a>
<a name="ln393">    free(finalization_timer); finalization_timer = NULL;</a>
<a name="ln394">    free(election_trigger); election_trigger = NULL;</a>
<a name="ln395">    free(shutdown_escalation_timer); shutdown_escalation_timer = NULL;</a>
<a name="ln396">    free(wait_timer); wait_timer = NULL;</a>
<a name="ln397">    free(recheck_timer); recheck_timer = NULL;</a>
<a name="ln398"> </a>
<a name="ln399">    free(fsa_our_dc_version); fsa_our_dc_version = NULL;</a>
<a name="ln400">    free(fsa_our_uname); fsa_our_uname = NULL;</a>
<a name="ln401">    free(fsa_our_uuid); fsa_our_uuid = NULL;</a>
<a name="ln402">    free(fsa_our_dc); fsa_our_dc = NULL;</a>
<a name="ln403"> </a>
<a name="ln404">    free(fsa_cluster_name); fsa_cluster_name = NULL;</a>
<a name="ln405"> </a>
<a name="ln406">    free(te_uuid); te_uuid = NULL;</a>
<a name="ln407">    free(te_client_id); te_client_id = NULL;</a>
<a name="ln408">    free(fsa_pe_ref); fsa_pe_ref = NULL;</a>
<a name="ln409">    free(failed_stop_offset); failed_stop_offset = NULL;</a>
<a name="ln410">    free(failed_start_offset); failed_start_offset = NULL;</a>
<a name="ln411"> </a>
<a name="ln412">    free(max_generation_from); max_generation_from = NULL;</a>
<a name="ln413">    free_xml(max_generation_xml); max_generation_xml = NULL;</a>
<a name="ln414"> </a>
<a name="ln415">    mainloop_destroy_signal(SIGPIPE);</a>
<a name="ln416">    mainloop_destroy_signal(SIGUSR1);</a>
<a name="ln417">    mainloop_destroy_signal(SIGTERM);</a>
<a name="ln418">    mainloop_destroy_signal(SIGTRAP);</a>
<a name="ln419">    /* leave SIGCHLD engaged as we might still want to drain some service-actions */</a>
<a name="ln420"> </a>
<a name="ln421">    if (mloop) {</a>
<a name="ln422">        GMainContext *ctx = g_main_loop_get_context(crmd_mainloop);</a>
<a name="ln423"> </a>
<a name="ln424">        /* Don't re-enter this block */</a>
<a name="ln425">        crmd_mainloop = NULL;</a>
<a name="ln426"> </a>
<a name="ln427">        crmd_drain_alerts(ctx);</a>
<a name="ln428"> </a>
<a name="ln429">        /* no signals on final draining anymore */</a>
<a name="ln430">        mainloop_destroy_signal(SIGCHLD);</a>
<a name="ln431"> </a>
<a name="ln432">        crm_trace(&quot;Draining mainloop %d %d&quot;, g_main_loop_is_running(mloop), g_main_context_pending(ctx));</a>
<a name="ln433"> </a>
<a name="ln434">        {</a>
<a name="ln435">            int lpc = 0;</a>
<a name="ln436"> </a>
<a name="ln437">            while((g_main_context_pending(ctx) &amp;&amp; lpc &lt; 10)) {</a>
<a name="ln438">                lpc++;</a>
<a name="ln439">                crm_trace(&quot;Iteration %d&quot;, lpc);</a>
<a name="ln440">                g_main_context_dispatch(ctx);</a>
<a name="ln441">            }</a>
<a name="ln442">        }</a>
<a name="ln443"> </a>
<a name="ln444">        crm_trace(&quot;Closing mainloop %d %d&quot;, g_main_loop_is_running(mloop), g_main_context_pending(ctx));</a>
<a name="ln445">        g_main_loop_quit(mloop);</a>
<a name="ln446"> </a>
<a name="ln447">#if SUPPORT_HEARTBEAT</a>
<a name="ln448">        /* Do this only after g_main_loop_quit().</a>
<a name="ln449">         *</a>
<a name="ln450">         * This interface was broken (incomplete) since it was introduced.</a>
<a name="ln451">         * -&gt;delete() does cleanup and free most of it, but it does not</a>
<a name="ln452">         * actually remove and destroy the corresponding GSource, so the next</a>
<a name="ln453">         * prepare/check iteratioin would find a corrupt (because partially</a>
<a name="ln454">         * freed) GSource, and segfault.</a>
<a name="ln455">         *</a>
<a name="ln456">         * Apparently one was supposed to store the GSource as returned by</a>
<a name="ln457">         * G_main_add_ll_cluster(), and g_source_destroy() that &quot;by hand&quot;.</a>
<a name="ln458">         *</a>
<a name="ln459">         * But no-one ever did this, not even in the old hb code when this was</a>
<a name="ln460">         * introduced.</a>
<a name="ln461">         *</a>
<a name="ln462">         * Note that fsa_cluster_conn was set as an &quot;alias&quot; to cluster-&gt;hb_conn</a>
<a name="ln463">         * in do_ha_control() right after crm_cluster_connect(), and only</a>
<a name="ln464">         * happens to still point at that object, because do_ha_control() does</a>
<a name="ln465">         * not reset it to NULL after crm_cluster_disconnect() above does</a>
<a name="ln466">         * reset cluster-&gt;hb_conn to NULL.</a>
<a name="ln467">         * Not sure if that's something to cleanup, too.</a>
<a name="ln468">         *</a>
<a name="ln469">         * I'll try to fix this up in heartbeat proper, so -&gt;delete</a>
<a name="ln470">         * will actually remove, and destroy, and unref, and free this thing.</a>
<a name="ln471">         * Doing so after g_main_loop_quit() is valid with both old,</a>
<a name="ln472">         * and eventually fixed heartbeat.</a>
<a name="ln473">         *</a>
<a name="ln474">         * If we introduce the &quot;by hand&quot; destroy/remove/unref,</a>
<a name="ln475">         * this may break again once heartbeat is fixed :-(</a>
<a name="ln476">         *</a>
<a name="ln477">         *                                              -- Lars Ellenberg</a>
<a name="ln478">         */</a>
<a name="ln479">        if (fsa_cluster_conn) {</a>
<a name="ln480">            crm_trace(&quot;Deleting heartbeat api object&quot;);</a>
<a name="ln481">            fsa_cluster_conn-&gt;llc_ops-&gt;delete(fsa_cluster_conn);</a>
<a name="ln482">            fsa_cluster_conn = NULL;</a>
<a name="ln483">        }</a>
<a name="ln484">#endif</a>
<a name="ln485"> </a>
<a name="ln486">        /* Won't do anything yet, since we're inside it now */</a>
<a name="ln487">        g_main_loop_unref(mloop);</a>
<a name="ln488"> </a>
<a name="ln489">        crm_trace(&quot;Done %d&quot;, rc);</a>
<a name="ln490">    } else {</a>
<a name="ln491">        mainloop_destroy_signal(SIGCHLD);</a>
<a name="ln492">    }</a>
<a name="ln493"> </a>
<a name="ln494">    cib_delete(fsa_cib_conn);</a>
<a name="ln495">    fsa_cib_conn = NULL;</a>
<a name="ln496"> </a>
<a name="ln497">    throttle_fini();</a>
<a name="ln498"> </a>
<a name="ln499">    /* Graceful */</a>
<a name="ln500">    return rc;</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">/*	 A_EXIT_0, A_EXIT_1	*/</a>
<a name="ln504">void</a>
<a name="ln505">do_exit(long long action,</a>
<a name="ln506">        enum crmd_fsa_cause cause,</a>
<a name="ln507">        enum crmd_fsa_state cur_state, enum crmd_fsa_input current_input, fsa_data_t * msg_data)</a>
<a name="ln508">{</a>
<a name="ln509">    int exit_code = pcmk_ok;</a>
<a name="ln510">    int log_level = LOG_INFO;</a>
<a name="ln511">    const char *exit_type = &quot;gracefully&quot;;</a>
<a name="ln512"> </a>
<a name="ln513">    if (action &amp; A_EXIT_1) {</a>
<a name="ln514">        /* exit_code = pcmk_err_generic; */</a>
<a name="ln515">        log_level = LOG_ERR;</a>
<a name="ln516">        exit_type = &quot;forcefully&quot;;</a>
<a name="ln517">        exit_code = pcmk_err_generic;</a>
<a name="ln518">    }</a>
<a name="ln519"> </a>
<a name="ln520">    verify_stopped(cur_state, LOG_ERR);</a>
<a name="ln521">    do_crm_log(log_level, &quot;Performing %s - %s exiting the CRMd&quot;,</a>
<a name="ln522">               fsa_action2string(action), exit_type);</a>
<a name="ln523"> </a>
<a name="ln524">    crm_info(&quot;[%s] stopped (%d)&quot;, crm_system_name, exit_code);</a>
<a name="ln525">    crmd_exit(exit_code);</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">static void sigpipe_ignore(int nsig) { return; }</a>
<a name="ln529"> </a>
<a name="ln530">/*	 A_STARTUP	*/</a>
<a name="ln531">void</a>
<a name="ln532">do_startup(long long action,</a>
<a name="ln533">           enum crmd_fsa_cause cause,</a>
<a name="ln534">           enum crmd_fsa_state cur_state, enum crmd_fsa_input current_input, fsa_data_t * msg_data)</a>
<a name="ln535">{</a>
<a name="ln536">    int was_error = 0;</a>
<a name="ln537"> </a>
<a name="ln538">    crm_debug(&quot;Registering Signal Handlers&quot;);</a>
<a name="ln539">    mainloop_add_signal(SIGTERM, crm_shutdown);</a>
<a name="ln540">    mainloop_add_signal(SIGPIPE, sigpipe_ignore);</a>
<a name="ln541"> </a>
<a name="ln542">    fsa_source = mainloop_add_trigger(G_PRIORITY_HIGH, crm_fsa_trigger, NULL);</a>
<a name="ln543">    config_read = mainloop_add_trigger(G_PRIORITY_HIGH, crm_read_options, NULL);</a>
<a name="ln544">    transition_trigger = mainloop_add_trigger(G_PRIORITY_LOW, te_graph_trigger, NULL);</a>
<a name="ln545"> </a>
<a name="ln546">    crm_debug(&quot;Creating CIB and LRM objects&quot;);</a>
<a name="ln547">    fsa_cib_conn = cib_new();</a>
<a name="ln548"> </a>
<a name="ln549">    lrm_state_init_local();</a>
<a name="ln550"> </a>
<a name="ln551">    /* set up the timers */</a>
<a name="ln552">    transition_timer = calloc(1, sizeof(fsa_timer_t));</a>
<a name="ln553">    integration_timer = calloc(1, sizeof(fsa_timer_t));</a>
<a name="ln554">    finalization_timer = calloc(1, sizeof(fsa_timer_t));</a>
<a name="ln555">    election_trigger = calloc(1, sizeof(fsa_timer_t));</a>
<a name="ln556">    shutdown_escalation_timer = calloc(1, sizeof(fsa_timer_t));</a>
<a name="ln557">    wait_timer = calloc(1, sizeof(fsa_timer_t));</a>
<a name="ln558">    recheck_timer = calloc(1, sizeof(fsa_timer_t));</a>
<a name="ln559"> </a>
<a name="ln560">    if (election_trigger != NULL) {</a>
<a name="ln561">        election_trigger-&gt;source_id = 0;</a>
<a name="ln562">        election_trigger-&gt;period_ms = -1;</a>
<a name="ln563">        election_trigger-&gt;fsa_input = I_DC_TIMEOUT;</a>
<a name="ln564">        election_trigger-&gt;callback = crm_timer_popped;</a>
<a name="ln565">        election_trigger-&gt;repeat = FALSE;</a>
<a name="ln566">    } else {</a>
<a name="ln567">        was_error = TRUE;</a>
<a name="ln568">    }</a>
<a name="ln569"> </a>
<a name="ln570">    if (transition_timer != NULL) {</a>
<a name="ln571">        transition_timer-&gt;source_id = 0;</a>
<a name="ln572">        transition_timer-&gt;period_ms = -1;</a>
<a name="ln573">        transition_timer-&gt;fsa_input = I_PE_CALC;</a>
<a name="ln574">        transition_timer-&gt;callback = crm_timer_popped;</a>
<a name="ln575">        transition_timer-&gt;repeat = FALSE;</a>
<a name="ln576">    } else {</a>
<a name="ln577">        was_error = TRUE;</a>
<a name="ln578">    }</a>
<a name="ln579"> </a>
<a name="ln580">    if (integration_timer != NULL) {</a>
<a name="ln581">        integration_timer-&gt;source_id = 0;</a>
<a name="ln582">        integration_timer-&gt;period_ms = -1;</a>
<a name="ln583">        integration_timer-&gt;fsa_input = I_INTEGRATED;</a>
<a name="ln584">        integration_timer-&gt;callback = crm_timer_popped;</a>
<a name="ln585">        integration_timer-&gt;repeat = FALSE;</a>
<a name="ln586">    } else {</a>
<a name="ln587">        was_error = TRUE;</a>
<a name="ln588">    }</a>
<a name="ln589"> </a>
<a name="ln590">    if (finalization_timer != NULL) {</a>
<a name="ln591">        finalization_timer-&gt;source_id = 0;</a>
<a name="ln592">        finalization_timer-&gt;period_ms = -1;</a>
<a name="ln593">        finalization_timer-&gt;fsa_input = I_FINALIZED;</a>
<a name="ln594">        finalization_timer-&gt;callback = crm_timer_popped;</a>
<a name="ln595">        finalization_timer-&gt;repeat = FALSE;</a>
<a name="ln596">        /* for possible enabling... a bug in the join protocol left</a>
<a name="ln597">         *    a slave in S_PENDING while we think its in S_NOT_DC</a>
<a name="ln598">         *</a>
<a name="ln599">         * raising I_FINALIZED put us into a transition loop which is</a>
<a name="ln600">         *    never resolved.</a>
<a name="ln601">         * in this loop we continually send probes which the node</a>
<a name="ln602">         *    NACK's because its in S_PENDING</a>
<a name="ln603">         *</a>
<a name="ln604">         * if we have nodes where heartbeat is active but the</a>
<a name="ln605">         *    CRM is not... then this will be handled in the</a>
<a name="ln606">         *    integration phase</a>
<a name="ln607">         */</a>
<a name="ln608">        finalization_timer-&gt;fsa_input = I_ELECTION;</a>
<a name="ln609"> </a>
<a name="ln610">    } else {</a>
<a name="ln611">        was_error = TRUE;</a>
<a name="ln612">    }</a>
<a name="ln613"> </a>
<a name="ln614">    if (shutdown_escalation_timer != NULL) {</a>
<a name="ln615">        shutdown_escalation_timer-&gt;source_id = 0;</a>
<a name="ln616">        shutdown_escalation_timer-&gt;period_ms = -1;</a>
<a name="ln617">        shutdown_escalation_timer-&gt;fsa_input = I_STOP;</a>
<a name="ln618">        shutdown_escalation_timer-&gt;callback = crm_timer_popped;</a>
<a name="ln619">        shutdown_escalation_timer-&gt;repeat = FALSE;</a>
<a name="ln620">    } else {</a>
<a name="ln621">        was_error = TRUE;</a>
<a name="ln622">    }</a>
<a name="ln623"> </a>
<a name="ln624">    if (wait_timer != NULL) {</a>
<a name="ln625">        wait_timer-&gt;source_id = 0;</a>
<a name="ln626">        wait_timer-&gt;period_ms = 2000;</a>
<a name="ln627">        wait_timer-&gt;fsa_input = I_NULL;</a>
<a name="ln628">        wait_timer-&gt;callback = crm_timer_popped;</a>
<a name="ln629">        wait_timer-&gt;repeat = FALSE;</a>
<a name="ln630">    } else {</a>
<a name="ln631">        was_error = TRUE;</a>
<a name="ln632">    }</a>
<a name="ln633"> </a>
<a name="ln634">    if (recheck_timer != NULL) {</a>
<a name="ln635">        recheck_timer-&gt;source_id = 0;</a>
<a name="ln636">        recheck_timer-&gt;period_ms = -1;</a>
<a name="ln637">        recheck_timer-&gt;fsa_input = I_PE_CALC;</a>
<a name="ln638">        recheck_timer-&gt;callback = crm_timer_popped;</a>
<a name="ln639">        recheck_timer-&gt;repeat = FALSE;</a>
<a name="ln640">    } else {</a>
<a name="ln641">        was_error = TRUE;</a>
<a name="ln642">    }</a>
<a name="ln643"> </a>
<a name="ln644">    /* set up the sub systems */</a>
<a name="ln645">    cib_subsystem = calloc(1, sizeof(struct crm_subsystem_s));</a>
<a name="ln646">    te_subsystem = calloc(1, sizeof(struct crm_subsystem_s));</a>
<a name="ln647">    pe_subsystem = calloc(1, sizeof(struct crm_subsystem_s));</a>
<a name="ln648"> </a>
<a name="ln649">    if (cib_subsystem != NULL) {</a>
<a name="ln650">        cib_subsystem-&gt;pid = -1;</a>
<a name="ln651">        cib_subsystem-&gt;name = CRM_SYSTEM_CIB;</a>
<a name="ln652">        cib_subsystem-&gt;flag_connected = R_CIB_CONNECTED;</a>
<a name="ln653">        cib_subsystem-&gt;flag_required = R_CIB_REQUIRED;</a>
<a name="ln654"> </a>
<a name="ln655">    } else {</a>
<a name="ln656">        was_error = TRUE;</a>
<a name="ln657">    }</a>
<a name="ln658"> </a>
<a name="ln659">    if (te_subsystem != NULL) {</a>
<a name="ln660">        te_subsystem-&gt;pid = -1;</a>
<a name="ln661">        te_subsystem-&gt;name = CRM_SYSTEM_TENGINE;</a>
<a name="ln662">        te_subsystem-&gt;flag_connected = R_TE_CONNECTED;</a>
<a name="ln663">        te_subsystem-&gt;flag_required = R_TE_REQUIRED;</a>
<a name="ln664"> </a>
<a name="ln665">    } else {</a>
<a name="ln666">        was_error = TRUE;</a>
<a name="ln667">    }</a>
<a name="ln668"> </a>
<a name="ln669">    if (pe_subsystem != NULL) {</a>
<a name="ln670">        pe_subsystem-&gt;pid = -1;</a>
<a name="ln671">        pe_subsystem-&gt;path = CRM_DAEMON_DIR;</a>
<a name="ln672">        pe_subsystem-&gt;name = CRM_SYSTEM_PENGINE;</a>
<a name="ln673">        pe_subsystem-&gt;command = CRM_DAEMON_DIR &quot;/&quot; CRM_SYSTEM_PENGINE;</a>
<a name="ln674">        pe_subsystem-&gt;args = NULL;</a>
<a name="ln675">        pe_subsystem-&gt;flag_connected = R_PE_CONNECTED;</a>
<a name="ln676">        pe_subsystem-&gt;flag_required = R_PE_REQUIRED;</a>
<a name="ln677"> </a>
<a name="ln678">    } else {</a>
<a name="ln679">        was_error = TRUE;</a>
<a name="ln680">    }</a>
<a name="ln681"> </a>
<a name="ln682">    if (was_error == FALSE &amp;&amp; need_spawn_pengine_from_crmd()) {</a>
<a name="ln683">        if (start_subsystem(pe_subsystem) == FALSE) {</a>
<a name="ln684">            was_error = TRUE;</a>
<a name="ln685">        }</a>
<a name="ln686">    }</a>
<a name="ln687"> </a>
<a name="ln688">    if (was_error) {</a>
<a name="ln689">        register_fsa_error(C_FSA_INTERNAL, I_ERROR, NULL);</a>
<a name="ln690">    }</a>
<a name="ln691"> </a>
<a name="ln692">}</a>
<a name="ln693"> </a>
<a name="ln694">static int32_t</a>
<a name="ln695">crmd_ipc_accept(qb_ipcs_connection_t * c, uid_t uid, gid_t gid)</a>
<a name="ln696">{</a>
<a name="ln697">    crm_trace(&quot;Connection %p&quot;, c);</a>
<a name="ln698">    if (crm_client_new(c, uid, gid) == NULL) {</a>
<a name="ln699">        return -EIO;</a>
<a name="ln700">    }</a>
<a name="ln701">    return 0;</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704">static void</a>
<a name="ln705">crmd_ipc_created(qb_ipcs_connection_t * c)</a>
<a name="ln706">{</a>
<a name="ln707">    crm_trace(&quot;Connection %p&quot;, c);</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">static int32_t</a>
<a name="ln711">crmd_ipc_dispatch(qb_ipcs_connection_t * c, void *data, size_t size)</a>
<a name="ln712">{</a>
<a name="ln713">    uint32_t id = 0;</a>
<a name="ln714">    uint32_t flags = 0;</a>
<a name="ln715">    crm_client_t *client = crm_client_get(c);</a>
<a name="ln716"> </a>
<a name="ln717">    xmlNode *msg = crm_ipcs_recv(client, data, size, &amp;id, &amp;flags);</a>
<a name="ln718"> </a>
<a name="ln719">    crm_trace(&quot;Invoked: %s&quot;, crm_client_name(client));</a>
<a name="ln720">    crm_ipcs_send_ack(client, id, flags, &quot;ack&quot;, __FUNCTION__, __LINE__);</a>
<a name="ln721"> </a>
<a name="ln722">    if (msg == NULL) {</a>
<a name="ln723">        return 0;</a>
<a name="ln724">    }</a>
<a name="ln725"> </a>
<a name="ln726">#if ENABLE_ACL</a>
<a name="ln727">    CRM_ASSERT(client-&gt;user != NULL);</a>
<a name="ln728">    crm_acl_get_set_user(msg, F_CRM_USER, client-&gt;user);</a>
<a name="ln729">#endif</a>
<a name="ln730"> </a>
<a name="ln731">    crm_trace(&quot;Processing msg from %s&quot;, crm_client_name(client));</a>
<a name="ln732">    crm_log_xml_trace(msg, &quot;CRMd[inbound]&quot;);</a>
<a name="ln733"> </a>
<a name="ln734">    crm_xml_add(msg, F_CRM_SYS_FROM, client-&gt;id);</a>
<a name="ln735">    if (crmd_authorize_message(msg, client, NULL)) {</a>
<a name="ln736">        route_message(C_IPC_MESSAGE, msg);</a>
<a name="ln737">    }</a>
<a name="ln738"> </a>
<a name="ln739">    trigger_fsa(fsa_source);</a>
<a name="ln740">    free_xml(msg);</a>
<a name="ln741">    return 0;</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">static int32_t</a>
<a name="ln745">crmd_ipc_closed(qb_ipcs_connection_t * c)</a>
<a name="ln746">{</a>
<a name="ln747">    crm_client_t *client = crm_client_get(c);</a>
<a name="ln748">    struct crm_subsystem_s *the_subsystem = NULL;</a>
<a name="ln749"> </a>
<a name="ln750">    if (client == NULL) {</a>
<a name="ln751">        return 0;</a>
<a name="ln752">    }</a>
<a name="ln753"> </a>
<a name="ln754">    crm_trace(&quot;Connection %p&quot;, c);</a>
<a name="ln755"> </a>
<a name="ln756">    if (client-&gt;userdata == NULL) {</a>
<a name="ln757">        crm_trace(&quot;Client hadn't registered with us yet&quot;);</a>
<a name="ln758"> </a>
<a name="ln759">    } else if (strcasecmp(CRM_SYSTEM_PENGINE, client-&gt;userdata) == 0) {</a>
<a name="ln760">        the_subsystem = pe_subsystem;</a>
<a name="ln761"> </a>
<a name="ln762">    } else if (strcasecmp(CRM_SYSTEM_TENGINE, client-&gt;userdata) == 0) {</a>
<a name="ln763">        the_subsystem = te_subsystem;</a>
<a name="ln764"> </a>
<a name="ln765">    } else if (strcasecmp(CRM_SYSTEM_CIB, client-&gt;userdata) == 0) {</a>
<a name="ln766">        the_subsystem = cib_subsystem;</a>
<a name="ln767">    }</a>
<a name="ln768"> </a>
<a name="ln769">    if (the_subsystem != NULL) {</a>
<a name="ln770">        the_subsystem-&gt;source = NULL;</a>
<a name="ln771">        the_subsystem-&gt;client = NULL;</a>
<a name="ln772">        crm_info(&quot;Received HUP from %s:[%d]&quot;, the_subsystem-&gt;name, the_subsystem-&gt;pid);</a>
<a name="ln773"> </a>
<a name="ln774">    } else {</a>
<a name="ln775">        /* else that was a transient client */</a>
<a name="ln776">        crm_trace(&quot;Received HUP from transient client&quot;);</a>
<a name="ln777">    }</a>
<a name="ln778"> </a>
<a name="ln779">    crm_trace(&quot;Disconnecting client %s (%p)&quot;, crm_client_name(client), client);</a>
<a name="ln780">    free(client-&gt;userdata);</a>
<a name="ln781">    crm_client_destroy(client);</a>
<a name="ln782"> </a>
<a name="ln783">    trigger_fsa(fsa_source);</a>
<a name="ln784">    return 0;</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">static void</a>
<a name="ln788">crmd_ipc_destroy(qb_ipcs_connection_t * c)</a>
<a name="ln789">{</a>
<a name="ln790">    crm_trace(&quot;Connection %p&quot;, c);</a>
<a name="ln791">    crmd_ipc_closed(c);</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">/*	 A_STOP	*/</a>
<a name="ln795">void</a>
<a name="ln796">do_stop(long long action,</a>
<a name="ln797">        enum crmd_fsa_cause cause,</a>
<a name="ln798">        enum crmd_fsa_state cur_state, enum crmd_fsa_input current_input, fsa_data_t * msg_data)</a>
<a name="ln799">{</a>
<a name="ln800">    crm_trace(&quot;Closing IPC server&quot;);</a>
<a name="ln801">    mainloop_del_ipc_server(ipcs); ipcs = NULL;</a>
<a name="ln802">    register_fsa_input(C_FSA_INTERNAL, I_TERMINATE, NULL);</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">/*	 A_STARTED	*/</a>
<a name="ln806">void</a>
<a name="ln807">do_started(long long action,</a>
<a name="ln808">           enum crmd_fsa_cause cause,</a>
<a name="ln809">           enum crmd_fsa_state cur_state, enum crmd_fsa_input current_input, fsa_data_t * msg_data)</a>
<a name="ln810">{</a>
<a name="ln811">    static struct qb_ipcs_service_handlers crmd_callbacks = {</a>
<a name="ln812">        .connection_accept = crmd_ipc_accept,</a>
<a name="ln813">        .connection_created = crmd_ipc_created,</a>
<a name="ln814">        .msg_process = crmd_ipc_dispatch,</a>
<a name="ln815">        .connection_closed = crmd_ipc_closed,</a>
<a name="ln816">        .connection_destroyed = crmd_ipc_destroy</a>
<a name="ln817">    };</a>
<a name="ln818"> </a>
<a name="ln819">    if (cur_state != S_STARTING) {</a>
<a name="ln820">        crm_err(&quot;Start cancelled... %s&quot;, fsa_state2string(cur_state));</a>
<a name="ln821">        return;</a>
<a name="ln822"> </a>
<a name="ln823">    } else if (is_set(fsa_input_register, R_MEMBERSHIP) == FALSE) {</a>
<a name="ln824">        crm_info(&quot;Delaying start, no membership data (%.16llx)&quot;, R_MEMBERSHIP);</a>
<a name="ln825"> </a>
<a name="ln826">        crmd_fsa_stall(TRUE);</a>
<a name="ln827">        return;</a>
<a name="ln828"> </a>
<a name="ln829">    } else if (is_set(fsa_input_register, R_LRM_CONNECTED) == FALSE) {</a>
<a name="ln830">        crm_info(&quot;Delaying start, LRM not connected (%.16llx)&quot;, R_LRM_CONNECTED);</a>
<a name="ln831"> </a>
<a name="ln832">        crmd_fsa_stall(TRUE);</a>
<a name="ln833">        return;</a>
<a name="ln834"> </a>
<a name="ln835">    } else if (is_set(fsa_input_register, R_CIB_CONNECTED) == FALSE) {</a>
<a name="ln836">        crm_info(&quot;Delaying start, CIB not connected (%.16llx)&quot;, R_CIB_CONNECTED);</a>
<a name="ln837"> </a>
<a name="ln838">        crmd_fsa_stall(TRUE);</a>
<a name="ln839">        return;</a>
<a name="ln840"> </a>
<a name="ln841">    } else if (is_set(fsa_input_register, R_READ_CONFIG) == FALSE) {</a>
<a name="ln842">        crm_info(&quot;Delaying start, Config not read (%.16llx)&quot;, R_READ_CONFIG);</a>
<a name="ln843"> </a>
<a name="ln844">        crmd_fsa_stall(TRUE);</a>
<a name="ln845">        return;</a>
<a name="ln846"> </a>
<a name="ln847">    } else if (is_set(fsa_input_register, R_PEER_DATA) == FALSE) {</a>
<a name="ln848"> </a>
<a name="ln849">        /* try reading from HA */</a>
<a name="ln850">        crm_info(&quot;Delaying start, No peer data (%.16llx)&quot;, R_PEER_DATA);</a>
<a name="ln851"> </a>
<a name="ln852">#if SUPPORT_HEARTBEAT</a>
<a name="ln853">        if (is_heartbeat_cluster()) {</a>
<a name="ln854">            HA_Message *msg = NULL;</a>
<a name="ln855"> </a>
<a name="ln856">            crm_trace(&quot;Looking for a HA message&quot;);</a>
<a name="ln857">            msg = fsa_cluster_conn-&gt;llc_ops-&gt;readmsg(fsa_cluster_conn, 0);</a>
<a name="ln858">            if (msg != NULL) {</a>
<a name="ln859">                crm_trace(&quot;There was a HA message&quot;);</a>
<a name="ln860">                ha_msg_del(msg);</a>
<a name="ln861">            }</a>
<a name="ln862">        }</a>
<a name="ln863">#endif</a>
<a name="ln864">        crmd_fsa_stall(TRUE);</a>
<a name="ln865">        return;</a>
<a name="ln866">    }</a>
<a name="ln867"> </a>
<a name="ln868">    crm_debug(&quot;Init server comms&quot;);</a>
<a name="ln869">    ipcs = crmd_ipc_server_init(&amp;crmd_callbacks);</a>
<a name="ln870">    if (ipcs == NULL) {</a>
<a name="ln871">        crm_err(&quot;Failed to create IPC server: shutting down and inhibiting respawn&quot;);</a>
<a name="ln872">        register_fsa_error(C_FSA_INTERNAL, I_ERROR, NULL);</a>
<a name="ln873">    }</a>
<a name="ln874"> </a>
<a name="ln875">    if (stonith_reconnect == NULL) {</a>
<a name="ln876">        int dummy;</a>
<a name="ln877"> </a>
<a name="ln878">        stonith_reconnect = mainloop_add_trigger(G_PRIORITY_LOW, te_connect_stonith, &amp;dummy);</a>
<a name="ln879">    }</a>
<a name="ln880">    set_bit(fsa_input_register, R_ST_REQUIRED);</a>
<a name="ln881">    mainloop_set_trigger(stonith_reconnect);</a>
<a name="ln882"> </a>
<a name="ln883">    crm_notice(&quot;The local CRM is operational&quot;);</a>
<a name="ln884">    clear_bit(fsa_input_register, R_STARTING);</a>
<a name="ln885">    register_fsa_input(msg_data-&gt;fsa_cause, I_PENDING, NULL);</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">/*	 A_RECOVER	*/</a>
<a name="ln889">void</a>
<a name="ln890">do_recover(long long action,</a>
<a name="ln891">           enum crmd_fsa_cause cause,</a>
<a name="ln892">           enum crmd_fsa_state cur_state, enum crmd_fsa_input current_input, fsa_data_t * msg_data)</a>
<a name="ln893">{</a>
<a name="ln894">    set_bit(fsa_input_register, R_IN_RECOVERY);</a>
<a name="ln895">    crm_warn(&quot;Fast-tracking shutdown in response to errors&quot;);</a>
<a name="ln896"> </a>
<a name="ln897">    register_fsa_input(C_FSA_INTERNAL, I_TERMINATE, NULL);</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">/* *INDENT-OFF* */</a>
<a name="ln901">pe_cluster_option crmd_opts[] = {</a>
<a name="ln902">	/* name, old-name, validate, values, default, short description, long description */</a>
<a name="ln903">	{ &quot;dc-version&quot;, NULL, &quot;string&quot;, NULL, &quot;none&quot;, NULL,</a>
<a name="ln904">          &quot;Version of Pacemaker on the cluster's DC.&quot;,</a>
<a name="ln905">          &quot;Includes the hash which identifies the exact changeset it was built from.  Used for diagnostic purposes.&quot;</a>
<a name="ln906">        },</a>
<a name="ln907">	{ &quot;cluster-infrastructure&quot;, NULL, &quot;string&quot;, NULL, &quot;heartbeat&quot;, NULL,</a>
<a name="ln908">          &quot;The messaging stack on which Pacemaker is currently running.&quot;,</a>
<a name="ln909">          &quot;Used for informational and diagnostic purposes.&quot; },</a>
<a name="ln910">	{ XML_CONFIG_ATTR_DC_DEADTIME, &quot;dc_deadtime&quot;, &quot;time&quot;, NULL, &quot;20s&quot;, &amp;check_time,</a>
<a name="ln911">          &quot;How long to wait for a response from other nodes during startup.&quot;,</a>
<a name="ln912">          &quot;The \&quot;correct\&quot; value will depend on the speed/load of your network and the type of switches used.&quot;</a>
<a name="ln913">        },</a>
<a name="ln914">	{ XML_CONFIG_ATTR_RECHECK, &quot;cluster_recheck_interval&quot;, &quot;time&quot;,</a>
<a name="ln915">	  &quot;Zero disables polling.  Positive values are an interval in seconds (unless other SI units are specified. eg. 5min)&quot;,</a>
<a name="ln916">          &quot;15min&quot;, &amp;check_timer,</a>
<a name="ln917">	  &quot;Polling interval for time based changes to options, resource parameters and constraints.&quot;,</a>
<a name="ln918">	  &quot;The Cluster is primarily event driven, however the configuration can have elements that change based on time.&quot;</a>
<a name="ln919">	  &quot;  To ensure these changes take effect, we can optionally poll the cluster's status for changes.&quot;</a>
<a name="ln920">        },</a>
<a name="ln921"> </a>
<a name="ln922">#ifdef RHEL7_COMPAT</a>
<a name="ln923">    /* These options were superseded by the alerts feature and now are just an</a>
<a name="ln924">     * alternate interface to it. It was never released upstream, but was</a>
<a name="ln925">     * released in RHEL 7, so we allow it to be enabled at compile-time by</a>
<a name="ln926">     * defining RHEL7_COMPAT.</a>
<a name="ln927">     */</a>
<a name="ln928">	{ &quot;notification-agent&quot;, NULL, &quot;string&quot;, NULL, &quot;/dev/null&quot;, &amp;check_script,</a>
<a name="ln929">          &quot;Deprecated&quot;,</a>
<a name="ln930">          &quot;Use alert path in alerts section instead&quot;</a>
<a name="ln931">        },</a>
<a name="ln932">	{ &quot;notification-recipient&quot;, NULL, &quot;string&quot;, NULL, &quot;&quot;, NULL,</a>
<a name="ln933">          &quot;Deprecated&quot;,</a>
<a name="ln934">          &quot;Use recipient value in alerts section instead&quot;</a>
<a name="ln935">        },</a>
<a name="ln936">#endif</a>
<a name="ln937"> </a>
<a name="ln938">	{ &quot;load-threshold&quot;, NULL, &quot;percentage&quot;, NULL, &quot;80%&quot;, &amp;check_utilization,</a>
<a name="ln939">	  &quot;The maximum amount of system resources that should be used by nodes in the cluster&quot;,</a>
<a name="ln940">	  &quot;The cluster will slow down its recovery process when the amount of system resources used&quot;</a>
<a name="ln941">          &quot; (currently CPU) approaches this limit&quot;,</a>
<a name="ln942">        },</a>
<a name="ln943">	{ &quot;node-action-limit&quot;, NULL, &quot;integer&quot;, NULL, &quot;0&quot;, &amp;check_number,</a>
<a name="ln944">          &quot;The maximum number of jobs that can be scheduled per node. Defaults to 2x cores&quot;},</a>
<a name="ln945">	{ XML_CONFIG_ATTR_ELECTION_FAIL, &quot;election_timeout&quot;, &quot;time&quot;, NULL, &quot;2min&quot;, &amp;check_timer,</a>
<a name="ln946">          &quot;*** Advanced Use Only ***.&quot;, &quot;If need to adjust this value, it probably indicates the presence of a bug.&quot;</a>
<a name="ln947">        },</a>
<a name="ln948">	{ XML_CONFIG_ATTR_FORCE_QUIT, &quot;shutdown_escalation&quot;, &quot;time&quot;, NULL, &quot;20min&quot;, &amp;check_timer,</a>
<a name="ln949">          &quot;*** Advanced Use Only ***.&quot;, &quot;If need to adjust this value, it probably indicates the presence of a bug.&quot;</a>
<a name="ln950">        },</a>
<a name="ln951">	{ &quot;crmd-integration-timeout&quot;, NULL, &quot;time&quot;, NULL, &quot;3min&quot;, &amp;check_timer,</a>
<a name="ln952">          &quot;*** Advanced Use Only ***.&quot;, &quot;If need to adjust this value, it probably indicates the presence of a bug.&quot;</a>
<a name="ln953">        },</a>
<a name="ln954">	{ &quot;crmd-finalization-timeout&quot;, NULL, &quot;time&quot;, NULL, &quot;30min&quot;, &amp;check_timer,</a>
<a name="ln955">          &quot;*** Advanced Use Only ***.&quot;, &quot;If you need to adjust this value, it probably indicates the presence of a bug.&quot;</a>
<a name="ln956">        },</a>
<a name="ln957">	{ &quot;crmd-transition-delay&quot;, NULL, &quot;time&quot;, NULL, &quot;0s&quot;, &amp;check_timer,</a>
<a name="ln958">          &quot;*** Advanced Use Only ***\n&quot;</a>
<a name="ln959">          &quot;Enabling this option will slow down cluster recovery under all conditions&quot;,</a>
<a name="ln960">          &quot;Delay cluster recovery for the configured interval to allow for additional/related events to occur.\n&quot;</a>
<a name="ln961">          &quot;Useful if your configuration is sensitive to the order in which ping updates arrive.&quot;</a>
<a name="ln962">        },</a>
<a name="ln963">	{ &quot;stonith-watchdog-timeout&quot;, NULL, &quot;time&quot;, NULL, NULL, &amp;check_sbd_timeout,</a>
<a name="ln964">	  &quot;How long to wait before we can assume nodes are safely down&quot;, NULL</a>
<a name="ln965">        },</a>
<a name="ln966">        { &quot;stonith-max-attempts&quot;,NULL,&quot;integer&quot;,NULL,&quot;10&quot;,&amp;check_positive_number,</a>
<a name="ln967">          &quot;How many times stonith can fail before it will no longer be attempted on a target&quot;</a>
<a name="ln968">        },   </a>
<a name="ln969">	{ &quot;no-quorum-policy&quot;, &quot;no_quorum_policy&quot;, &quot;enum&quot;, &quot;stop, freeze, ignore, suicide&quot;, &quot;stop&quot;, &amp;check_quorum, NULL, NULL },</a>
<a name="ln970"> </a>
<a name="ln971">#if SUPPORT_PLUGIN</a>
<a name="ln972">	{ XML_ATTR_EXPECTED_VOTES, NULL, &quot;integer&quot;, NULL, &quot;2&quot;, &amp;check_number, &quot;The number of nodes expected to be in the cluster&quot;, &quot;Used to calculate quorum in openais based clusters.&quot; },</a>
<a name="ln973">#endif</a>
<a name="ln974">};</a>
<a name="ln975">/* *INDENT-ON* */</a>
<a name="ln976"> </a>
<a name="ln977">void</a>
<a name="ln978">crmd_metadata(void)</a>
<a name="ln979">{</a>
<a name="ln980">    config_metadata(&quot;CRM Daemon&quot;, &quot;1.0&quot;,</a>
<a name="ln981">                    &quot;CRM Daemon Options&quot;,</a>
<a name="ln982">                    &quot;This is a fake resource that details the options that can be configured for the CRM Daemon.&quot;,</a>
<a name="ln983">                    crmd_opts, DIMOF(crmd_opts));</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986">static void</a>
<a name="ln987">verify_crmd_options(GHashTable * options)</a>
<a name="ln988">{</a>
<a name="ln989">    verify_all_options(options, crmd_opts, DIMOF(crmd_opts));</a>
<a name="ln990">}</a>
<a name="ln991"> </a>
<a name="ln992">static const char *</a>
<a name="ln993">crmd_pref(GHashTable * options, const char *name)</a>
<a name="ln994">{</a>
<a name="ln995">    return get_cluster_pref(options, crmd_opts, DIMOF(crmd_opts), name);</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">static void</a>
<a name="ln999">config_query_callback(xmlNode * msg, int call_id, int rc, xmlNode * output, void *user_data)</a>
<a name="ln1000">{</a>
<a name="ln1001">#ifdef RHEL7_COMPAT</a>
<a name="ln1002">    const char *script = NULL;</a>
<a name="ln1003">#endif</a>
<a name="ln1004">    const char *value = NULL;</a>
<a name="ln1005">    GHashTable *config_hash = NULL;</a>
<a name="ln1006">    crm_time_t *now = crm_time_new(NULL);</a>
<a name="ln1007">    xmlNode *crmconfig = NULL;</a>
<a name="ln1008">    xmlNode *alerts = NULL;</a>
<a name="ln1009"> </a>
<a name="ln1010">    if (rc != pcmk_ok) {</a>
<a name="ln1011">        fsa_data_t *msg_data = NULL;</a>
<a name="ln1012"> </a>
<a name="ln1013">        crm_err(&quot;Local CIB query resulted in an error: %s&quot;, pcmk_strerror(rc));</a>
<a name="ln1014">        register_fsa_error(C_FSA_INTERNAL, I_ERROR, NULL);</a>
<a name="ln1015"> </a>
<a name="ln1016">        if (rc == -EACCES || rc == -pcmk_err_schema_validation) {</a>
<a name="ln1017">            crm_err(&quot;The cluster is mis-configured - shutting down and staying down&quot;);</a>
<a name="ln1018">            set_bit(fsa_input_register, R_STAYDOWN);</a>
<a name="ln1019">        }</a>
<a name="ln1020">        goto bail;</a>
<a name="ln1021">    }</a>
<a name="ln1022"> </a>
<a name="ln1023">    crmconfig = output;</a>
<a name="ln1024">    if ((crmconfig) &amp;&amp;</a>
<a name="ln1025">        (crm_element_name(crmconfig)) &amp;&amp;</a>
<a name="ln1026">        (strcmp(crm_element_name(crmconfig), XML_CIB_TAG_CRMCONFIG) != 0)) {</a>
<a name="ln1027">        crmconfig = first_named_child(crmconfig, XML_CIB_TAG_CRMCONFIG);</a>
<a name="ln1028">    }</a>
<a name="ln1029">    if (!crmconfig) {</a>
<a name="ln1030">        fsa_data_t *msg_data = NULL;</a>
<a name="ln1031"> </a>
<a name="ln1032">        crm_err(&quot;Local CIB query for &quot; XML_CIB_TAG_CRMCONFIG &quot; section failed&quot;);</a>
<a name="ln1033">        register_fsa_error(C_FSA_INTERNAL, I_ERROR, NULL);</a>
<a name="ln1034">        goto bail;</a>
<a name="ln1035">    }</a>
<a name="ln1036"> </a>
<a name="ln1037">    crm_debug(&quot;Call %d : Parsing CIB options&quot;, call_id);</a>
<a name="ln1038">    config_hash =</a>
<a name="ln1039">        g_hash_table_new_full(crm_str_hash, g_str_equal, g_hash_destroy_str, g_hash_destroy_str);</a>
<a name="ln1040"> </a>
<a name="ln1041">    unpack_instance_attributes(crmconfig, crmconfig, XML_CIB_TAG_PROPSET, NULL, config_hash,</a>
<a name="ln1042">                               CIB_OPTIONS_FIRST, FALSE, now);</a>
<a name="ln1043"> </a>
<a name="ln1044">    verify_crmd_options(config_hash);</a>
<a name="ln1045"> </a>
<a name="ln1046">#ifdef RHEL7_COMPAT</a>
<a name="ln1047">    script = crmd_pref(config_hash, &quot;notification-agent&quot;);</a>
<a name="ln1048">    value  = crmd_pref(config_hash, &quot;notification-recipient&quot;);</a>
<a name="ln1049">    crmd_enable_alerts(script, value);</a>
<a name="ln1050">#endif</a>
<a name="ln1051"> </a>
<a name="ln1052">    value = crmd_pref(config_hash, XML_CONFIG_ATTR_DC_DEADTIME);</a>
<a name="ln1053">    election_trigger-&gt;period_ms = crm_get_msec(value);</a>
<a name="ln1054"> </a>
<a name="ln1055">    value = crmd_pref(config_hash, &quot;node-action-limit&quot;); /* Also checks migration-limit */</a>
<a name="ln1056">    throttle_update_job_max(value);</a>
<a name="ln1057"> </a>
<a name="ln1058">    value = crmd_pref(config_hash, &quot;load-threshold&quot;);</a>
<a name="ln1059">    if(value) {</a>
<a name="ln1060">        throttle_set_load_target(strtof(value, NULL) / 100.0);</a>
<a name="ln1061">    }</a>
<a name="ln1062"> </a>
<a name="ln1063">    value = crmd_pref(config_hash, &quot;no-quorum-policy&quot;);</a>
<a name="ln1064">    if (safe_str_eq(value, &quot;suicide&quot;) &amp;&amp; pcmk_locate_sbd()) {</a>
<a name="ln1065">        no_quorum_suicide_escalation = TRUE;</a>
<a name="ln1066">    }</a>
<a name="ln1067"> </a>
<a name="ln1068">    value = crmd_pref(config_hash,&quot;stonith-max-attempts&quot;);</a>
<a name="ln1069">    update_stonith_max_attempts(value);</a>
<a name="ln1070"> </a>
<a name="ln1071">    value = crmd_pref(config_hash, XML_CONFIG_ATTR_FORCE_QUIT);</a>
<a name="ln1072">    shutdown_escalation_timer-&gt;period_ms = crm_get_msec(value);</a>
<a name="ln1073">    /* How long to declare an election over - even if not everyone voted */</a>
<a name="ln1074">    crm_debug(&quot;Shutdown escalation occurs after: %dms&quot;, shutdown_escalation_timer-&gt;period_ms);</a>
<a name="ln1075"> </a>
<a name="ln1076">    value = crmd_pref(config_hash, XML_CONFIG_ATTR_ELECTION_FAIL);</a>
<a name="ln1077">    election_timeout_set_period(fsa_election, crm_get_msec(value));</a>
<a name="ln1078"> </a>
<a name="ln1079">    value = crmd_pref(config_hash, XML_CONFIG_ATTR_RECHECK);</a>
<a name="ln1080">    recheck_timer-&gt;period_ms = crm_get_msec(value);</a>
<a name="ln1081">    crm_debug(&quot;Checking for expired actions every %dms&quot;, recheck_timer-&gt;period_ms);</a>
<a name="ln1082"> </a>
<a name="ln1083">    value = crmd_pref(config_hash, &quot;crmd-transition-delay&quot;);</a>
<a name="ln1084">    transition_timer-&gt;period_ms = crm_get_msec(value);</a>
<a name="ln1085"> </a>
<a name="ln1086">    value = crmd_pref(config_hash, &quot;crmd-integration-timeout&quot;);</a>
<a name="ln1087">    integration_timer-&gt;period_ms = crm_get_msec(value);</a>
<a name="ln1088"> </a>
<a name="ln1089">    value = crmd_pref(config_hash, &quot;crmd-finalization-timeout&quot;);</a>
<a name="ln1090">    finalization_timer-&gt;period_ms = crm_get_msec(value);</a>
<a name="ln1091"> </a>
<a name="ln1092">#if SUPPORT_COROSYNC</a>
<a name="ln1093">    if (is_classic_ais_cluster()) {</a>
<a name="ln1094">        value = crmd_pref(config_hash, XML_ATTR_EXPECTED_VOTES);</a>
<a name="ln1095">        crm_debug(&quot;Sending expected-votes=%s to corosync&quot;, value);</a>
<a name="ln1096">        send_cluster_text(crm_class_quorum, value, TRUE, NULL, crm_msg_ais);</a>
<a name="ln1097">    }</a>
<a name="ln1098">#endif</a>
<a name="ln1099"> </a>
<a name="ln1100">    free(fsa_cluster_name);</a>
<a name="ln1101">    fsa_cluster_name = NULL;</a>
<a name="ln1102"> </a>
<a name="ln1103">    value = g_hash_table_lookup(config_hash, &quot;cluster-name&quot;);</a>
<a name="ln1104">    if (value) {</a>
<a name="ln1105">        fsa_cluster_name = strdup(value);</a>
<a name="ln1106">    }</a>
<a name="ln1107"> </a>
<a name="ln1108">    alerts = first_named_child(output, XML_CIB_TAG_ALERTS);</a>
<a name="ln1109">    parse_alerts(alerts);</a>
<a name="ln1110"> </a>
<a name="ln1111">    set_bit(fsa_input_register, R_READ_CONFIG);</a>
<a name="ln1112">    crm_trace(&quot;Triggering FSA: %s&quot;, __FUNCTION__);</a>
<a name="ln1113">    mainloop_set_trigger(fsa_source);</a>
<a name="ln1114"> </a>
<a name="ln1115">    g_hash_table_destroy(config_hash);</a>
<a name="ln1116">  bail:</a>
<a name="ln1117">    crm_time_free(now);</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">gboolean</a>
<a name="ln1121">crm_read_options(gpointer user_data)</a>
<a name="ln1122">{</a>
<a name="ln1123">    int call_id =</a>
<a name="ln1124">        fsa_cib_conn-&gt;cmds-&gt;query(fsa_cib_conn,</a>
<a name="ln1125">            &quot;//&quot; XML_CIB_TAG_CRMCONFIG &quot; | //&quot; XML_CIB_TAG_ALERTS,</a>
<a name="ln1126">            NULL, cib_xpath | cib_scope_local);</a>
<a name="ln1127"> </a>
<a name="ln1128">    fsa_register_cib_callback(call_id, FALSE, NULL, config_query_callback);</a>
<a name="ln1129">    crm_trace(&quot;Querying the CIB... call %d&quot;, call_id);</a>
<a name="ln1130">    return TRUE;</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133">/*	 A_READCONFIG	*/</a>
<a name="ln1134">void</a>
<a name="ln1135">do_read_config(long long action,</a>
<a name="ln1136">               enum crmd_fsa_cause cause,</a>
<a name="ln1137">               enum crmd_fsa_state cur_state,</a>
<a name="ln1138">               enum crmd_fsa_input current_input, fsa_data_t * msg_data)</a>
<a name="ln1139">{</a>
<a name="ln1140">    throttle_init();</a>
<a name="ln1141">    mainloop_set_trigger(config_read);</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">void</a>
<a name="ln1145">crm_shutdown(int nsig)</a>
<a name="ln1146">{</a>
<a name="ln1147">    if (crmd_mainloop != NULL &amp;&amp; g_main_is_running(crmd_mainloop)) {</a>
<a name="ln1148">        if (is_set(fsa_input_register, R_SHUTDOWN)) {</a>
<a name="ln1149">            crm_err(&quot;Escalating the shutdown&quot;);</a>
<a name="ln1150">            register_fsa_input_before(C_SHUTDOWN, I_ERROR, NULL);</a>
<a name="ln1151"> </a>
<a name="ln1152">        } else {</a>
<a name="ln1153">            set_bit(fsa_input_register, R_SHUTDOWN);</a>
<a name="ln1154">            register_fsa_input(C_SHUTDOWN, I_SHUTDOWN, NULL);</a>
<a name="ln1155"> </a>
<a name="ln1156">            if (shutdown_escalation_timer-&gt;period_ms &lt; 1) {</a>
<a name="ln1157">                const char *value = crmd_pref(NULL, XML_CONFIG_ATTR_FORCE_QUIT);</a>
<a name="ln1158">                int msec = crm_get_msec(value);</a>
<a name="ln1159"> </a>
<a name="ln1160">                crm_debug(&quot;Using default shutdown escalation: %dms&quot;, msec);</a>
<a name="ln1161">                shutdown_escalation_timer-&gt;period_ms = msec;</a>
<a name="ln1162">            }</a>
<a name="ln1163"> </a>
<a name="ln1164">            /* can't rely on this... */</a>
<a name="ln1165">            crm_notice(&quot;Shutting down cluster resource manager &quot; CRM_XS</a>
<a name="ln1166">                       &quot; limit=%dms&quot;, shutdown_escalation_timer-&gt;period_ms);</a>
<a name="ln1167">            crm_timer_start(shutdown_escalation_timer);</a>
<a name="ln1168">        }</a>
<a name="ln1169"> </a>
<a name="ln1170">    } else {</a>
<a name="ln1171">        crm_info(&quot;exit from shutdown&quot;);</a>
<a name="ln1172">        crmd_exit(pcmk_ok);</a>
<a name="ln1173">    }</a>
<a name="ln1174">}</a>

</code></pre>
<div class="balloon" rel="608"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V519/" target="_blank">V519</a> The 'finalization_timer->fsa_input' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 593, 608.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
