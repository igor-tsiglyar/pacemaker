
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (C) 2004 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * This library is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU Lesser General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2.1 of the License, or (at your option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This library is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * Lesser General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU Lesser General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;crm_internal.h&gt;</a>
<a name="ln24">#include &lt;bzlib.h&gt;</a>
<a name="ln25">#include &lt;sys/socket.h&gt;</a>
<a name="ln26">#include &lt;netinet/in.h&gt;</a>
<a name="ln27">#include &lt;arpa/inet.h&gt;</a>
<a name="ln28">#include &lt;netdb.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;crm/common/ipc.h&gt;</a>
<a name="ln31">#include &lt;crm/cluster/internal.h&gt;</a>
<a name="ln32">#include &lt;crm/common/mainloop.h&gt;</a>
<a name="ln33">#include &lt;sys/utsname.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;qb/qbipcc.h&gt;</a>
<a name="ln36">#include &lt;qb/qbutil.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;corosync/corodefs.h&gt;</a>
<a name="ln39">#include &lt;corosync/corotypes.h&gt;</a>
<a name="ln40">#include &lt;corosync/hdb.h&gt;</a>
<a name="ln41">#include &lt;corosync/cfg.h&gt;</a>
<a name="ln42">#include &lt;corosync/cmap.h&gt;</a>
<a name="ln43">#include &lt;corosync/quorum.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;crm/msg_xml.h&gt;</a>
<a name="ln46"> </a>
<a name="ln47">quorum_handle_t pcmk_quorum_handle = 0;</a>
<a name="ln48"> </a>
<a name="ln49">gboolean(*quorum_app_callback) (unsigned long long seq, gboolean quorate) = NULL;</a>
<a name="ln50"> </a>
<a name="ln51">/*</a>
<a name="ln52"> * CFG functionality stolen from node_name() in corosync-quorumtool.c</a>
<a name="ln53"> * This resolves the first address assigned to a node and returns the name or IP address.</a>
<a name="ln54"> */</a>
<a name="ln55">char *</a>
<a name="ln56">corosync_node_name(uint64_t /*cmap_handle_t */ cmap_handle, uint32_t nodeid)</a>
<a name="ln57">{</a>
<a name="ln58">    int lpc = 0;</a>
<a name="ln59">    int rc = CS_OK;</a>
<a name="ln60">    int retries = 0;</a>
<a name="ln61">    char *name = NULL;</a>
<a name="ln62">    cmap_handle_t local_handle = 0;</a>
<a name="ln63"> </a>
<a name="ln64">    /* nodeid == 0 == CMAN_NODEID_US */</a>
<a name="ln65">    if (nodeid == 0) {</a>
<a name="ln66">        nodeid = get_local_nodeid(0);</a>
<a name="ln67">    }</a>
<a name="ln68"> </a>
<a name="ln69">    if (cmap_handle == 0 &amp;&amp; local_handle == 0) {</a>
<a name="ln70">        retries = 0;</a>
<a name="ln71">        crm_trace(&quot;Initializing CMAP connection&quot;);</a>
<a name="ln72">        do {</a>
<a name="ln73">            rc = cmap_initialize(&amp;local_handle);</a>
<a name="ln74">            if (rc != CS_OK) {</a>
<a name="ln75">                retries++;</a>
<a name="ln76">                crm_debug(&quot;API connection setup failed: %s.  Retrying in %ds&quot;, cs_strerror(rc),</a>
<a name="ln77">                          retries);</a>
<a name="ln78">                sleep(retries);</a>
<a name="ln79">            }</a>
<a name="ln80"> </a>
<a name="ln81">        } while (retries &lt; 5 &amp;&amp; rc != CS_OK);</a>
<a name="ln82"> </a>
<a name="ln83">        if (rc != CS_OK) {</a>
<a name="ln84">            crm_warn(&quot;Could not connect to Cluster Configuration Database API, error %s&quot;,</a>
<a name="ln85">                     cs_strerror(rc));</a>
<a name="ln86">            local_handle = 0;</a>
<a name="ln87">        }</a>
<a name="ln88">    }</a>
<a name="ln89"> </a>
<a name="ln90">    if (cmap_handle == 0) {</a>
<a name="ln91">        cmap_handle = local_handle;</a>
<a name="ln92">    }</a>
<a name="ln93"> </a>
<a name="ln94">    while (name == NULL &amp;&amp; cmap_handle != 0) {</a>
<a name="ln95">        uint32_t id = 0;</a>
<a name="ln96">        char *key = NULL;</a>
<a name="ln97"> </a>
<a name="ln98">        key = crm_strdup_printf(&quot;nodelist.node.%d.nodeid&quot;, lpc);</a>
<a name="ln99">        rc = cmap_get_uint32(cmap_handle, key, &amp;id);</a>
<a name="ln100">        crm_trace(&quot;Checking %u vs %u from %s&quot;, nodeid, id, key);</a>
<a name="ln101">        free(key);</a>
<a name="ln102"> </a>
<a name="ln103">        if (rc != CS_OK) {</a>
<a name="ln104">            break;</a>
<a name="ln105">        }</a>
<a name="ln106"> </a>
<a name="ln107">        if (nodeid == id) {</a>
<a name="ln108">            crm_trace(&quot;Searching for node name for %u in nodelist.node.%d %s&quot;, nodeid, lpc, name);</a>
<a name="ln109">            if (name == NULL) {</a>
<a name="ln110">                key = crm_strdup_printf(&quot;nodelist.node.%d.ring0_addr&quot;, lpc);</a>
<a name="ln111">                cmap_get_string(cmap_handle, key, &amp;name);</a>
<a name="ln112">                crm_trace(&quot;%s = %s&quot;, key, name);</a>
<a name="ln113"> </a>
<a name="ln114">                if (node_name_is_valid(key, name) == FALSE) {</a>
<a name="ln115">                    free(name);</a>
<a name="ln116">                    name = NULL;</a>
<a name="ln117">                }</a>
<a name="ln118">                free(key);</a>
<a name="ln119">            }</a>
<a name="ln120"> </a>
<a name="ln121">            if (name == NULL) {</a>
<a name="ln122">                key = crm_strdup_printf(&quot;nodelist.node.%d.name&quot;, lpc);</a>
<a name="ln123">                cmap_get_string(cmap_handle, key, &amp;name);</a>
<a name="ln124">                crm_trace(&quot;%s = %s %d&quot;, key, name, rc);</a>
<a name="ln125">                free(key);</a>
<a name="ln126">            }</a>
<a name="ln127">            break;</a>
<a name="ln128">        }</a>
<a name="ln129"> </a>
<a name="ln130">        lpc++;</a>
<a name="ln131">    }</a>
<a name="ln132"> </a>
<a name="ln133">    if(local_handle) {</a>
<a name="ln134">        cmap_finalize(local_handle);</a>
<a name="ln135">    }</a>
<a name="ln136"> </a>
<a name="ln137">    if (name == NULL) {</a>
<a name="ln138">        crm_info(&quot;Unable to get node name for nodeid %u&quot;, nodeid);</a>
<a name="ln139">    }</a>
<a name="ln140">    return name;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">void</a>
<a name="ln144">terminate_cs_connection(crm_cluster_t *cluster)</a>
<a name="ln145">{</a>
<a name="ln146">    crm_info(&quot;Disconnecting from Corosync&quot;);</a>
<a name="ln147"> </a>
<a name="ln148">    cluster_disconnect_cpg(cluster);</a>
<a name="ln149"> </a>
<a name="ln150">    if (pcmk_quorum_handle) {</a>
<a name="ln151">        crm_trace(&quot;Disconnecting quorum&quot;);</a>
<a name="ln152">        quorum_finalize(pcmk_quorum_handle);</a>
<a name="ln153">        pcmk_quorum_handle = 0;</a>
<a name="ln154"> </a>
<a name="ln155">    } else {</a>
<a name="ln156">        crm_info(&quot;No Quorum connection&quot;);</a>
<a name="ln157">    }</a>
<a name="ln158"> </a>
<a name="ln159">    crm_notice(&quot;Disconnected from Corosync&quot;);</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">int ais_membership_timer = 0;</a>
<a name="ln163">gboolean ais_membership_force = FALSE;</a>
<a name="ln164"> </a>
<a name="ln165"> </a>
<a name="ln166">static int</a>
<a name="ln167">pcmk_quorum_dispatch(gpointer user_data)</a>
<a name="ln168">{</a>
<a name="ln169">    int rc = 0;</a>
<a name="ln170"> </a>
<a name="ln171">    rc = quorum_dispatch(pcmk_quorum_handle, CS_DISPATCH_ALL);</a>
<a name="ln172">    if (rc &lt; 0) {</a>
<a name="ln173">        crm_err(&quot;Connection to the Quorum API failed: %d&quot;, rc);</a>
<a name="ln174">        pcmk_quorum_handle = 0;</a>
<a name="ln175">        return -1;</a>
<a name="ln176">    }</a>
<a name="ln177">    return 0;</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">static void</a>
<a name="ln181">pcmk_quorum_notification(quorum_handle_t handle,</a>
<a name="ln182">                         uint32_t quorate,</a>
<a name="ln183">                         uint64_t ring_id, uint32_t view_list_entries, uint32_t * view_list)</a>
<a name="ln184">{</a>
<a name="ln185">    int i;</a>
<a name="ln186">    GHashTableIter iter;</a>
<a name="ln187">    crm_node_t *node = NULL;</a>
<a name="ln188">    static gboolean init_phase = TRUE;</a>
<a name="ln189"> </a>
<a name="ln190">    if (quorate != crm_have_quorum) {</a>
<a name="ln191">        if (quorate) {</a>
<a name="ln192">            crm_notice(&quot;Quorum acquired &quot; CRM_XS &quot; membership=&quot; U64T &quot; members=%lu&quot;,</a>
<a name="ln193">                       ring_id, (long unsigned int)view_list_entries);</a>
<a name="ln194">        } else {</a>
<a name="ln195">            crm_warn(&quot;Quorum lost &quot; CRM_XS &quot; membership=&quot; U64T &quot; members=%lu&quot;,</a>
<a name="ln196">                     ring_id, (long unsigned int)view_list_entries);</a>
<a name="ln197">        }</a>
<a name="ln198">        crm_have_quorum = quorate;</a>
<a name="ln199"> </a>
<a name="ln200">    } else {</a>
<a name="ln201">        crm_info(&quot;Quorum %s &quot; CRM_XS &quot; membership=&quot; U64T &quot; members=%lu&quot;,</a>
<a name="ln202">                 (quorate? &quot;retained&quot; : &quot;still lost&quot;), ring_id,</a>
<a name="ln203">                 (long unsigned int)view_list_entries);</a>
<a name="ln204">    }</a>
<a name="ln205"> </a>
<a name="ln206">    if (view_list_entries == 0 &amp;&amp; init_phase) {</a>
<a name="ln207">        crm_info(&quot;Corosync membership is still forming, ignoring&quot;);</a>
<a name="ln208">        return;</a>
<a name="ln209">    }</a>
<a name="ln210"> </a>
<a name="ln211">    init_phase = FALSE;</a>
<a name="ln212"> </a>
<a name="ln213">    /* Reset last_seen for all cached nodes so we can tell which ones aren't</a>
<a name="ln214">     * in the view list */</a>
<a name="ln215">    g_hash_table_iter_init(&amp;iter, crm_peer_cache);</a>
<a name="ln216">    while (g_hash_table_iter_next(&amp;iter, NULL, (gpointer *) &amp;node)) {</a>
<a name="ln217">        node-&gt;last_seen = 0;</a>
<a name="ln218">    }</a>
<a name="ln219"> </a>
<a name="ln220">    /* Update the peer cache for each node in view list */</a>
<a name="ln221">    for (i = 0; i &lt; view_list_entries; i++) {</a>
<a name="ln222">        uint32_t id = view_list[i];</a>
<a name="ln223"> </a>
<a name="ln224">        crm_debug(&quot;Member[%d] %u &quot;, i, id);</a>
<a name="ln225"> </a>
<a name="ln226">        /* Get this node's peer cache entry (adding one if not already there) */</a>
<a name="ln227">        node = crm_get_peer(id, NULL);</a>
<a name="ln228">        if (node-&gt;uname == NULL) {</a>
<a name="ln229">            char *name = corosync_node_name(0, id);</a>
<a name="ln230"> </a>
<a name="ln231">            crm_info(&quot;Obtaining name for new node %u&quot;, id);</a>
<a name="ln232">            node = crm_get_peer(id, name);</a>
<a name="ln233">            free(name);</a>
<a name="ln234">        }</a>
<a name="ln235"> </a>
<a name="ln236">        /* Update the node state (including updating last_seen to ring_id) */</a>
<a name="ln237">        crm_update_peer_state(__FUNCTION__, node, CRM_NODE_MEMBER, ring_id);</a>
<a name="ln238">    }</a>
<a name="ln239"> </a>
<a name="ln240">    /* Remove any peer cache entries we didn't update */</a>
<a name="ln241">    crm_reap_unseen_nodes(ring_id);</a>
<a name="ln242"> </a>
<a name="ln243">    if (quorum_app_callback) {</a>
<a name="ln244">        quorum_app_callback(ring_id, quorate);</a>
<a name="ln245">    }</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">quorum_callbacks_t quorum_callbacks = {</a>
<a name="ln249">    .quorum_notify_fn = pcmk_quorum_notification,</a>
<a name="ln250">};</a>
<a name="ln251"> </a>
<a name="ln252">gboolean</a>
<a name="ln253">cluster_connect_quorum(gboolean(*dispatch) (unsigned long long, gboolean),</a>
<a name="ln254">                       void (*destroy) (gpointer))</a>
<a name="ln255">{</a>
<a name="ln256">    int rc = -1;</a>
<a name="ln257">    int fd = 0;</a>
<a name="ln258">    int quorate = 0;</a>
<a name="ln259">    uint32_t quorum_type = 0;</a>
<a name="ln260">    struct mainloop_fd_callbacks quorum_fd_callbacks;</a>
<a name="ln261"> </a>
<a name="ln262">    quorum_fd_callbacks.dispatch = pcmk_quorum_dispatch;</a>
<a name="ln263">    quorum_fd_callbacks.destroy = destroy;</a>
<a name="ln264"> </a>
<a name="ln265">    crm_debug(&quot;Configuring Pacemaker to obtain quorum from Corosync&quot;);</a>
<a name="ln266"> </a>
<a name="ln267">    rc = quorum_initialize(&amp;pcmk_quorum_handle, &amp;quorum_callbacks, &amp;quorum_type);</a>
<a name="ln268">    if (rc != CS_OK) {</a>
<a name="ln269">        crm_err(&quot;Could not connect to the Quorum API: %d&quot;, rc);</a>
<a name="ln270">        goto bail;</a>
<a name="ln271"> </a>
<a name="ln272">    } else if (quorum_type != QUORUM_SET) {</a>
<a name="ln273">        crm_err(&quot;Corosync quorum is not configured&quot;);</a>
<a name="ln274">        goto bail;</a>
<a name="ln275">    }</a>
<a name="ln276"> </a>
<a name="ln277">    rc = quorum_getquorate(pcmk_quorum_handle, &amp;quorate);</a>
<a name="ln278">    if (rc != CS_OK) {</a>
<a name="ln279">        crm_err(&quot;Could not obtain the current Quorum API state: %d&quot;, rc);</a>
<a name="ln280">        goto bail;</a>
<a name="ln281">    }</a>
<a name="ln282"> </a>
<a name="ln283">    if (quorate) {</a>
<a name="ln284">        crm_notice(&quot;Quorum acquired&quot;);</a>
<a name="ln285">    } else {</a>
<a name="ln286">        crm_warn(&quot;Quorum lost&quot;);</a>
<a name="ln287">    }</a>
<a name="ln288">    quorum_app_callback = dispatch;</a>
<a name="ln289">    crm_have_quorum = quorate;</a>
<a name="ln290"> </a>
<a name="ln291">    rc = quorum_trackstart(pcmk_quorum_handle, CS_TRACK_CHANGES | CS_TRACK_CURRENT);</a>
<a name="ln292">    if (rc != CS_OK) {</a>
<a name="ln293">        crm_err(&quot;Could not setup Quorum API notifications: %d&quot;, rc);</a>
<a name="ln294">        goto bail;</a>
<a name="ln295">    }</a>
<a name="ln296"> </a>
<a name="ln297">    rc = quorum_fd_get(pcmk_quorum_handle, &amp;fd);</a>
<a name="ln298">    if (rc != CS_OK) {</a>
<a name="ln299">        crm_err(&quot;Could not obtain the Quorum API connection: %d&quot;, rc);</a>
<a name="ln300">        goto bail;</a>
<a name="ln301">    }</a>
<a name="ln302"> </a>
<a name="ln303">    mainloop_add_fd(&quot;quorum&quot;, G_PRIORITY_HIGH, fd, dispatch, &amp;quorum_fd_callbacks);</a>
<a name="ln304"> </a>
<a name="ln305">    corosync_initialize_nodelist(NULL, FALSE, NULL);</a>
<a name="ln306"> </a>
<a name="ln307">  bail:</a>
<a name="ln308">    if (rc != CS_OK) {</a>
<a name="ln309">        quorum_finalize(pcmk_quorum_handle);</a>
<a name="ln310">        return FALSE;</a>
<a name="ln311">    }</a>
<a name="ln312">    return TRUE;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">gboolean</a>
<a name="ln316">init_cs_connection(crm_cluster_t * cluster)</a>
<a name="ln317">{</a>
<a name="ln318">    int retries = 0;</a>
<a name="ln319"> </a>
<a name="ln320">    while (retries &lt; 5) {</a>
<a name="ln321">        int rc = init_cs_connection_once(cluster);</a>
<a name="ln322"> </a>
<a name="ln323">        retries++;</a>
<a name="ln324"> </a>
<a name="ln325">        switch (rc) {</a>
<a name="ln326">            case CS_OK:</a>
<a name="ln327">                return TRUE;</a>
<a name="ln328">                break;</a>
<a name="ln329">            case CS_ERR_TRY_AGAIN:</a>
<a name="ln330">            case CS_ERR_QUEUE_FULL:</a>
<a name="ln331">                sleep(retries);</a>
<a name="ln332">                break;</a>
<a name="ln333">            default:</a>
<a name="ln334">                return FALSE;</a>
<a name="ln335">        }</a>
<a name="ln336">    }</a>
<a name="ln337"> </a>
<a name="ln338">    crm_err(&quot;Could not connect to corosync after %d retries&quot;, retries);</a>
<a name="ln339">    return FALSE;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">gboolean</a>
<a name="ln343">init_cs_connection_once(crm_cluster_t * cluster)</a>
<a name="ln344">{</a>
<a name="ln345">    crm_node_t *peer = NULL;</a>
<a name="ln346">    enum cluster_type_e stack = get_cluster_type();</a>
<a name="ln347"> </a>
<a name="ln348">    crm_peer_init();</a>
<a name="ln349"> </a>
<a name="ln350">    /* Here we just initialize comms */</a>
<a name="ln351">    if (stack != pcmk_cluster_corosync) {</a>
<a name="ln352">        crm_err(&quot;Invalid cluster type: %s (%d)&quot;, name_for_cluster_type(stack), stack);</a>
<a name="ln353">        return FALSE;</a>
<a name="ln354">    }</a>
<a name="ln355"> </a>
<a name="ln356">    if (cluster_connect_cpg(cluster) == FALSE) {</a>
<a name="ln357">        return FALSE;</a>
<a name="ln358">    }</a>
<a name="ln359">    crm_info(&quot;Connection to '%s': established&quot;, name_for_cluster_type(stack));</a>
<a name="ln360"> </a>
<a name="ln361">    cluster-&gt;nodeid = get_local_nodeid(0);</a>
<a name="ln362">    if(cluster-&gt;nodeid == 0) {</a>
<a name="ln363">        crm_err(&quot;Could not establish local nodeid&quot;);</a>
<a name="ln364">        return FALSE;</a>
<a name="ln365">    }</a>
<a name="ln366"> </a>
<a name="ln367">    cluster-&gt;uname = get_node_name(0);</a>
<a name="ln368">    if(cluster-&gt;uname == NULL) {</a>
<a name="ln369">        crm_err(&quot;Could not establish local node name&quot;);</a>
<a name="ln370">        return FALSE;</a>
<a name="ln371">    }</a>
<a name="ln372"> </a>
<a name="ln373">    /* Ensure the local node always exists */</a>
<a name="ln374">    peer = crm_get_peer(cluster-&gt;nodeid, cluster-&gt;uname);</a>
<a name="ln375">    cluster-&gt;uuid = get_corosync_uuid(peer);</a>
<a name="ln376"> </a>
<a name="ln377">    return TRUE;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">gboolean</a>
<a name="ln381">check_message_sanity(const AIS_Message * msg, const char *data)</a>
<a name="ln382">{</a>
<a name="ln383">    gboolean sane = TRUE;</a>
<a name="ln384">    int dest = msg-&gt;host.type;</a>
<a name="ln385">    int tmp_size = msg-&gt;header.size - sizeof(AIS_Message);</a>
<a name="ln386"> </a>
<a name="ln387">    if (sane &amp;&amp; msg-&gt;header.size == 0) {</a>
<a name="ln388">        crm_warn(&quot;Message with no size&quot;);</a>
<a name="ln389">        sane = FALSE;</a>
<a name="ln390">    }</a>
<a name="ln391"> </a>
<a name="ln392">    if (sane &amp;&amp; msg-&gt;header.error != CS_OK) {</a>
<a name="ln393">        crm_warn(&quot;Message header contains an error: %d&quot;, msg-&gt;header.error);</a>
<a name="ln394">        sane = FALSE;</a>
<a name="ln395">    }</a>
<a name="ln396"> </a>
<a name="ln397">    if (sane &amp;&amp; ais_data_len(msg) != tmp_size) {</a>
<a name="ln398">        crm_warn(&quot;Message payload size is incorrect: expected %d, got %d&quot;, ais_data_len(msg),</a>
<a name="ln399">                 tmp_size);</a>
<a name="ln400">        sane = TRUE;</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">    if (sane &amp;&amp; ais_data_len(msg) == 0) {</a>
<a name="ln404">        crm_warn(&quot;Message with no payload&quot;);</a>
<a name="ln405">        sane = FALSE;</a>
<a name="ln406">    }</a>
<a name="ln407"> </a>
<a name="ln408">    if (sane &amp;&amp; data &amp;&amp; msg-&gt;is_compressed == FALSE) {</a>
<a name="ln409">        int str_size = strlen(data) + 1;</a>
<a name="ln410"> </a>
<a name="ln411">        if (ais_data_len(msg) != str_size) {</a>
<a name="ln412">            int lpc = 0;</a>
<a name="ln413"> </a>
<a name="ln414">            crm_warn(&quot;Message payload is corrupted: expected %d bytes, got %d&quot;,</a>
<a name="ln415">                     ais_data_len(msg), str_size);</a>
<a name="ln416">            sane = FALSE;</a>
<a name="ln417">            for (lpc = (str_size - 10); lpc &lt; msg-&gt;size; lpc++) {</a>
<a name="ln418">                if (lpc &lt; 0) {</a>
<a name="ln419">                    lpc = 0;</a>
<a name="ln420">                }</a>
<a name="ln421">                crm_debug(&quot;bad_data[%d]: %d / '%c'&quot;, lpc, data[lpc], data[lpc]);</a>
<a name="ln422">            }</a>
<a name="ln423">        }</a>
<a name="ln424">    }</a>
<a name="ln425"> </a>
<a name="ln426">    if (sane == FALSE) {</a>
<a name="ln427">        crm_err(&quot;Invalid message %d: (dest=%s:%s, from=%s:%s.%u, compressed=%d, size=%d, total=%d)&quot;,</a>
<a name="ln428">                msg-&gt;id, ais_dest(&amp;(msg-&gt;host)), msg_type2text(dest),</a>
<a name="ln429">                ais_dest(&amp;(msg-&gt;sender)), msg_type2text(msg-&gt;sender.type),</a>
<a name="ln430">                msg-&gt;sender.pid, msg-&gt;is_compressed, ais_data_len(msg), msg-&gt;header.size);</a>
<a name="ln431"> </a>
<a name="ln432">    } else {</a>
<a name="ln433">        crm_trace</a>
<a name="ln434">            (&quot;Verified message %d: (dest=%s:%s, from=%s:%s.%u, compressed=%d, size=%d, total=%d)&quot;,</a>
<a name="ln435">             msg-&gt;id, ais_dest(&amp;(msg-&gt;host)), msg_type2text(dest), ais_dest(&amp;(msg-&gt;sender)),</a>
<a name="ln436">             msg_type2text(msg-&gt;sender.type), msg-&gt;sender.pid, msg-&gt;is_compressed,</a>
<a name="ln437">             ais_data_len(msg), msg-&gt;header.size);</a>
<a name="ln438">    }</a>
<a name="ln439"> </a>
<a name="ln440">    return sane;</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">enum cluster_type_e</a>
<a name="ln444">find_corosync_variant(void)</a>
<a name="ln445">{</a>
<a name="ln446">    int rc = CS_OK;</a>
<a name="ln447">    cmap_handle_t handle;</a>
<a name="ln448"> </a>
<a name="ln449">    rc = cmap_initialize(&amp;handle);</a>
<a name="ln450"> </a>
<a name="ln451">    switch(rc) {</a>
<a name="ln452">        case CS_OK:</a>
<a name="ln453">            break;</a>
<a name="ln454">        case CS_ERR_SECURITY:</a>
<a name="ln455">            crm_debug(&quot;Failed to initialize the cmap API: Permission denied (%d)&quot;, rc);</a>
<a name="ln456">            /* It's there, we just can't talk to it.</a>
<a name="ln457">             * Good enough for us to identify as 'corosync'</a>
<a name="ln458">             */</a>
<a name="ln459">            return pcmk_cluster_corosync;</a>
<a name="ln460"> </a>
<a name="ln461">        default:</a>
<a name="ln462">            crm_info(&quot;Failed to initialize the cmap API: %s (%d)&quot;,</a>
<a name="ln463">                     ais_error2text(rc), rc);</a>
<a name="ln464">            return pcmk_cluster_unknown;</a>
<a name="ln465">    }</a>
<a name="ln466"> </a>
<a name="ln467">    cmap_finalize(handle);</a>
<a name="ln468">    return pcmk_cluster_corosync;</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471">gboolean</a>
<a name="ln472">crm_is_corosync_peer_active(const crm_node_t * node)</a>
<a name="ln473">{</a>
<a name="ln474">    if (node == NULL) {</a>
<a name="ln475">        crm_trace(&quot;NULL&quot;);</a>
<a name="ln476">        return FALSE;</a>
<a name="ln477"> </a>
<a name="ln478">    } else if (safe_str_neq(node-&gt;state, CRM_NODE_MEMBER)) {</a>
<a name="ln479">        crm_trace(&quot;%s: state=%s&quot;, node-&gt;uname, node-&gt;state);</a>
<a name="ln480">        return FALSE;</a>
<a name="ln481"> </a>
<a name="ln482">    } else if ((node-&gt;processes &amp; crm_proc_cpg) == 0) {</a>
<a name="ln483">        crm_trace(&quot;%s: processes=%.16x&quot;, node-&gt;uname, node-&gt;processes);</a>
<a name="ln484">        return FALSE;</a>
<a name="ln485">    }</a>
<a name="ln486">    return TRUE;</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">gboolean</a>
<a name="ln490">corosync_initialize_nodelist(void *cluster, gboolean force_member, xmlNode * xml_parent)</a>
<a name="ln491">{</a>
<a name="ln492">    int lpc = 0;</a>
<a name="ln493">    int rc = CS_OK;</a>
<a name="ln494">    int retries = 0;</a>
<a name="ln495">    gboolean any = FALSE;</a>
<a name="ln496">    cmap_handle_t cmap_handle;</a>
<a name="ln497"> </a>
<a name="ln498">    do {</a>
<a name="ln499">        rc = cmap_initialize(&amp;cmap_handle);</a>
<a name="ln500">        if (rc != CS_OK) {</a>
<a name="ln501">            retries++;</a>
<a name="ln502">            crm_debug(&quot;API connection setup failed: %s.  Retrying in %ds&quot;, cs_strerror(rc),</a>
<a name="ln503">                      retries);</a>
<a name="ln504">            sleep(retries);</a>
<a name="ln505">        }</a>
<a name="ln506"> </a>
<a name="ln507">    } while (retries &lt; 5 &amp;&amp; rc != CS_OK);</a>
<a name="ln508"> </a>
<a name="ln509">    if (rc != CS_OK) {</a>
<a name="ln510">        crm_warn(&quot;Could not connect to Cluster Configuration Database API, error %d&quot;, rc);</a>
<a name="ln511">        return FALSE;</a>
<a name="ln512">    }</a>
<a name="ln513"> </a>
<a name="ln514">    crm_peer_init();</a>
<a name="ln515">    crm_trace(&quot;Initializing corosync nodelist&quot;);</a>
<a name="ln516">    for (lpc = 0;; lpc++) {</a>
<a name="ln517">        uint32_t nodeid = 0;</a>
<a name="ln518">        char *name = NULL;</a>
<a name="ln519">        char *key = NULL;</a>
<a name="ln520"> </a>
<a name="ln521">        key = crm_strdup_printf(&quot;nodelist.node.%d.nodeid&quot;, lpc);</a>
<a name="ln522">        rc = cmap_get_uint32(cmap_handle, key, &amp;nodeid);</a>
<a name="ln523">        free(key);</a>
<a name="ln524"> </a>
<a name="ln525">        if (rc != CS_OK) {</a>
<a name="ln526">            break;</a>
<a name="ln527">        }</a>
<a name="ln528"> </a>
<a name="ln529">        name = corosync_node_name(cmap_handle, nodeid);</a>
<a name="ln530">        if (name != NULL) {</a>
<a name="ln531">            GHashTableIter iter;</a>
<a name="ln532">            crm_node_t *node = NULL;</a>
<a name="ln533"> </a>
<a name="ln534">            g_hash_table_iter_init(&amp;iter, crm_peer_cache);</a>
<a name="ln535">            while (g_hash_table_iter_next(&amp;iter, NULL, (gpointer *) &amp;node)) {</a>
<a name="ln536">                if(node &amp;&amp; node-&gt;uname &amp;&amp; strcasecmp(node-&gt;uname, name) == 0) {</a>
<a name="ln537">                    if (node-&gt;id &amp;&amp; node-&gt;id != nodeid) {</a>
<a name="ln538">                        crm_crit(&quot;Nodes %u and %u share the same name '%s': shutting down&quot;, node-&gt;id,</a>
<a name="ln539">                                 nodeid, name);</a>
<a name="ln540">                        crm_exit(DAEMON_RESPAWN_STOP);</a>
<a name="ln541">                    }</a>
<a name="ln542">                }</a>
<a name="ln543">            }</a>
<a name="ln544">        }</a>
<a name="ln545"> </a>
<a name="ln546">        if (nodeid &gt; 0 || name != NULL) {</a>
<a name="ln547">            crm_trace(&quot;Initializing node[%d] %u = %s&quot;, lpc, nodeid, name);</a>
<a name="ln548">            crm_get_peer(nodeid, name);</a>
<a name="ln549">        }</a>
<a name="ln550"> </a>
<a name="ln551">        if (nodeid &gt; 0 &amp;&amp; name != NULL) {</a>
<a name="ln552">            any = TRUE;</a>
<a name="ln553"> </a>
<a name="ln554">            if (xml_parent) {</a>
<a name="ln555">                xmlNode *node = create_xml_node(xml_parent, XML_CIB_TAG_NODE);</a>
<a name="ln556"> </a>
<a name="ln557">                crm_xml_set_id(node, &quot;%u&quot;, nodeid);</a>
<a name="ln558">                crm_xml_add(node, XML_ATTR_UNAME, name);</a>
<a name="ln559">                if (force_member) {</a>
<a name="ln560">                    crm_xml_add(node, XML_ATTR_TYPE, CRM_NODE_MEMBER);</a>
<a name="ln561">                }</a>
<a name="ln562">            }</a>
<a name="ln563">        }</a>
<a name="ln564"> </a>
<a name="ln565">        free(name);</a>
<a name="ln566">    }</a>
<a name="ln567">    cmap_finalize(cmap_handle);</a>
<a name="ln568">    return any;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">char *</a>
<a name="ln572">corosync_cluster_name(void)</a>
<a name="ln573">{</a>
<a name="ln574">    cmap_handle_t handle;</a>
<a name="ln575">    char *cluster_name = NULL;</a>
<a name="ln576">    int rc = CS_OK;</a>
<a name="ln577"> </a>
<a name="ln578">    rc = cmap_initialize(&amp;handle);</a>
<a name="ln579">    if (rc != CS_OK) {</a>
<a name="ln580">        crm_info(&quot;Failed to initialize the cmap API: %s (%d)&quot;, ais_error2text(rc), rc);</a>
<a name="ln581">        return NULL;</a>
<a name="ln582">    }</a>
<a name="ln583"> </a>
<a name="ln584">    rc = cmap_get_string(handle, &quot;totem.cluster_name&quot;, &amp;cluster_name);</a>
<a name="ln585">    if (rc != CS_OK) {</a>
<a name="ln586">        crm_info(&quot;Cannot get totem.cluster_name: %s (%d)&quot;, ais_error2text(rc), rc);</a>
<a name="ln587"> </a>
<a name="ln588">    } else {</a>
<a name="ln589">        crm_debug(&quot;cmap totem.cluster_name = '%s'&quot;, cluster_name);</a>
<a name="ln590">    }</a>
<a name="ln591"> </a>
<a name="ln592">    cmap_finalize(handle);</a>
<a name="ln593"> </a>
<a name="ln594">    return cluster_name;</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597">int</a>
<a name="ln598">corosync_cmap_has_config(const char *prefix)</a>
<a name="ln599">{</a>
<a name="ln600">    int rc = CS_OK;</a>
<a name="ln601">    int retries = 0;</a>
<a name="ln602">    static int found = -1;</a>
<a name="ln603">    cmap_handle_t cmap_handle;</a>
<a name="ln604">    cmap_iter_handle_t iter_handle;</a>
<a name="ln605">    char key_name[CMAP_KEYNAME_MAXLEN + 1];</a>
<a name="ln606"> </a>
<a name="ln607">    if(found != -1) {</a>
<a name="ln608">        return found;</a>
<a name="ln609">    }</a>
<a name="ln610"> </a>
<a name="ln611">    do {</a>
<a name="ln612">        rc = cmap_initialize(&amp;cmap_handle);</a>
<a name="ln613">        if (rc != CS_OK) {</a>
<a name="ln614">            retries++;</a>
<a name="ln615">            crm_debug(&quot;API connection setup failed: %s.  Retrying in %ds&quot;, cs_strerror(rc),</a>
<a name="ln616">                      retries);</a>
<a name="ln617">            sleep(retries);</a>
<a name="ln618">        }</a>
<a name="ln619"> </a>
<a name="ln620">    } while (retries &lt; 5 &amp;&amp; rc != CS_OK);</a>
<a name="ln621"> </a>
<a name="ln622">    if (rc != CS_OK) {</a>
<a name="ln623">        crm_warn(&quot;Could not connect to Cluster Configuration Database API: %s (rc=%d)&quot;,</a>
<a name="ln624">                 cs_strerror(rc), rc);</a>
<a name="ln625">        return -1;</a>
<a name="ln626">    }</a>
<a name="ln627"> </a>
<a name="ln628">    rc = cmap_iter_init(cmap_handle, prefix, &amp;iter_handle);</a>
<a name="ln629">    if (rc != CS_OK) {</a>
<a name="ln630">        crm_warn(&quot;Failed to initialize iteration for corosync cmap '%s': %s (rc=%d)&quot;,</a>
<a name="ln631">                 prefix, cs_strerror(rc), rc);</a>
<a name="ln632">        goto bail;</a>
<a name="ln633">    }</a>
<a name="ln634"> </a>
<a name="ln635">    found = 0;</a>
<a name="ln636">    while ((rc = cmap_iter_next(cmap_handle, iter_handle, key_name, NULL, NULL)) == CS_OK) {</a>
<a name="ln637">        crm_trace(&quot;'%s' is configured in corosync cmap: %s&quot;, prefix, key_name);</a>
<a name="ln638">        found++;</a>
<a name="ln639">        break;</a>
<a name="ln640">    }</a>
<a name="ln641">    cmap_iter_finalize(cmap_handle, iter_handle);</a>
<a name="ln642"> </a>
<a name="ln643">bail:</a>
<a name="ln644">    cmap_finalize(cmap_handle);</a>
<a name="ln645"> </a>
<a name="ln646">    return found;</a>
<a name="ln647">}</a>

</code></pre>
<div class="balloon" rel="69"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V560/" target="_blank">V560</a> A part of conditional expression is always true: local_handle == 0.</p></div>
<div class="balloon" rel="94"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V560/" target="_blank">V560</a> A part of conditional expression is always true: name == NULL.</p></div>
<div class="balloon" rel="109"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V547/" target="_blank">V547</a> Expression 'name == NULL' is always true.</p></div>
<div class="balloon" rel="639"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V612/" target="_blank">V612</a> An unconditional 'break' within a loop.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
