
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (C) 2004 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * This library is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU Lesser General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2.1 of the License, or (at your option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This library is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * Lesser General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU Lesser General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;crm_internal.h&gt;</a>
<a name="ln24">#include &lt;bzlib.h&gt;</a>
<a name="ln25">#include &lt;sys/socket.h&gt;</a>
<a name="ln26">#include &lt;netinet/in.h&gt;</a>
<a name="ln27">#include &lt;arpa/inet.h&gt;</a>
<a name="ln28">#include &lt;netdb.h&gt;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;crm/common/ipc.h&gt;</a>
<a name="ln31">#include &lt;crm/cluster/internal.h&gt;</a>
<a name="ln32">#include &lt;crm/common/mainloop.h&gt;</a>
<a name="ln33">#include &lt;sys/utsname.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;qb/qbipcc.h&gt;</a>
<a name="ln36">#include &lt;qb/qbutil.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;corosync/corodefs.h&gt;</a>
<a name="ln39">#include &lt;corosync/corotypes.h&gt;</a>
<a name="ln40">#include &lt;corosync/hdb.h&gt;</a>
<a name="ln41">#include &lt;corosync/cpg.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;crm/msg_xml.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">cpg_handle_t pcmk_cpg_handle = 0; /* TODO: Remove, use cluster.cpg_handle */</a>
<a name="ln46"> </a>
<a name="ln47">static bool cpg_evicted = FALSE;</a>
<a name="ln48">gboolean(*pcmk_cpg_dispatch_fn) (int kind, const char *from, const char *data) = NULL;</a>
<a name="ln49"> </a>
<a name="ln50">#define cs_repeat(counter, max, code) do {		\</a>
<a name="ln51">	code;						\</a>
<a name="ln52">	if(rc == CS_ERR_TRY_AGAIN || rc == CS_ERR_QUEUE_FULL) {  \</a>
<a name="ln53">	    counter++;					\</a>
<a name="ln54">	    crm_debug(&quot;Retrying operation after %ds&quot;, counter);	\</a>
<a name="ln55">	    sleep(counter);				\</a>
<a name="ln56">	} else {                                        \</a>
<a name="ln57">            break;                                      \</a>
<a name="ln58">        }                                               \</a>
<a name="ln59">    } while(counter &lt; max)</a>
<a name="ln60"> </a>
<a name="ln61">void</a>
<a name="ln62">cluster_disconnect_cpg(crm_cluster_t *cluster)</a>
<a name="ln63">{</a>
<a name="ln64">    pcmk_cpg_handle = 0;</a>
<a name="ln65">    if (cluster-&gt;cpg_handle) {</a>
<a name="ln66">        crm_trace(&quot;Disconnecting CPG&quot;);</a>
<a name="ln67">        cpg_leave(cluster-&gt;cpg_handle, &amp;cluster-&gt;group);</a>
<a name="ln68">        cpg_finalize(cluster-&gt;cpg_handle);</a>
<a name="ln69">        cluster-&gt;cpg_handle = 0;</a>
<a name="ln70"> </a>
<a name="ln71">    } else {</a>
<a name="ln72">        crm_info(&quot;No CPG connection&quot;);</a>
<a name="ln73">    }</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">uint32_t get_local_nodeid(cpg_handle_t handle)</a>
<a name="ln77">{</a>
<a name="ln78">    int rc = CS_OK;</a>
<a name="ln79">    int retries = 0;</a>
<a name="ln80">    static uint32_t local_nodeid = 0;</a>
<a name="ln81">    cpg_handle_t local_handle = handle;</a>
<a name="ln82">    cpg_callbacks_t cb = { };</a>
<a name="ln83"> </a>
<a name="ln84">    if(local_nodeid != 0) {</a>
<a name="ln85">        return local_nodeid;</a>
<a name="ln86">    }</a>
<a name="ln87"> </a>
<a name="ln88">#if 0</a>
<a name="ln89">    /* Should not be necessary */</a>
<a name="ln90">    if(get_cluster_type() == pcmk_cluster_classic_ais) {</a>
<a name="ln91">        get_ais_details(&amp;local_nodeid, NULL);</a>
<a name="ln92">        goto done;</a>
<a name="ln93">    }</a>
<a name="ln94">#endif</a>
<a name="ln95"> </a>
<a name="ln96">    if(handle == 0) {</a>
<a name="ln97">        crm_trace(&quot;Creating connection&quot;);</a>
<a name="ln98">        cs_repeat(retries, 5, rc = cpg_initialize(&amp;local_handle, &amp;cb));</a>
<a name="ln99">    }</a>
<a name="ln100"> </a>
<a name="ln101">    if (rc == CS_OK) {</a>
<a name="ln102">        retries = 0;</a>
<a name="ln103">        crm_trace(&quot;Performing lookup&quot;);</a>
<a name="ln104">        cs_repeat(retries, 5, rc = cpg_local_get(local_handle, &amp;local_nodeid));</a>
<a name="ln105">    }</a>
<a name="ln106"> </a>
<a name="ln107">    if (rc != CS_OK) {</a>
<a name="ln108">        crm_err(&quot;Could not get local node id from the CPG API: %s (%d)&quot;, ais_error2text(rc), rc);</a>
<a name="ln109">    }</a>
<a name="ln110">    if(handle == 0) {</a>
<a name="ln111">        crm_trace(&quot;Closing connection&quot;);</a>
<a name="ln112">        cpg_finalize(local_handle);</a>
<a name="ln113">    }</a>
<a name="ln114">    crm_debug(&quot;Local nodeid is %u&quot;, local_nodeid);</a>
<a name="ln115">    return local_nodeid;</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118"> </a>
<a name="ln119">GListPtr cs_message_queue = NULL;</a>
<a name="ln120">int cs_message_timer = 0;</a>
<a name="ln121"> </a>
<a name="ln122">static ssize_t crm_cs_flush(gpointer data);</a>
<a name="ln123"> </a>
<a name="ln124">static gboolean</a>
<a name="ln125">crm_cs_flush_cb(gpointer data)</a>
<a name="ln126">{</a>
<a name="ln127">    cs_message_timer = 0;</a>
<a name="ln128">    crm_cs_flush(data);</a>
<a name="ln129">    return FALSE;</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">#define CS_SEND_MAX 200</a>
<a name="ln133">static ssize_t</a>
<a name="ln134">crm_cs_flush(gpointer data)</a>
<a name="ln135">{</a>
<a name="ln136">    int sent = 0;</a>
<a name="ln137">    ssize_t rc = 0;</a>
<a name="ln138">    int queue_len = 0;</a>
<a name="ln139">    static unsigned int last_sent = 0;</a>
<a name="ln140">    cpg_handle_t *handle = (cpg_handle_t *)data;</a>
<a name="ln141"> </a>
<a name="ln142">    if (*handle == 0) {</a>
<a name="ln143">        crm_trace(&quot;Connection is dead&quot;);</a>
<a name="ln144">        return pcmk_ok;</a>
<a name="ln145">    }</a>
<a name="ln146"> </a>
<a name="ln147">    queue_len = g_list_length(cs_message_queue);</a>
<a name="ln148">    if ((queue_len % 1000) == 0 &amp;&amp; queue_len &gt; 1) {</a>
<a name="ln149">        crm_err(&quot;CPG queue has grown to %d&quot;, queue_len);</a>
<a name="ln150"> </a>
<a name="ln151">    } else if (queue_len == CS_SEND_MAX) {</a>
<a name="ln152">        crm_warn(&quot;CPG queue has grown to %d&quot;, queue_len);</a>
<a name="ln153">    }</a>
<a name="ln154"> </a>
<a name="ln155">    if (cs_message_timer) {</a>
<a name="ln156">        /* There is already a timer, wait until it goes off */</a>
<a name="ln157">        crm_trace(&quot;Timer active %d&quot;, cs_message_timer);</a>
<a name="ln158">        return pcmk_ok;</a>
<a name="ln159">    }</a>
<a name="ln160"> </a>
<a name="ln161">    while (cs_message_queue &amp;&amp; sent &lt; CS_SEND_MAX) {</a>
<a name="ln162">        struct iovec *iov = cs_message_queue-&gt;data;</a>
<a name="ln163"> </a>
<a name="ln164">        errno = 0;</a>
<a name="ln165">        rc = cpg_mcast_joined(*handle, CPG_TYPE_AGREED, iov, 1);</a>
<a name="ln166"> </a>
<a name="ln167">        if (rc != CS_OK) {</a>
<a name="ln168">            break;</a>
<a name="ln169">        }</a>
<a name="ln170"> </a>
<a name="ln171">        sent++;</a>
<a name="ln172">        last_sent++;</a>
<a name="ln173">        crm_trace(&quot;CPG message sent, size=%llu&quot;,</a>
<a name="ln174">                  (unsigned long long) iov-&gt;iov_len);</a>
<a name="ln175"> </a>
<a name="ln176">        cs_message_queue = g_list_remove(cs_message_queue, iov);</a>
<a name="ln177">        free(iov-&gt;iov_base);</a>
<a name="ln178">        free(iov);</a>
<a name="ln179">    }</a>
<a name="ln180"> </a>
<a name="ln181">    queue_len -= sent;</a>
<a name="ln182">    if (sent &gt; 1 || cs_message_queue) {</a>
<a name="ln183">        crm_info(&quot;Sent %d CPG messages  (%d remaining, last=%u): %s (%lld)&quot;,</a>
<a name="ln184">                 sent, queue_len, last_sent, ais_error2text(rc),</a>
<a name="ln185">                 (long long) rc);</a>
<a name="ln186">    } else {</a>
<a name="ln187">        crm_trace(&quot;Sent %d CPG messages  (%d remaining, last=%u): %s (%lld)&quot;,</a>
<a name="ln188">                  sent, queue_len, last_sent, ais_error2text(rc),</a>
<a name="ln189">                  (long long) rc);</a>
<a name="ln190">    }</a>
<a name="ln191"> </a>
<a name="ln192">    if (cs_message_queue) {</a>
<a name="ln193">        uint32_t delay_ms = 100;</a>
<a name="ln194">        if(rc != CS_OK) {</a>
<a name="ln195">            /* Proportionally more if sending failed but cap at 1s */</a>
<a name="ln196">            delay_ms = QB_MIN(1000, CS_SEND_MAX + (10 * queue_len));</a>
<a name="ln197">        }</a>
<a name="ln198">        cs_message_timer = g_timeout_add(delay_ms, crm_cs_flush_cb, data);</a>
<a name="ln199">    }</a>
<a name="ln200"> </a>
<a name="ln201">    return rc;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">gboolean</a>
<a name="ln205">send_cpg_iov(struct iovec * iov)</a>
<a name="ln206">{</a>
<a name="ln207">    static unsigned int queued = 0;</a>
<a name="ln208"> </a>
<a name="ln209">    queued++;</a>
<a name="ln210">    crm_trace(&quot;Queueing CPG message %u (%llu bytes)&quot;,</a>
<a name="ln211">              queued, (unsigned long long) iov-&gt;iov_len);</a>
<a name="ln212">    cs_message_queue = g_list_append(cs_message_queue, iov);</a>
<a name="ln213">    crm_cs_flush(&amp;pcmk_cpg_handle);</a>
<a name="ln214">    return TRUE;</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">static int</a>
<a name="ln218">pcmk_cpg_dispatch(gpointer user_data)</a>
<a name="ln219">{</a>
<a name="ln220">    int rc = 0;</a>
<a name="ln221">    crm_cluster_t *cluster = (crm_cluster_t*) user_data;</a>
<a name="ln222"> </a>
<a name="ln223">    rc = cpg_dispatch(cluster-&gt;cpg_handle, CS_DISPATCH_ONE);</a>
<a name="ln224">    if (rc != CS_OK) {</a>
<a name="ln225">        crm_err(&quot;Connection to the CPG API failed: %s (%d)&quot;, ais_error2text(rc), rc);</a>
<a name="ln226">        cluster-&gt;cpg_handle = 0;</a>
<a name="ln227">        return -1;</a>
<a name="ln228"> </a>
<a name="ln229">    } else if(cpg_evicted) {</a>
<a name="ln230">        crm_err(&quot;Evicted from CPG membership&quot;);</a>
<a name="ln231">        return -1;</a>
<a name="ln232">    }</a>
<a name="ln233">    return 0;</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">char *</a>
<a name="ln237">pcmk_message_common_cs(cpg_handle_t handle, uint32_t nodeid, uint32_t pid, void *content,</a>
<a name="ln238">                        uint32_t *kind, const char **from)</a>
<a name="ln239">{</a>
<a name="ln240">    char *data = NULL;</a>
<a name="ln241">    AIS_Message *msg = (AIS_Message *) content;</a>
<a name="ln242"> </a>
<a name="ln243">    if(handle) {</a>
<a name="ln244">        /* 'msg' came from CPG not the plugin</a>
<a name="ln245">         * Do filtering and field massaging</a>
<a name="ln246">         */</a>
<a name="ln247">        uint32_t local_nodeid = get_local_nodeid(handle);</a>
<a name="ln248">        const char *local_name = get_local_node_name();</a>
<a name="ln249"> </a>
<a name="ln250">        if (msg-&gt;sender.id &gt; 0 &amp;&amp; msg-&gt;sender.id != nodeid) {</a>
<a name="ln251">            crm_err(&quot;Nodeid mismatch from %d.%d: claimed nodeid=%u&quot;, nodeid, pid, msg-&gt;sender.id);</a>
<a name="ln252">            return NULL;</a>
<a name="ln253"> </a>
<a name="ln254">        } else if (msg-&gt;host.id != 0 &amp;&amp; (local_nodeid != msg-&gt;host.id)) {</a>
<a name="ln255">            /* Not for us */</a>
<a name="ln256">            crm_trace(&quot;Not for us: %u != %u&quot;, msg-&gt;host.id, local_nodeid);</a>
<a name="ln257">            return NULL;</a>
<a name="ln258">        } else if (msg-&gt;host.size != 0 &amp;&amp; safe_str_neq(msg-&gt;host.uname, local_name)) {</a>
<a name="ln259">            /* Not for us */</a>
<a name="ln260">            crm_trace(&quot;Not for us: %s != %s&quot;, msg-&gt;host.uname, local_name);</a>
<a name="ln261">            return NULL;</a>
<a name="ln262">        }</a>
<a name="ln263"> </a>
<a name="ln264">        msg-&gt;sender.id = nodeid;</a>
<a name="ln265">        if (msg-&gt;sender.size == 0) {</a>
<a name="ln266">            crm_node_t *peer = crm_get_peer(nodeid, NULL);</a>
<a name="ln267"> </a>
<a name="ln268">            if (peer == NULL) {</a>
<a name="ln269">                crm_err(&quot;Peer with nodeid=%u is unknown&quot;, nodeid);</a>
<a name="ln270"> </a>
<a name="ln271">            } else if (peer-&gt;uname == NULL) {</a>
<a name="ln272">                crm_err(&quot;No uname for peer with nodeid=%u&quot;, nodeid);</a>
<a name="ln273"> </a>
<a name="ln274">            } else {</a>
<a name="ln275">                crm_notice(&quot;Fixing uname for peer with nodeid=%u&quot;, nodeid);</a>
<a name="ln276">                msg-&gt;sender.size = strlen(peer-&gt;uname);</a>
<a name="ln277">                memset(msg-&gt;sender.uname, 0, MAX_NAME);</a>
<a name="ln278">                memcpy(msg-&gt;sender.uname, peer-&gt;uname, msg-&gt;sender.size);</a>
<a name="ln279">            }</a>
<a name="ln280">        }</a>
<a name="ln281">    }</a>
<a name="ln282"> </a>
<a name="ln283">    crm_trace(&quot;Got new%s message (size=%d, %d, %d)&quot;,</a>
<a name="ln284">              msg-&gt;is_compressed ? &quot; compressed&quot; : &quot;&quot;,</a>
<a name="ln285">              ais_data_len(msg), msg-&gt;size, msg-&gt;compressed_size);</a>
<a name="ln286"> </a>
<a name="ln287">    if (kind != NULL) {</a>
<a name="ln288">        *kind = msg-&gt;header.id;</a>
<a name="ln289">    }</a>
<a name="ln290">    if (from != NULL) {</a>
<a name="ln291">        *from = msg-&gt;sender.uname;</a>
<a name="ln292">    }</a>
<a name="ln293"> </a>
<a name="ln294">    if (msg-&gt;is_compressed &amp;&amp; msg-&gt;size &gt; 0) {</a>
<a name="ln295">        int rc = BZ_OK;</a>
<a name="ln296">        char *uncompressed = NULL;</a>
<a name="ln297">        unsigned int new_size = msg-&gt;size + 1;</a>
<a name="ln298"> </a>
<a name="ln299">        if (check_message_sanity(msg, NULL) == FALSE) {</a>
<a name="ln300">            goto badmsg;</a>
<a name="ln301">        }</a>
<a name="ln302"> </a>
<a name="ln303">        crm_trace(&quot;Decompressing message data&quot;);</a>
<a name="ln304">        uncompressed = calloc(1, new_size);</a>
<a name="ln305">        rc = BZ2_bzBuffToBuffDecompress(uncompressed, &amp;new_size, msg-&gt;data, msg-&gt;compressed_size, 1, 0);</a>
<a name="ln306"> </a>
<a name="ln307">        if (rc != BZ_OK) {</a>
<a name="ln308">            crm_err(&quot;Decompression failed: %d&quot;, rc);</a>
<a name="ln309">            free(uncompressed);</a>
<a name="ln310">            goto badmsg;</a>
<a name="ln311">        }</a>
<a name="ln312"> </a>
<a name="ln313">        CRM_ASSERT(rc == BZ_OK);</a>
<a name="ln314">        CRM_ASSERT(new_size == msg-&gt;size);</a>
<a name="ln315"> </a>
<a name="ln316">        data = uncompressed;</a>
<a name="ln317"> </a>
<a name="ln318">    } else if (check_message_sanity(msg, data) == FALSE) {</a>
<a name="ln319">        goto badmsg;</a>
<a name="ln320"> </a>
<a name="ln321">    } else if (safe_str_eq(&quot;identify&quot;, data)) {</a>
<a name="ln322">        char *pid_s = crm_itoa((int) getpid());</a>
<a name="ln323"> </a>
<a name="ln324">        send_cluster_text(crm_class_cluster, pid_s, TRUE, NULL, crm_msg_ais);</a>
<a name="ln325">        free(pid_s);</a>
<a name="ln326">        return NULL;</a>
<a name="ln327"> </a>
<a name="ln328">    } else {</a>
<a name="ln329">        data = strdup(msg-&gt;data);</a>
<a name="ln330">    }</a>
<a name="ln331"> </a>
<a name="ln332">    if (msg-&gt;header.id != crm_class_members) {</a>
<a name="ln333">        /* Is this even needed anymore? */</a>
<a name="ln334">        crm_get_peer(msg-&gt;sender.id, msg-&gt;sender.uname);</a>
<a name="ln335">    }</a>
<a name="ln336"> </a>
<a name="ln337">    if (msg-&gt;header.id == crm_class_rmpeer) {</a>
<a name="ln338">        uint32_t id = crm_int_helper(data, NULL);</a>
<a name="ln339"> </a>
<a name="ln340">        crm_info(&quot;Removing peer %s/%u&quot;, data, id);</a>
<a name="ln341">        reap_crm_member(id, NULL);</a>
<a name="ln342">        free(data);</a>
<a name="ln343">        return NULL;</a>
<a name="ln344"> </a>
<a name="ln345">#if SUPPORT_PLUGIN</a>
<a name="ln346">    } else if (is_classic_ais_cluster()) {</a>
<a name="ln347">        plugin_handle_membership(msg);</a>
<a name="ln348">#endif</a>
<a name="ln349">    }</a>
<a name="ln350"> </a>
<a name="ln351">    crm_trace(&quot;Payload: %.200s&quot;, data);</a>
<a name="ln352">    return data;</a>
<a name="ln353"> </a>
<a name="ln354">  badmsg:</a>
<a name="ln355">    crm_err(&quot;Invalid message (id=%d, dest=%s:%s, from=%s:%s.%d):&quot;</a>
<a name="ln356">            &quot; min=%d, total=%d, size=%d, bz2_size=%d&quot;,</a>
<a name="ln357">            msg-&gt;id, ais_dest(&amp;(msg-&gt;host)), msg_type2text(msg-&gt;host.type),</a>
<a name="ln358">            ais_dest(&amp;(msg-&gt;sender)), msg_type2text(msg-&gt;sender.type),</a>
<a name="ln359">            msg-&gt;sender.pid, (int)sizeof(AIS_Message),</a>
<a name="ln360">            msg-&gt;header.size, msg-&gt;size, msg-&gt;compressed_size);</a>
<a name="ln361"> </a>
<a name="ln362">    free(data);</a>
<a name="ln363">    return NULL;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">void</a>
<a name="ln367">pcmk_cpg_membership(cpg_handle_t handle,</a>
<a name="ln368">                    const struct cpg_name *groupName,</a>
<a name="ln369">                    const struct cpg_address *member_list, size_t member_list_entries,</a>
<a name="ln370">                    const struct cpg_address *left_list, size_t left_list_entries,</a>
<a name="ln371">                    const struct cpg_address *joined_list, size_t joined_list_entries)</a>
<a name="ln372">{</a>
<a name="ln373">    int i;</a>
<a name="ln374">    gboolean found = FALSE;</a>
<a name="ln375">    static int counter = 0;</a>
<a name="ln376">    uint32_t local_nodeid = get_local_nodeid(handle);</a>
<a name="ln377"> </a>
<a name="ln378">    for (i = 0; i &lt; left_list_entries; i++) {</a>
<a name="ln379">        crm_node_t *peer = crm_find_peer(left_list[i].nodeid, NULL);</a>
<a name="ln380"> </a>
<a name="ln381">        crm_info(&quot;Node %u left group %s (peer=%s, counter=%d.%d)&quot;,</a>
<a name="ln382">                 left_list[i].nodeid, groupName-&gt;value,</a>
<a name="ln383">                 (peer? peer-&gt;uname : &quot;&lt;none&gt;&quot;), counter, i);</a>
<a name="ln384">        if (peer) {</a>
<a name="ln385">            crm_update_peer_proc(__FUNCTION__, peer, crm_proc_cpg, OFFLINESTATUS);</a>
<a name="ln386">        }</a>
<a name="ln387">    }</a>
<a name="ln388"> </a>
<a name="ln389">    for (i = 0; i &lt; joined_list_entries; i++) {</a>
<a name="ln390">        crm_info(&quot;Node %u joined group %s (counter=%d.%d)&quot;,</a>
<a name="ln391">                 joined_list[i].nodeid, groupName-&gt;value, counter, i);</a>
<a name="ln392">    }</a>
<a name="ln393"> </a>
<a name="ln394">    for (i = 0; i &lt; member_list_entries; i++) {</a>
<a name="ln395">        crm_node_t *peer = crm_get_peer(member_list[i].nodeid, NULL);</a>
<a name="ln396"> </a>
<a name="ln397">        crm_info(&quot;Node %u still member of group %s (peer=%s, counter=%d.%d)&quot;,</a>
<a name="ln398">                 member_list[i].nodeid, groupName-&gt;value,</a>
<a name="ln399">                 (peer? peer-&gt;uname : &quot;&lt;none&gt;&quot;), counter, i);</a>
<a name="ln400"> </a>
<a name="ln401">        /* Anyone that is sending us CPG messages must also be a _CPG_ member.</a>
<a name="ln402">         * But it's _not_ safe to assume it's in the quorum membership.</a>
<a name="ln403">         * We may have just found out it's dead and are processing the last couple of messages it sent</a>
<a name="ln404">         */</a>
<a name="ln405">        peer = crm_update_peer_proc(__FUNCTION__, peer, crm_proc_cpg, ONLINESTATUS);</a>
<a name="ln406">        if(peer &amp;&amp; peer-&gt;state &amp;&amp; crm_is_peer_active(peer) == FALSE) {</a>
<a name="ln407">            time_t now = time(NULL);</a>
<a name="ln408"> </a>
<a name="ln409">            /* Co-opt the otherwise unused votes field */</a>
<a name="ln410">            if(peer-&gt;votes == 0) {</a>
<a name="ln411">                peer-&gt;votes = now;</a>
<a name="ln412"> </a>
<a name="ln413">            } else if(now &gt; (60 + peer-&gt;votes)) {</a>
<a name="ln414">                /* On the otherhand, if we're still getting messages, at a certain point</a>
<a name="ln415">                 * we need to acknowledge our internal cache is probably wrong</a>
<a name="ln416">                 *</a>
<a name="ln417">                 * Set the threshold to 1 minute</a>
<a name="ln418">                 */</a>
<a name="ln419">                crm_err(&quot;Node %s[%u] appears to be online even though we think it is dead&quot;, peer-&gt;uname, peer-&gt;id);</a>
<a name="ln420">                if (crm_update_peer_state(__FUNCTION__, peer, CRM_NODE_MEMBER, 0)) {</a>
<a name="ln421">                    peer-&gt;votes = 0;</a>
<a name="ln422">                }</a>
<a name="ln423">            }</a>
<a name="ln424">        }</a>
<a name="ln425"> </a>
<a name="ln426">        if (local_nodeid == member_list[i].nodeid) {</a>
<a name="ln427">            found = TRUE;</a>
<a name="ln428">        }</a>
<a name="ln429">    }</a>
<a name="ln430"> </a>
<a name="ln431">    if (!found) {</a>
<a name="ln432">        crm_err(&quot;We're not part of CPG group '%s' anymore!&quot;, groupName-&gt;value);</a>
<a name="ln433">        cpg_evicted = TRUE;</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    counter++;</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">gboolean</a>
<a name="ln440">cluster_connect_cpg(crm_cluster_t *cluster)</a>
<a name="ln441">{</a>
<a name="ln442">    int rc = -1;</a>
<a name="ln443">    int fd = 0;</a>
<a name="ln444">    int retries = 0;</a>
<a name="ln445">    uint32_t id = 0;</a>
<a name="ln446">    crm_node_t *peer = NULL;</a>
<a name="ln447">    cpg_handle_t handle = 0;</a>
<a name="ln448"> </a>
<a name="ln449">    struct mainloop_fd_callbacks cpg_fd_callbacks = {</a>
<a name="ln450">        .dispatch = pcmk_cpg_dispatch,</a>
<a name="ln451">        .destroy = cluster-&gt;destroy,</a>
<a name="ln452">    };</a>
<a name="ln453"> </a>
<a name="ln454">    cpg_callbacks_t cpg_callbacks = {</a>
<a name="ln455">        .cpg_deliver_fn = cluster-&gt;cpg.cpg_deliver_fn,</a>
<a name="ln456">        .cpg_confchg_fn = cluster-&gt;cpg.cpg_confchg_fn,</a>
<a name="ln457">        /* .cpg_deliver_fn = pcmk_cpg_deliver, */</a>
<a name="ln458">        /* .cpg_confchg_fn = pcmk_cpg_membership, */</a>
<a name="ln459">    };</a>
<a name="ln460"> </a>
<a name="ln461">    cpg_evicted = FALSE;</a>
<a name="ln462">    cluster-&gt;group.length = 0;</a>
<a name="ln463">    cluster-&gt;group.value[0] = 0;</a>
<a name="ln464"> </a>
<a name="ln465">    /* group.value is char[128] */</a>
<a name="ln466">    strncpy(cluster-&gt;group.value, crm_system_name?crm_system_name:&quot;unknown&quot;, 127);</a>
<a name="ln467">    cluster-&gt;group.value[127] = 0;</a>
<a name="ln468">    cluster-&gt;group.length = 1 + QB_MIN(127, strlen(cluster-&gt;group.value));</a>
<a name="ln469"> </a>
<a name="ln470">    cs_repeat(retries, 30, rc = cpg_initialize(&amp;handle, &amp;cpg_callbacks));</a>
<a name="ln471">    if (rc != CS_OK) {</a>
<a name="ln472">        crm_err(&quot;Could not connect to the Cluster Process Group API: %d&quot;, rc);</a>
<a name="ln473">        goto bail;</a>
<a name="ln474">    }</a>
<a name="ln475"> </a>
<a name="ln476">    id = get_local_nodeid(handle);</a>
<a name="ln477">    if (id == 0) {</a>
<a name="ln478">        crm_err(&quot;Could not get local node id from the CPG API&quot;);</a>
<a name="ln479">        goto bail;</a>
<a name="ln480"> </a>
<a name="ln481">    }</a>
<a name="ln482">    cluster-&gt;nodeid = id;</a>
<a name="ln483"> </a>
<a name="ln484">    retries = 0;</a>
<a name="ln485">    cs_repeat(retries, 30, rc = cpg_join(handle, &amp;cluster-&gt;group));</a>
<a name="ln486">    if (rc != CS_OK) {</a>
<a name="ln487">        crm_err(&quot;Could not join the CPG group '%s': %d&quot;, crm_system_name, rc);</a>
<a name="ln488">        goto bail;</a>
<a name="ln489">    }</a>
<a name="ln490"> </a>
<a name="ln491">    rc = cpg_fd_get(handle, &amp;fd);</a>
<a name="ln492">    if (rc != CS_OK) {</a>
<a name="ln493">        crm_err(&quot;Could not obtain the CPG API connection: %d&quot;, rc);</a>
<a name="ln494">        goto bail;</a>
<a name="ln495">    }</a>
<a name="ln496"> </a>
<a name="ln497">    pcmk_cpg_handle = handle;</a>
<a name="ln498">    cluster-&gt;cpg_handle = handle;</a>
<a name="ln499">    mainloop_add_fd(&quot;corosync-cpg&quot;, G_PRIORITY_MEDIUM, fd, cluster, &amp;cpg_fd_callbacks);</a>
<a name="ln500"> </a>
<a name="ln501">  bail:</a>
<a name="ln502">    if (rc != CS_OK) {</a>
<a name="ln503">        cpg_finalize(handle);</a>
<a name="ln504">        return FALSE;</a>
<a name="ln505">    }</a>
<a name="ln506"> </a>
<a name="ln507">    peer = crm_get_peer(id, NULL);</a>
<a name="ln508">    crm_update_peer_proc(__FUNCTION__, peer, crm_proc_cpg, ONLINESTATUS);</a>
<a name="ln509">    return TRUE;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">gboolean</a>
<a name="ln513">send_cluster_message_cs(xmlNode * msg, gboolean local, crm_node_t * node, enum crm_ais_msg_types dest)</a>
<a name="ln514">{</a>
<a name="ln515">    gboolean rc = TRUE;</a>
<a name="ln516">    char *data = NULL;</a>
<a name="ln517"> </a>
<a name="ln518">    data = dump_xml_unformatted(msg);</a>
<a name="ln519">    rc = send_cluster_text(crm_class_cluster, data, local, node, dest);</a>
<a name="ln520">    free(data);</a>
<a name="ln521">    return rc;</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524">gboolean</a>
<a name="ln525">send_cluster_text(int class, const char *data,</a>
<a name="ln526">              gboolean local, crm_node_t * node, enum crm_ais_msg_types dest)</a>
<a name="ln527">{</a>
<a name="ln528">    static int msg_id = 0;</a>
<a name="ln529">    static int local_pid = 0;</a>
<a name="ln530">    static int local_name_len = 0;</a>
<a name="ln531">    static const char *local_name = NULL;</a>
<a name="ln532"> </a>
<a name="ln533">    char *target = NULL;</a>
<a name="ln534">    struct iovec *iov;</a>
<a name="ln535">    AIS_Message *msg = NULL;</a>
<a name="ln536">    enum crm_ais_msg_types sender = text2msg_type(crm_system_name);</a>
<a name="ln537"> </a>
<a name="ln538">    /* There are only 6 handlers registered to crm_lib_service in plugin.c */</a>
<a name="ln539">    CRM_CHECK(class &lt; 6, crm_err(&quot;Invalid message class: %d&quot;, class);</a>
<a name="ln540">              return FALSE);</a>
<a name="ln541"> </a>
<a name="ln542">#if !SUPPORT_PLUGIN</a>
<a name="ln543">    CRM_CHECK(dest != crm_msg_ais, return FALSE);</a>
<a name="ln544">#endif</a>
<a name="ln545"> </a>
<a name="ln546">    if(local_name == NULL) {</a>
<a name="ln547">        local_name = get_local_node_name();</a>
<a name="ln548">    }</a>
<a name="ln549">    if(local_name_len == 0 &amp;&amp; local_name) {</a>
<a name="ln550">        local_name_len = strlen(local_name);</a>
<a name="ln551">    }</a>
<a name="ln552"> </a>
<a name="ln553">    if (data == NULL) {</a>
<a name="ln554">        data = &quot;&quot;;</a>
<a name="ln555">    }</a>
<a name="ln556"> </a>
<a name="ln557">    if (local_pid == 0) {</a>
<a name="ln558">        local_pid = getpid();</a>
<a name="ln559">    }</a>
<a name="ln560"> </a>
<a name="ln561">    if (sender == crm_msg_none) {</a>
<a name="ln562">        sender = local_pid;</a>
<a name="ln563">    }</a>
<a name="ln564"> </a>
<a name="ln565">    msg = calloc(1, sizeof(AIS_Message));</a>
<a name="ln566"> </a>
<a name="ln567">    msg_id++;</a>
<a name="ln568">    msg-&gt;id = msg_id;</a>
<a name="ln569">    msg-&gt;header.id = class;</a>
<a name="ln570">    msg-&gt;header.error = CS_OK;</a>
<a name="ln571"> </a>
<a name="ln572">    msg-&gt;host.type = dest;</a>
<a name="ln573">    msg-&gt;host.local = local;</a>
<a name="ln574"> </a>
<a name="ln575">    if (node) {</a>
<a name="ln576">        if (node-&gt;uname) {</a>
<a name="ln577">            target = strdup(node-&gt;uname);</a>
<a name="ln578">            msg-&gt;host.size = strlen(node-&gt;uname);</a>
<a name="ln579">            memset(msg-&gt;host.uname, 0, MAX_NAME);</a>
<a name="ln580">            memcpy(msg-&gt;host.uname, node-&gt;uname, msg-&gt;host.size);</a>
<a name="ln581">        } else {</a>
<a name="ln582">            target = crm_strdup_printf(&quot;%u&quot;, node-&gt;id);</a>
<a name="ln583">        }</a>
<a name="ln584">        msg-&gt;host.id = node-&gt;id;</a>
<a name="ln585">    } else {</a>
<a name="ln586">        target = strdup(&quot;all&quot;);</a>
<a name="ln587">    }</a>
<a name="ln588"> </a>
<a name="ln589">    msg-&gt;sender.id = 0;</a>
<a name="ln590">    msg-&gt;sender.type = sender;</a>
<a name="ln591">    msg-&gt;sender.pid = local_pid;</a>
<a name="ln592">    msg-&gt;sender.size = local_name_len;</a>
<a name="ln593">    memset(msg-&gt;sender.uname, 0, MAX_NAME);</a>
<a name="ln594">    if(local_name &amp;&amp; msg-&gt;sender.size) {</a>
<a name="ln595">        memcpy(msg-&gt;sender.uname, local_name, msg-&gt;sender.size);</a>
<a name="ln596">    }</a>
<a name="ln597"> </a>
<a name="ln598">    msg-&gt;size = 1 + strlen(data);</a>
<a name="ln599">    msg-&gt;header.size = sizeof(AIS_Message) + msg-&gt;size;</a>
<a name="ln600"> </a>
<a name="ln601">    if (msg-&gt;size &lt; CRM_BZ2_THRESHOLD) {</a>
<a name="ln602">        msg = realloc_safe(msg, msg-&gt;header.size);</a>
<a name="ln603">        memcpy(msg-&gt;data, data, msg-&gt;size);</a>
<a name="ln604"> </a>
<a name="ln605">    } else {</a>
<a name="ln606">        char *compressed = NULL;</a>
<a name="ln607">        unsigned int new_size = 0;</a>
<a name="ln608">        char *uncompressed = strdup(data);</a>
<a name="ln609"> </a>
<a name="ln610">        if (crm_compress_string(uncompressed, msg-&gt;size, 0, &amp;compressed, &amp;new_size)) {</a>
<a name="ln611"> </a>
<a name="ln612">            msg-&gt;header.size = sizeof(AIS_Message) + new_size;</a>
<a name="ln613">            msg = realloc_safe(msg, msg-&gt;header.size);</a>
<a name="ln614">            memcpy(msg-&gt;data, compressed, new_size);</a>
<a name="ln615"> </a>
<a name="ln616">            msg-&gt;is_compressed = TRUE;</a>
<a name="ln617">            msg-&gt;compressed_size = new_size;</a>
<a name="ln618"> </a>
<a name="ln619">        } else {</a>
<a name="ln620">            msg = realloc_safe(msg, msg-&gt;header.size);</a>
<a name="ln621">            memcpy(msg-&gt;data, data, msg-&gt;size);</a>
<a name="ln622">        }</a>
<a name="ln623"> </a>
<a name="ln624">        free(uncompressed);</a>
<a name="ln625">        free(compressed);</a>
<a name="ln626">    }</a>
<a name="ln627"> </a>
<a name="ln628">    iov = calloc(1, sizeof(struct iovec));</a>
<a name="ln629">    iov-&gt;iov_base = msg;</a>
<a name="ln630">    iov-&gt;iov_len = msg-&gt;header.size;</a>
<a name="ln631"> </a>
<a name="ln632">    if (msg-&gt;compressed_size) {</a>
<a name="ln633">        crm_trace(&quot;Queueing CPG message %u to %s (%llu bytes, %d bytes compressed payload): %.200s&quot;,</a>
<a name="ln634">                  msg-&gt;id, target, (unsigned long long) iov-&gt;iov_len,</a>
<a name="ln635">                  msg-&gt;compressed_size, data);</a>
<a name="ln636">    } else {</a>
<a name="ln637">        crm_trace(&quot;Queueing CPG message %u to %s (%llu bytes, %d bytes payload): %.200s&quot;,</a>
<a name="ln638">                  msg-&gt;id, target, (unsigned long long) iov-&gt;iov_len,</a>
<a name="ln639">                  msg-&gt;size, data);</a>
<a name="ln640">    }</a>
<a name="ln641">    free(target);</a>
<a name="ln642"> </a>
<a name="ln643">#if SUPPORT_PLUGIN</a>
<a name="ln644">    /* The plugin is the only time we don't use CPG messaging */</a>
<a name="ln645">    if(get_cluster_type() == pcmk_cluster_classic_ais) {</a>
<a name="ln646">        return send_plugin_text(class, iov);</a>
<a name="ln647">    }</a>
<a name="ln648">#endif</a>
<a name="ln649"> </a>
<a name="ln650">    send_cpg_iov(iov);</a>
<a name="ln651"> </a>
<a name="ln652">    return TRUE;</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">enum crm_ais_msg_types</a>
<a name="ln656">text2msg_type(const char *text)</a>
<a name="ln657">{</a>
<a name="ln658">    int type = crm_msg_none;</a>
<a name="ln659"> </a>
<a name="ln660">    CRM_CHECK(text != NULL, return type);</a>
<a name="ln661">    if (safe_str_eq(text, &quot;ais&quot;)) {</a>
<a name="ln662">        type = crm_msg_ais;</a>
<a name="ln663">    } else if (safe_str_eq(text, &quot;crm_plugin&quot;)) {</a>
<a name="ln664">        type = crm_msg_ais;</a>
<a name="ln665">    } else if (safe_str_eq(text, CRM_SYSTEM_CIB)) {</a>
<a name="ln666">        type = crm_msg_cib;</a>
<a name="ln667">    } else if (safe_str_eq(text, CRM_SYSTEM_CRMD)) {</a>
<a name="ln668">        type = crm_msg_crmd;</a>
<a name="ln669">    } else if (safe_str_eq(text, CRM_SYSTEM_DC)) {</a>
<a name="ln670">        type = crm_msg_crmd;</a>
<a name="ln671">    } else if (safe_str_eq(text, CRM_SYSTEM_TENGINE)) {</a>
<a name="ln672">        type = crm_msg_te;</a>
<a name="ln673">    } else if (safe_str_eq(text, CRM_SYSTEM_PENGINE)) {</a>
<a name="ln674">        type = crm_msg_pe;</a>
<a name="ln675">    } else if (safe_str_eq(text, CRM_SYSTEM_LRMD)) {</a>
<a name="ln676">        type = crm_msg_lrmd;</a>
<a name="ln677">    } else if (safe_str_eq(text, CRM_SYSTEM_STONITHD)) {</a>
<a name="ln678">        type = crm_msg_stonithd;</a>
<a name="ln679">    } else if (safe_str_eq(text, &quot;stonith-ng&quot;)) {</a>
<a name="ln680">        type = crm_msg_stonith_ng;</a>
<a name="ln681">    } else if (safe_str_eq(text, &quot;attrd&quot;)) {</a>
<a name="ln682">        type = crm_msg_attrd;</a>
<a name="ln683"> </a>
<a name="ln684">    } else {</a>
<a name="ln685">        /* This will normally be a transient client rather than</a>
<a name="ln686">         * a cluster daemon.  Set the type to the pid of the client</a>
<a name="ln687">         */</a>
<a name="ln688">        int scan_rc = sscanf(text, &quot;%d&quot;, &amp;type);</a>
<a name="ln689"> </a>
<a name="ln690">        if (scan_rc != 1 || type &lt;= crm_msg_stonith_ng) {</a>
<a name="ln691">            /* Ensure it's sane */</a>
<a name="ln692">            type = crm_msg_none;</a>
<a name="ln693">        }</a>
<a name="ln694">    }</a>
<a name="ln695">    return type;</a>
<a name="ln696">}</a>

</code></pre>
<div class="balloon" rel="313"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V562/" target="_blank">V562</a> It's odd to compare 0 or 1 with a value of 0: (rc == 0) == (0).</p></div>
<div class="balloon" rel="362"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The null pointer is passed into 'free' function. Inspect the first argument.</p></div>
<div class="balloon" rel="568"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'msg'. Check lines: 568, 565.</p></div>
<div class="balloon" rel="629"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'iov'. Check lines: 629, 628.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
