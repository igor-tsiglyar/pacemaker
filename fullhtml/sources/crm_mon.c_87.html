
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (C) 2004-2015 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * This program is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2 of the License, or (at your option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This software is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;crm_internal.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;sys/param.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &lt;crm/crm.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;stdio.h&gt;</a>
<a name="ln30">#include &lt;sys/types.h&gt;</a>
<a name="ln31">#include &lt;sys/stat.h&gt;</a>
<a name="ln32">#include &lt;unistd.h&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;stdlib.h&gt;</a>
<a name="ln35">#include &lt;errno.h&gt;</a>
<a name="ln36">#include &lt;fcntl.h&gt;</a>
<a name="ln37">#include &lt;libgen.h&gt;</a>
<a name="ln38">#include &lt;sys/utsname.h&gt;</a>
<a name="ln39"> </a>
<a name="ln40">#include &lt;crm/msg_xml.h&gt;</a>
<a name="ln41">#include &lt;crm/services.h&gt;</a>
<a name="ln42">#include &lt;crm/lrmd.h&gt;</a>
<a name="ln43">#include &lt;crm/common/util.h&gt;</a>
<a name="ln44">#include &lt;crm/common/xml.h&gt;</a>
<a name="ln45">#include &lt;crm/common/ipc.h&gt;</a>
<a name="ln46">#include &lt;crm/common/mainloop.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">#include &lt;crm/cib/internal.h&gt;</a>
<a name="ln49">#include &lt;crm/pengine/status.h&gt;</a>
<a name="ln50">#include &lt;crm/pengine/internal.h&gt;</a>
<a name="ln51">#include &lt;../lib/pengine/unpack.h&gt;</a>
<a name="ln52">#include &lt;../pengine/pengine.h&gt;</a>
<a name="ln53">#include &lt;crm/stonith-ng.h&gt;</a>
<a name="ln54"> </a>
<a name="ln55">extern void cleanup_alloc_calculations(pe_working_set_t * data_set);</a>
<a name="ln56"> </a>
<a name="ln57">void clean_up(int rc);</a>
<a name="ln58">void crm_diff_update(const char *event, xmlNode * msg);</a>
<a name="ln59">gboolean mon_refresh_display(gpointer user_data);</a>
<a name="ln60">int cib_connect(gboolean full);</a>
<a name="ln61">void mon_st_callback(stonith_t * st, stonith_event_t * e);</a>
<a name="ln62">static char *get_node_display_name(node_t *node);</a>
<a name="ln63"> </a>
<a name="ln64">/*</a>
<a name="ln65"> * Definitions indicating which items to print</a>
<a name="ln66"> */</a>
<a name="ln67"> </a>
<a name="ln68">#define mon_show_times      (0x0001U)</a>
<a name="ln69">#define mon_show_stack      (0x0002U)</a>
<a name="ln70">#define mon_show_dc         (0x0004U)</a>
<a name="ln71">#define mon_show_count      (0x0008U)</a>
<a name="ln72">#define mon_show_nodes      (0x0010U)</a>
<a name="ln73">#define mon_show_resources  (0x0020U)</a>
<a name="ln74">#define mon_show_attributes (0x0040U)</a>
<a name="ln75">#define mon_show_failcounts (0x0080U)</a>
<a name="ln76">#define mon_show_operations (0x0100U)</a>
<a name="ln77">#define mon_show_tickets    (0x0200U)</a>
<a name="ln78">#define mon_show_bans       (0x0400U)</a>
<a name="ln79"> </a>
<a name="ln80">#define mon_show_headers    (mon_show_times | mon_show_stack | mon_show_dc | mon_show_count)</a>
<a name="ln81">#define mon_show_default    (mon_show_headers | mon_show_nodes | mon_show_resources)</a>
<a name="ln82">#define mon_show_all        (mon_show_default | mon_show_attributes | mon_show_failcounts \</a>
<a name="ln83">                     | mon_show_operations | mon_show_tickets | mon_show_bans)</a>
<a name="ln84"> </a>
<a name="ln85">unsigned int show = mon_show_default;</a>
<a name="ln86"> </a>
<a name="ln87">/*</a>
<a name="ln88"> * Definitions indicating how to output</a>
<a name="ln89"> */</a>
<a name="ln90"> </a>
<a name="ln91">enum mon_output_format_e {</a>
<a name="ln92">    mon_output_none,</a>
<a name="ln93">    mon_output_monitor,</a>
<a name="ln94">    mon_output_plain,</a>
<a name="ln95">    mon_output_console,</a>
<a name="ln96">    mon_output_xml,</a>
<a name="ln97">    mon_output_html,</a>
<a name="ln98">    mon_output_cgi</a>
<a name="ln99">} output_format = mon_output_console;</a>
<a name="ln100"> </a>
<a name="ln101">char *output_filename = NULL;   /* if sending output to a file, its name */</a>
<a name="ln102"> </a>
<a name="ln103">/* other globals */</a>
<a name="ln104">char *xml_file = NULL;</a>
<a name="ln105">char *pid_file = NULL;</a>
<a name="ln106">char *snmp_target = NULL;</a>
<a name="ln107">char *snmp_community = NULL;</a>
<a name="ln108"> </a>
<a name="ln109">gboolean group_by_node = FALSE;</a>
<a name="ln110">gboolean inactive_resources = FALSE;</a>
<a name="ln111">int reconnect_msec = 5000;</a>
<a name="ln112">gboolean daemonize = FALSE;</a>
<a name="ln113">GMainLoop *mainloop = NULL;</a>
<a name="ln114">guint timer_id = 0;</a>
<a name="ln115">GList *attr_list = NULL;</a>
<a name="ln116"> </a>
<a name="ln117">const char *crm_mail_host = NULL;</a>
<a name="ln118">const char *crm_mail_prefix = NULL;</a>
<a name="ln119">const char *crm_mail_from = NULL;</a>
<a name="ln120">const char *crm_mail_to = NULL;</a>
<a name="ln121">const char *external_agent = NULL;</a>
<a name="ln122">const char *external_recipient = NULL;</a>
<a name="ln123"> </a>
<a name="ln124">cib_t *cib = NULL;</a>
<a name="ln125">stonith_t *st = NULL;</a>
<a name="ln126">xmlNode *current_cib = NULL;</a>
<a name="ln127"> </a>
<a name="ln128">gboolean one_shot = FALSE;</a>
<a name="ln129">gboolean has_warnings = FALSE;</a>
<a name="ln130">gboolean print_timing = FALSE;</a>
<a name="ln131">gboolean watch_fencing = FALSE;</a>
<a name="ln132">gboolean print_brief = FALSE;</a>
<a name="ln133">gboolean print_pending = TRUE;</a>
<a name="ln134">gboolean print_clone_detail = FALSE;</a>
<a name="ln135"> </a>
<a name="ln136">/* FIXME allow, detect, and correctly interpret glob pattern or regex? */</a>
<a name="ln137">const char *print_neg_location_prefix = &quot;&quot;;</a>
<a name="ln138"> </a>
<a name="ln139">/* Never display node attributes whose name starts with one of these prefixes */</a>
<a name="ln140">#define FILTER_STR { CRM_FAIL_COUNT_PREFIX, CRM_LAST_FAILURE_PREFIX,       \</a>
<a name="ln141">                     &quot;shutdown&quot;, &quot;terminate&quot;, &quot;standby&quot;, &quot;probe_complete&quot;, \</a>
<a name="ln142">                     &quot;#&quot;, NULL }</a>
<a name="ln143"> </a>
<a name="ln144">long last_refresh = 0;</a>
<a name="ln145">crm_trigger_t *refresh_trigger = NULL;</a>
<a name="ln146"> </a>
<a name="ln147">/*</a>
<a name="ln148"> * 1.3.6.1.4.1.32723 has been assigned to the project by IANA</a>
<a name="ln149"> * http://www.iana.org/assignments/enterprise-numbers</a>
<a name="ln150"> */</a>
<a name="ln151">#define PACEMAKER_PREFIX &quot;1.3.6.1.4.1.32723&quot;</a>
<a name="ln152">#define PACEMAKER_TRAP_PREFIX PACEMAKER_PREFIX &quot;.1&quot;</a>
<a name="ln153"> </a>
<a name="ln154">#define snmp_crm_trap_oid   PACEMAKER_TRAP_PREFIX</a>
<a name="ln155">#define snmp_crm_oid_node   PACEMAKER_TRAP_PREFIX &quot;.1&quot;</a>
<a name="ln156">#define snmp_crm_oid_rsc    PACEMAKER_TRAP_PREFIX &quot;.2&quot;</a>
<a name="ln157">#define snmp_crm_oid_task   PACEMAKER_TRAP_PREFIX &quot;.3&quot;</a>
<a name="ln158">#define snmp_crm_oid_desc   PACEMAKER_TRAP_PREFIX &quot;.4&quot;</a>
<a name="ln159">#define snmp_crm_oid_status PACEMAKER_TRAP_PREFIX &quot;.5&quot;</a>
<a name="ln160">#define snmp_crm_oid_rc     PACEMAKER_TRAP_PREFIX &quot;.6&quot;</a>
<a name="ln161">#define snmp_crm_oid_trc    PACEMAKER_TRAP_PREFIX &quot;.7&quot;</a>
<a name="ln162"> </a>
<a name="ln163">/* Define exit codes for monitoring-compatible output */</a>
<a name="ln164">#define MON_STATUS_OK   (0)</a>
<a name="ln165">#define MON_STATUS_WARN (1)</a>
<a name="ln166"> </a>
<a name="ln167">/* Convenience macro for prettifying output (e.g. &quot;node&quot; vs &quot;nodes&quot;) */</a>
<a name="ln168">#define s_if_plural(i) (((i) == 1)? &quot;&quot; : &quot;s&quot;)</a>
<a name="ln169"> </a>
<a name="ln170">#if CURSES_ENABLED</a>
<a name="ln171">#  define print_dot() if (output_format == mon_output_console) { \</a>
<a name="ln172">	printw(&quot;.&quot;);				\</a>
<a name="ln173">	clrtoeol();				\</a>
<a name="ln174">	refresh();				\</a>
<a name="ln175">    } else {					\</a>
<a name="ln176">	fprintf(stdout, &quot;.&quot;);			\</a>
<a name="ln177">    }</a>
<a name="ln178">#else</a>
<a name="ln179">#  define print_dot() fprintf(stdout, &quot;.&quot;);</a>
<a name="ln180">#endif</a>
<a name="ln181"> </a>
<a name="ln182">#if CURSES_ENABLED</a>
<a name="ln183">#  define print_as(fmt, args...) if (output_format == mon_output_console) { \</a>
<a name="ln184">	printw(fmt, ##args);				\</a>
<a name="ln185">	clrtoeol();					\</a>
<a name="ln186">	refresh();					\</a>
<a name="ln187">    } else {						\</a>
<a name="ln188">	fprintf(stdout, fmt, ##args);			\</a>
<a name="ln189">    }</a>
<a name="ln190">#else</a>
<a name="ln191">#  define print_as(fmt, args...) fprintf(stdout, fmt, ##args);</a>
<a name="ln192">#endif</a>
<a name="ln193"> </a>
<a name="ln194">static void</a>
<a name="ln195">blank_screen(void)</a>
<a name="ln196">{</a>
<a name="ln197">#if CURSES_ENABLED</a>
<a name="ln198">    int lpc = 0;</a>
<a name="ln199"> </a>
<a name="ln200">    for (lpc = 0; lpc &lt; LINES; lpc++) {</a>
<a name="ln201">        move(lpc, 0);</a>
<a name="ln202">        clrtoeol();</a>
<a name="ln203">    }</a>
<a name="ln204">    move(0, 0);</a>
<a name="ln205">    refresh();</a>
<a name="ln206">#endif</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">static gboolean</a>
<a name="ln210">mon_timer_popped(gpointer data)</a>
<a name="ln211">{</a>
<a name="ln212">    int rc = pcmk_ok;</a>
<a name="ln213"> </a>
<a name="ln214">#if CURSES_ENABLED</a>
<a name="ln215">    if (output_format == mon_output_console) {</a>
<a name="ln216">        clear();</a>
<a name="ln217">        refresh();</a>
<a name="ln218">    }</a>
<a name="ln219">#endif</a>
<a name="ln220"> </a>
<a name="ln221">    if (timer_id &gt; 0) {</a>
<a name="ln222">        g_source_remove(timer_id);</a>
<a name="ln223">    }</a>
<a name="ln224"> </a>
<a name="ln225">    print_as(&quot;Reconnecting...\n&quot;);</a>
<a name="ln226">    rc = cib_connect(TRUE);</a>
<a name="ln227"> </a>
<a name="ln228">    if (rc != pcmk_ok) {</a>
<a name="ln229">        timer_id = g_timeout_add(reconnect_msec, mon_timer_popped, NULL);</a>
<a name="ln230">    }</a>
<a name="ln231">    return FALSE;</a>
<a name="ln232">}</a>
<a name="ln233"> </a>
<a name="ln234">static void</a>
<a name="ln235">mon_cib_connection_destroy(gpointer user_data)</a>
<a name="ln236">{</a>
<a name="ln237">    print_as(&quot;Connection to the CIB terminated\n&quot;);</a>
<a name="ln238">    if (cib) {</a>
<a name="ln239">        cib-&gt;cmds-&gt;signoff(cib);</a>
<a name="ln240">        timer_id = g_timeout_add(reconnect_msec, mon_timer_popped, NULL);</a>
<a name="ln241">    }</a>
<a name="ln242">    return;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">/*</a>
<a name="ln246"> * Mainloop signal handler.</a>
<a name="ln247"> */</a>
<a name="ln248">static void</a>
<a name="ln249">mon_shutdown(int nsig)</a>
<a name="ln250">{</a>
<a name="ln251">    clean_up(EX_OK);</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">#if ON_DARWIN</a>
<a name="ln255">#  define sighandler_t sig_t</a>
<a name="ln256">#endif</a>
<a name="ln257"> </a>
<a name="ln258">#if CURSES_ENABLED</a>
<a name="ln259">#  ifndef HAVE_SIGHANDLER_T</a>
<a name="ln260">typedef void (*sighandler_t) (int);</a>
<a name="ln261">#  endif</a>
<a name="ln262">static sighandler_t ncurses_winch_handler;</a>
<a name="ln263">static void</a>
<a name="ln264">mon_winresize(int nsig)</a>
<a name="ln265">{</a>
<a name="ln266">    static int not_done;</a>
<a name="ln267">    int lines = 0, cols = 0;</a>
<a name="ln268"> </a>
<a name="ln269">    if (!not_done++) {</a>
<a name="ln270">        if (ncurses_winch_handler)</a>
<a name="ln271">            /* the original ncurses WINCH signal handler does the</a>
<a name="ln272">             * magic of retrieving the new window size;</a>
<a name="ln273">             * otherwise, we'd have to use ioctl or tgetent */</a>
<a name="ln274">            (*ncurses_winch_handler) (SIGWINCH);</a>
<a name="ln275">        getmaxyx(stdscr, lines, cols);</a>
<a name="ln276">        resizeterm(lines, cols);</a>
<a name="ln277">        mainloop_set_trigger(refresh_trigger);</a>
<a name="ln278">    }</a>
<a name="ln279">    not_done--;</a>
<a name="ln280">}</a>
<a name="ln281">#endif</a>
<a name="ln282"> </a>
<a name="ln283">int</a>
<a name="ln284">cib_connect(gboolean full)</a>
<a name="ln285">{</a>
<a name="ln286">    int rc = pcmk_ok;</a>
<a name="ln287">    static gboolean need_pass = TRUE;</a>
<a name="ln288"> </a>
<a name="ln289">    CRM_CHECK(cib != NULL, return -EINVAL);</a>
<a name="ln290"> </a>
<a name="ln291">    if (getenv(&quot;CIB_passwd&quot;) != NULL) {</a>
<a name="ln292">        need_pass = FALSE;</a>
<a name="ln293">    }</a>
<a name="ln294"> </a>
<a name="ln295">    if (watch_fencing &amp;&amp; st == NULL) {</a>
<a name="ln296">        st = stonith_api_new();</a>
<a name="ln297">    }</a>
<a name="ln298"> </a>
<a name="ln299">    if (watch_fencing &amp;&amp; st-&gt;state == stonith_disconnected) {</a>
<a name="ln300">        crm_trace(&quot;Connecting to stonith&quot;);</a>
<a name="ln301">        rc = st-&gt;cmds-&gt;connect(st, crm_system_name, NULL);</a>
<a name="ln302">        if (rc == pcmk_ok) {</a>
<a name="ln303">            crm_trace(&quot;Setting up stonith callbacks&quot;);</a>
<a name="ln304">            st-&gt;cmds-&gt;register_notification(st, T_STONITH_NOTIFY_FENCE, mon_st_callback);</a>
<a name="ln305">        }</a>
<a name="ln306">    }</a>
<a name="ln307"> </a>
<a name="ln308">    if (cib-&gt;state != cib_connected_query &amp;&amp; cib-&gt;state != cib_connected_command) {</a>
<a name="ln309">        crm_trace(&quot;Connecting to the CIB&quot;);</a>
<a name="ln310">        if ((output_format == mon_output_console) &amp;&amp; need_pass &amp;&amp; (cib-&gt;variant == cib_remote)) {</a>
<a name="ln311">            need_pass = FALSE;</a>
<a name="ln312">            print_as(&quot;Password:&quot;);</a>
<a name="ln313">        }</a>
<a name="ln314"> </a>
<a name="ln315">        rc = cib-&gt;cmds-&gt;signon(cib, crm_system_name, cib_query);</a>
<a name="ln316"> </a>
<a name="ln317">        if (rc != pcmk_ok) {</a>
<a name="ln318">            return rc;</a>
<a name="ln319">        }</a>
<a name="ln320"> </a>
<a name="ln321">        rc = cib-&gt;cmds-&gt;query(cib, NULL, &amp;current_cib, cib_scope_local | cib_sync_call);</a>
<a name="ln322">        if (rc == pcmk_ok) {</a>
<a name="ln323">            mon_refresh_display(NULL);</a>
<a name="ln324">        }</a>
<a name="ln325"> </a>
<a name="ln326">        if (rc == pcmk_ok &amp;&amp; full) {</a>
<a name="ln327">            if (rc == pcmk_ok) {</a>
<a name="ln328">                rc = cib-&gt;cmds-&gt;set_connection_dnotify(cib, mon_cib_connection_destroy);</a>
<a name="ln329">                if (rc == -EPROTONOSUPPORT) {</a>
<a name="ln330">                    print_as</a>
<a name="ln331">                        (&quot;Notification setup not supported, won't be able to reconnect after failure&quot;);</a>
<a name="ln332">                    if (output_format == mon_output_console) {</a>
<a name="ln333">                        sleep(2);</a>
<a name="ln334">                    }</a>
<a name="ln335">                    rc = pcmk_ok;</a>
<a name="ln336">                }</a>
<a name="ln337"> </a>
<a name="ln338">            }</a>
<a name="ln339"> </a>
<a name="ln340">            if (rc == pcmk_ok) {</a>
<a name="ln341">                cib-&gt;cmds-&gt;del_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);</a>
<a name="ln342">                rc = cib-&gt;cmds-&gt;add_notify_callback(cib, T_CIB_DIFF_NOTIFY, crm_diff_update);</a>
<a name="ln343">            }</a>
<a name="ln344"> </a>
<a name="ln345">            if (rc != pcmk_ok) {</a>
<a name="ln346">                print_as(&quot;Notification setup failed, could not monitor CIB actions&quot;);</a>
<a name="ln347">                if (output_format == mon_output_console) {</a>
<a name="ln348">                    sleep(2);</a>
<a name="ln349">                }</a>
<a name="ln350">                clean_up(-rc);</a>
<a name="ln351">            }</a>
<a name="ln352">        }</a>
<a name="ln353">    }</a>
<a name="ln354">    return rc;</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">/* *INDENT-OFF* */</a>
<a name="ln358">static struct crm_option long_options[] = {</a>
<a name="ln359">    /* Top-level Options */</a>
<a name="ln360">    {&quot;help&quot;,           0, 0, '?', &quot;\tThis text&quot;},</a>
<a name="ln361">    {&quot;version&quot;,        0, 0, '$', &quot;\tVersion information&quot;  },</a>
<a name="ln362">    {&quot;verbose&quot;,        0, 0, 'V', &quot;\tIncrease debug output&quot;},</a>
<a name="ln363">    {&quot;quiet&quot;,          0, 0, 'Q', &quot;\tDisplay only essential output&quot; },</a>
<a name="ln364"> </a>
<a name="ln365">    {&quot;-spacer-&quot;,	1, 0, '-', &quot;\nModes:&quot;},</a>
<a name="ln366">    {&quot;as-html&quot;,        1, 0, 'h', &quot;\tWrite cluster status to the named html file&quot;},</a>
<a name="ln367">    {&quot;as-xml&quot;,         0, 0, 'X', &quot;\t\tWrite cluster status as xml to stdout. This will enable one-shot mode.&quot;},</a>
<a name="ln368">    {&quot;web-cgi&quot;,        0, 0, 'w', &quot;\t\tWeb mode with output suitable for cgi&quot;},</a>
<a name="ln369">    {&quot;simple-status&quot;,  0, 0, 's', &quot;\tDisplay the cluster status once as a simple one line output (suitable for nagios)&quot;},</a>
<a name="ln370">    {&quot;snmp-traps&quot;,     1, 0, 'S', &quot;\tSend SNMP traps to this station&quot;, !ENABLE_SNMP},</a>
<a name="ln371">    {&quot;snmp-community&quot;, 1, 0, 'C', &quot;Specify community for SNMP traps(default is NULL)&quot;, !ENABLE_SNMP},</a>
<a name="ln372">    {&quot;mail-to&quot;,        1, 0, 'T', &quot;\tSend Mail alerts to this user.  See also --mail-from, --mail-host, --mail-prefix&quot;, !ENABLE_ESMTP},</a>
<a name="ln373"> </a>
<a name="ln374">    {&quot;-spacer-&quot;,	1, 0, '-', &quot;\nDisplay Options:&quot;},</a>
<a name="ln375">    {&quot;group-by-node&quot;,  0, 0, 'n', &quot;\tGroup resources by node&quot;     },</a>
<a name="ln376">    {&quot;inactive&quot;,       0, 0, 'r', &quot;\t\tDisplay inactive resources&quot;  },</a>
<a name="ln377">    {&quot;failcounts&quot;,     0, 0, 'f', &quot;\tDisplay resource fail counts&quot;},</a>
<a name="ln378">    {&quot;operations&quot;,     0, 0, 'o', &quot;\tDisplay resource operation history&quot; },</a>
<a name="ln379">    {&quot;timing-details&quot;, 0, 0, 't', &quot;\tDisplay resource operation history with timing details&quot; },</a>
<a name="ln380">    {&quot;tickets&quot;,        0, 0, 'c', &quot;\t\tDisplay cluster tickets&quot;},</a>
<a name="ln381">    {&quot;watch-fencing&quot;,  0, 0, 'W', &quot;\tListen for fencing events. For use with --external-agent, --mail-to and/or --snmp-traps where supported&quot;},</a>
<a name="ln382">    {&quot;neg-locations&quot;,  2, 0, 'L', &quot;Display negative location constraints [optionally filtered by id prefix]&quot;},</a>
<a name="ln383">    {&quot;show-node-attributes&quot;, 0, 0, 'A', &quot;Display node attributes&quot; },</a>
<a name="ln384">    {&quot;hide-headers&quot;,   0, 0, 'D', &quot;\tHide all headers&quot; },</a>
<a name="ln385">    {&quot;show-detail&quot;,    0, 0, 'R', &quot;\tShow more details (node IDs, individual clone instances)&quot; },</a>
<a name="ln386">    {&quot;brief&quot;,          0, 0, 'b', &quot;\t\tBrief output&quot; },</a>
<a name="ln387">    {&quot;pending&quot;,        0, 0, 'j', &quot;\t\tDisplay pending state if 'record-pending' is enabled&quot;, pcmk_option_hidden},</a>
<a name="ln388"> </a>
<a name="ln389">    {&quot;-spacer-&quot;,	1, 0, '-', &quot;\nAdditional Options:&quot;},</a>
<a name="ln390">    {&quot;interval&quot;,       1, 0, 'i', &quot;\tUpdate frequency in seconds&quot; },</a>
<a name="ln391">    {&quot;one-shot&quot;,       0, 0, '1', &quot;\t\tDisplay the cluster status once on the console and exit&quot;},</a>
<a name="ln392">    {&quot;disable-ncurses&quot;,0, 0, 'N', &quot;\tDisable the use of ncurses&quot;, !CURSES_ENABLED},</a>
<a name="ln393">    {&quot;daemonize&quot;,      0, 0, 'd', &quot;\tRun in the background as a daemon&quot;},</a>
<a name="ln394">    {&quot;pid-file&quot;,       1, 0, 'p', &quot;\t(Advanced) Daemon pid file location&quot;},</a>
<a name="ln395">    {&quot;mail-from&quot;,      1, 0, 'F', &quot;\tMail alerts should come from the named user&quot;, !ENABLE_ESMTP},</a>
<a name="ln396">    {&quot;mail-host&quot;,      1, 0, 'H', &quot;\tMail alerts should be sent via the named host&quot;, !ENABLE_ESMTP},</a>
<a name="ln397">    {&quot;mail-prefix&quot;,    1, 0, 'P', &quot;Subjects for mail alerts should start with this string&quot;, !ENABLE_ESMTP},</a>
<a name="ln398">    {&quot;external-agent&quot;,    1, 0, 'E', &quot;A program to run when resource operations take place.&quot;},</a>
<a name="ln399">    {&quot;external-recipient&quot;,1, 0, 'e', &quot;A recipient for your program (assuming you want the program to send something to someone).&quot;},</a>
<a name="ln400"> </a>
<a name="ln401"> </a>
<a name="ln402">    {&quot;xml-file&quot;,       1, 0, 'x', NULL, pcmk_option_hidden},</a>
<a name="ln403"> </a>
<a name="ln404">    {&quot;-spacer-&quot;,	1, 0, '-', &quot;\nExamples:&quot;, pcmk_option_paragraph},</a>
<a name="ln405">    {&quot;-spacer-&quot;,	1, 0, '-', &quot;Display the cluster status on the console with updates as they occur:&quot;, pcmk_option_paragraph},</a>
<a name="ln406">    {&quot;-spacer-&quot;,	1, 0, '-', &quot; crm_mon&quot;, pcmk_option_example},</a>
<a name="ln407">    {&quot;-spacer-&quot;,	1, 0, '-', &quot;Display the cluster status on the console just once then exit:&quot;, pcmk_option_paragraph},</a>
<a name="ln408">    {&quot;-spacer-&quot;,	1, 0, '-', &quot; crm_mon -1&quot;, pcmk_option_example},</a>
<a name="ln409">    {&quot;-spacer-&quot;,	1, 0, '-', &quot;Display your cluster status, group resources by node, and include inactive resources in the list:&quot;, pcmk_option_paragraph},</a>
<a name="ln410">    {&quot;-spacer-&quot;,	1, 0, '-', &quot; crm_mon --group-by-node --inactive&quot;, pcmk_option_example},</a>
<a name="ln411">    {&quot;-spacer-&quot;,	1, 0, '-', &quot;Start crm_mon as a background daemon and have it write the cluster status to an HTML file:&quot;, pcmk_option_paragraph},</a>
<a name="ln412">    {&quot;-spacer-&quot;,	1, 0, '-', &quot; crm_mon --daemonize --as-html /path/to/docroot/filename.html&quot;, pcmk_option_example},</a>
<a name="ln413">    {&quot;-spacer-&quot;,	1, 0, '-', &quot;Start crm_mon and export the current cluster status as xml to stdout, then exit.:&quot;, pcmk_option_paragraph},</a>
<a name="ln414">    {&quot;-spacer-&quot;,	1, 0, '-', &quot; crm_mon --as-xml&quot;, pcmk_option_example},</a>
<a name="ln415">    {&quot;-spacer-&quot;,	1, 0, '-', &quot;Start crm_mon as a background daemon and have it send email alerts:&quot;, pcmk_option_paragraph|!ENABLE_ESMTP},</a>
<a name="ln416">    {&quot;-spacer-&quot;,	1, 0, '-', &quot; crm_mon --daemonize --mail-to user@example.com --mail-host mail.example.com&quot;, pcmk_option_example|!ENABLE_ESMTP},</a>
<a name="ln417">    {&quot;-spacer-&quot;,	1, 0, '-', &quot;Start crm_mon as a background daemon and have it send SNMP alerts:&quot;, pcmk_option_paragraph|!ENABLE_SNMP},</a>
<a name="ln418">    {&quot;-spacer-&quot;,	1, 0, '-', &quot; crm_mon --daemonize --snmp-traps snmptrapd.example.com&quot;, pcmk_option_example|!ENABLE_SNMP},</a>
<a name="ln419"> </a>
<a name="ln420">    {NULL, 0, 0, 0}</a>
<a name="ln421">};</a>
<a name="ln422">/* *INDENT-ON* */</a>
<a name="ln423"> </a>
<a name="ln424">#if CURSES_ENABLED</a>
<a name="ln425">static const char *</a>
<a name="ln426">get_option_desc(char c)</a>
<a name="ln427">{</a>
<a name="ln428">    int lpc;</a>
<a name="ln429"> </a>
<a name="ln430">    for (lpc = 0; long_options[lpc].name != NULL; lpc++) {</a>
<a name="ln431"> </a>
<a name="ln432">        if (long_options[lpc].name[0] == '-')</a>
<a name="ln433">            continue;</a>
<a name="ln434"> </a>
<a name="ln435">        if (long_options[lpc].val == c) {</a>
<a name="ln436">            const char * tab = NULL;</a>
<a name="ln437">            tab = strrchr(long_options[lpc].desc, '\t');</a>
<a name="ln438">            return tab ? ++tab : long_options[lpc].desc;</a>
<a name="ln439">        }</a>
<a name="ln440">    }</a>
<a name="ln441"> </a>
<a name="ln442">    return NULL;</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">#define print_option_help(option, condition) \</a>
<a name="ln446">    print_as(&quot;%c %c: \t%s\n&quot;, ((condition)? '*': ' '), option, get_option_desc(option));</a>
<a name="ln447"> </a>
<a name="ln448">static gboolean</a>
<a name="ln449">detect_user_input(GIOChannel *channel, GIOCondition condition, gpointer unused)</a>
<a name="ln450">{</a>
<a name="ln451">    int c;</a>
<a name="ln452">    gboolean config_mode = FALSE;</a>
<a name="ln453"> </a>
<a name="ln454">    while (1) {</a>
<a name="ln455"> </a>
<a name="ln456">        /* Get user input */</a>
<a name="ln457">        c = getchar();</a>
<a name="ln458"> </a>
<a name="ln459">        switch (c) {</a>
<a name="ln460">            case 'c':</a>
<a name="ln461">                show ^= mon_show_tickets;</a>
<a name="ln462">                break;</a>
<a name="ln463">            case 'f':</a>
<a name="ln464">                show ^= mon_show_failcounts;</a>
<a name="ln465">                break;</a>
<a name="ln466">            case 'n':</a>
<a name="ln467">                group_by_node = ! group_by_node;</a>
<a name="ln468">                break;</a>
<a name="ln469">            case 'o':</a>
<a name="ln470">                show ^= mon_show_operations;</a>
<a name="ln471">                if ((show &amp; mon_show_operations) == 0) {</a>
<a name="ln472">                    print_timing = 0;</a>
<a name="ln473">                }</a>
<a name="ln474">                break;</a>
<a name="ln475">            case 'r':</a>
<a name="ln476">                inactive_resources = ! inactive_resources;</a>
<a name="ln477">                break;</a>
<a name="ln478">            case 'R':</a>
<a name="ln479">                print_clone_detail = ! print_clone_detail;</a>
<a name="ln480">                break;</a>
<a name="ln481">            case 't':</a>
<a name="ln482">                print_timing = ! print_timing;</a>
<a name="ln483">                if (print_timing) {</a>
<a name="ln484">                    show |= mon_show_operations;</a>
<a name="ln485">                }</a>
<a name="ln486">                break;</a>
<a name="ln487">            case 'A':</a>
<a name="ln488">                show ^= mon_show_attributes;</a>
<a name="ln489">                break;</a>
<a name="ln490">            case 'L':</a>
<a name="ln491">                show ^= mon_show_bans;</a>
<a name="ln492">                break;</a>
<a name="ln493">            case 'D':</a>
<a name="ln494">                /* If any header is shown, clear them all, otherwise set them all */</a>
<a name="ln495">                if (show &amp; mon_show_headers) {</a>
<a name="ln496">                    show &amp;= ~mon_show_headers;</a>
<a name="ln497">                } else {</a>
<a name="ln498">                    show |= mon_show_headers;</a>
<a name="ln499">                }</a>
<a name="ln500">                break;</a>
<a name="ln501">            case 'b':</a>
<a name="ln502">                print_brief = ! print_brief;</a>
<a name="ln503">                break;</a>
<a name="ln504">            case 'j':</a>
<a name="ln505">                print_pending = ! print_pending;</a>
<a name="ln506">                break;</a>
<a name="ln507">            case '?':</a>
<a name="ln508">                config_mode = TRUE;</a>
<a name="ln509">                break;</a>
<a name="ln510">            default:</a>
<a name="ln511">                goto refresh;</a>
<a name="ln512">        }</a>
<a name="ln513"> </a>
<a name="ln514">        if (!config_mode)</a>
<a name="ln515">            goto refresh;</a>
<a name="ln516"> </a>
<a name="ln517">        blank_screen();</a>
<a name="ln518"> </a>
<a name="ln519">        print_as(&quot;Display option change mode\n&quot;);</a>
<a name="ln520">        print_as(&quot;\n&quot;);</a>
<a name="ln521">        print_option_help('c', show &amp; mon_show_tickets);</a>
<a name="ln522">        print_option_help('f', show &amp; mon_show_failcounts);</a>
<a name="ln523">        print_option_help('n', group_by_node);</a>
<a name="ln524">        print_option_help('o', show &amp; mon_show_operations);</a>
<a name="ln525">        print_option_help('r', inactive_resources);</a>
<a name="ln526">        print_option_help('t', print_timing);</a>
<a name="ln527">        print_option_help('A', show &amp; mon_show_attributes);</a>
<a name="ln528">        print_option_help('L', show &amp; mon_show_bans);</a>
<a name="ln529">        print_option_help('D', (show &amp; mon_show_headers) == 0);</a>
<a name="ln530">        print_option_help('R', print_clone_detail);</a>
<a name="ln531">        print_option_help('b', print_brief);</a>
<a name="ln532">        print_option_help('j', print_pending);</a>
<a name="ln533">        print_as(&quot;\n&quot;);</a>
<a name="ln534">        print_as(&quot;Toggle fields via field letter, type any other key to return&quot;);</a>
<a name="ln535">    }</a>
<a name="ln536"> </a>
<a name="ln537">refresh:</a>
<a name="ln538">    mon_refresh_display(NULL);</a>
<a name="ln539">    return TRUE;</a>
<a name="ln540">}</a>
<a name="ln541">#endif</a>
<a name="ln542"> </a>
<a name="ln543">int</a>
<a name="ln544">main(int argc, char **argv)</a>
<a name="ln545">{</a>
<a name="ln546">    int flag;</a>
<a name="ln547">    int argerr = 0;</a>
<a name="ln548">    int exit_code = 0;</a>
<a name="ln549">    int option_index = 0;</a>
<a name="ln550"> </a>
<a name="ln551">    pid_file = strdup(&quot;/tmp/ClusterMon.pid&quot;);</a>
<a name="ln552">    crm_log_cli_init(&quot;crm_mon&quot;);</a>
<a name="ln553">    crm_set_options(NULL, &quot;mode [options]&quot;, long_options,</a>
<a name="ln554">                    &quot;Provides a summary of cluster's current state.&quot;</a>
<a name="ln555">                    &quot;\n\nOutputs varying levels of detail in a number of different formats.\n&quot;);</a>
<a name="ln556"> </a>
<a name="ln557">#if !defined (ON_DARWIN) &amp;&amp; !defined (ON_BSD)</a>
<a name="ln558">    /* prevent zombies */</a>
<a name="ln559">    signal(SIGCLD, SIG_IGN);</a>
<a name="ln560">#endif</a>
<a name="ln561"> </a>
<a name="ln562">    if (strcmp(crm_system_name, &quot;crm_mon.cgi&quot;) == 0) {</a>
<a name="ln563">        output_format = mon_output_cgi;</a>
<a name="ln564">        one_shot = TRUE;</a>
<a name="ln565">    }</a>
<a name="ln566"> </a>
<a name="ln567">    while (1) {</a>
<a name="ln568">        flag = crm_get_option(argc, argv, &amp;option_index);</a>
<a name="ln569">        if (flag == -1)</a>
<a name="ln570">            break;</a>
<a name="ln571"> </a>
<a name="ln572">        switch (flag) {</a>
<a name="ln573">            case 'V':</a>
<a name="ln574">                crm_bump_log_level(argc, argv);</a>
<a name="ln575">                break;</a>
<a name="ln576">            case 'Q':</a>
<a name="ln577">                show &amp;= ~mon_show_times;</a>
<a name="ln578">                break;</a>
<a name="ln579">            case 'i':</a>
<a name="ln580">                reconnect_msec = crm_get_msec(optarg);</a>
<a name="ln581">                break;</a>
<a name="ln582">            case 'n':</a>
<a name="ln583">                group_by_node = TRUE;</a>
<a name="ln584">                break;</a>
<a name="ln585">            case 'r':</a>
<a name="ln586">                inactive_resources = TRUE;</a>
<a name="ln587">                break;</a>
<a name="ln588">            case 'W':</a>
<a name="ln589">                watch_fencing = TRUE;</a>
<a name="ln590">                break;</a>
<a name="ln591">            case 'd':</a>
<a name="ln592">                daemonize = TRUE;</a>
<a name="ln593">                break;</a>
<a name="ln594">            case 't':</a>
<a name="ln595">                print_timing = TRUE;</a>
<a name="ln596">                show |= mon_show_operations;</a>
<a name="ln597">                break;</a>
<a name="ln598">            case 'o':</a>
<a name="ln599">                show |= mon_show_operations;</a>
<a name="ln600">                break;</a>
<a name="ln601">            case 'f':</a>
<a name="ln602">                show |= mon_show_failcounts;</a>
<a name="ln603">                break;</a>
<a name="ln604">            case 'A':</a>
<a name="ln605">                show |= mon_show_attributes;</a>
<a name="ln606">                break;</a>
<a name="ln607">            case 'L':</a>
<a name="ln608">                show |= mon_show_bans;</a>
<a name="ln609">                print_neg_location_prefix = optarg? optarg : &quot;&quot;;</a>
<a name="ln610">                break;</a>
<a name="ln611">            case 'D':</a>
<a name="ln612">                show &amp;= ~mon_show_headers;</a>
<a name="ln613">                break;</a>
<a name="ln614">            case 'b':</a>
<a name="ln615">                print_brief = TRUE;</a>
<a name="ln616">                break;</a>
<a name="ln617">            case 'j':</a>
<a name="ln618">                print_pending = TRUE;</a>
<a name="ln619">                break;</a>
<a name="ln620">            case 'R':</a>
<a name="ln621">                print_clone_detail = TRUE;</a>
<a name="ln622">                break;</a>
<a name="ln623">            case 'c':</a>
<a name="ln624">                show |= mon_show_tickets;</a>
<a name="ln625">                break;</a>
<a name="ln626">            case 'p':</a>
<a name="ln627">                free(pid_file);</a>
<a name="ln628">                if(optarg == NULL) {</a>
<a name="ln629">                    return crm_help(flag, EX_USAGE);</a>
<a name="ln630">                }</a>
<a name="ln631">                pid_file = strdup(optarg);</a>
<a name="ln632">                break;</a>
<a name="ln633">            case 'x':</a>
<a name="ln634">                if(optarg == NULL) {</a>
<a name="ln635">                    return crm_help(flag, EX_USAGE);</a>
<a name="ln636">                }</a>
<a name="ln637">                xml_file = strdup(optarg);</a>
<a name="ln638">                one_shot = TRUE;</a>
<a name="ln639">                break;</a>
<a name="ln640">            case 'h':</a>
<a name="ln641">                if(optarg == NULL) {</a>
<a name="ln642">                    return crm_help(flag, EX_USAGE);</a>
<a name="ln643">                }</a>
<a name="ln644">                output_format = mon_output_html;</a>
<a name="ln645">                output_filename = strdup(optarg);</a>
<a name="ln646">                umask(S_IWGRP | S_IWOTH);</a>
<a name="ln647">                break;</a>
<a name="ln648">            case 'X':</a>
<a name="ln649">                output_format = mon_output_xml;</a>
<a name="ln650">                one_shot = TRUE;</a>
<a name="ln651">                break;</a>
<a name="ln652">            case 'w':</a>
<a name="ln653">                output_format = mon_output_cgi;</a>
<a name="ln654">                one_shot = TRUE;</a>
<a name="ln655">                break;</a>
<a name="ln656">            case 's':</a>
<a name="ln657">                output_format = mon_output_monitor;</a>
<a name="ln658">                one_shot = TRUE;</a>
<a name="ln659">                break;</a>
<a name="ln660">            case 'S':</a>
<a name="ln661">                snmp_target = optarg;</a>
<a name="ln662">                break;</a>
<a name="ln663">            case 'T':</a>
<a name="ln664">                crm_mail_to = optarg;</a>
<a name="ln665">                break;</a>
<a name="ln666">            case 'F':</a>
<a name="ln667">                crm_mail_from = optarg;</a>
<a name="ln668">                break;</a>
<a name="ln669">            case 'H':</a>
<a name="ln670">                crm_mail_host = optarg;</a>
<a name="ln671">                break;</a>
<a name="ln672">            case 'P':</a>
<a name="ln673">                crm_mail_prefix = optarg;</a>
<a name="ln674">                break;</a>
<a name="ln675">            case 'E':</a>
<a name="ln676">                external_agent = optarg;</a>
<a name="ln677">                break;</a>
<a name="ln678">            case 'e':</a>
<a name="ln679">                external_recipient = optarg;</a>
<a name="ln680">                break;</a>
<a name="ln681">            case '1':</a>
<a name="ln682">                one_shot = TRUE;</a>
<a name="ln683">                break;</a>
<a name="ln684">            case 'N':</a>
<a name="ln685">                if (output_format == mon_output_console) {</a>
<a name="ln686">                    output_format = mon_output_plain;</a>
<a name="ln687">                }</a>
<a name="ln688">                break;</a>
<a name="ln689">            case 'C':</a>
<a name="ln690">                snmp_community = optarg;</a>
<a name="ln691">                break;</a>
<a name="ln692">            case '$':</a>
<a name="ln693">            case '?':</a>
<a name="ln694">                return crm_help(flag, EX_OK);</a>
<a name="ln695">                break;</a>
<a name="ln696">            default:</a>
<a name="ln697">                printf(&quot;Argument code 0%o (%c) is not (?yet?) supported\n&quot;, flag, flag);</a>
<a name="ln698">                ++argerr;</a>
<a name="ln699">                break;</a>
<a name="ln700">        }</a>
<a name="ln701">    }</a>
<a name="ln702"> </a>
<a name="ln703">    if (optind &lt; argc) {</a>
<a name="ln704">        printf(&quot;non-option ARGV-elements: &quot;);</a>
<a name="ln705">        while (optind &lt; argc)</a>
<a name="ln706">            printf(&quot;%s &quot;, argv[optind++]);</a>
<a name="ln707">        printf(&quot;\n&quot;);</a>
<a name="ln708">    }</a>
<a name="ln709">    if (argerr) {</a>
<a name="ln710">        return crm_help('?', EX_USAGE);</a>
<a name="ln711">    }</a>
<a name="ln712"> </a>
<a name="ln713">    /* XML output always prints everything */</a>
<a name="ln714">    if (output_format == mon_output_xml) {</a>
<a name="ln715">        show = mon_show_all;</a>
<a name="ln716">        print_timing = TRUE;</a>
<a name="ln717">    }</a>
<a name="ln718"> </a>
<a name="ln719">    if (one_shot) {</a>
<a name="ln720">        if (output_format == mon_output_console) {</a>
<a name="ln721">            output_format = mon_output_plain;</a>
<a name="ln722">        }</a>
<a name="ln723"> </a>
<a name="ln724">    } else if (daemonize) {</a>
<a name="ln725">        if ((output_format == mon_output_console) || (output_format == mon_output_plain)) {</a>
<a name="ln726">            output_format = mon_output_none;</a>
<a name="ln727">        }</a>
<a name="ln728">        crm_enable_stderr(FALSE);</a>
<a name="ln729"> </a>
<a name="ln730">        if ((output_format != mon_output_html) &amp;&amp; (output_format != mon_output_xml)</a>
<a name="ln731">            &amp;&amp; !snmp_target &amp;&amp; !crm_mail_to &amp;&amp; !external_agent) {</a>
<a name="ln732">            printf</a>
<a name="ln733">                (&quot;Looks like you forgot to specify one or more of: --as-html, --as-xml, --mail-to, --snmp-target, --external-agent\n&quot;);</a>
<a name="ln734">            return crm_help('?', EX_USAGE);</a>
<a name="ln735">        }</a>
<a name="ln736"> </a>
<a name="ln737">        crm_make_daemon(crm_system_name, TRUE, pid_file);</a>
<a name="ln738"> </a>
<a name="ln739">    } else if (output_format == mon_output_console) {</a>
<a name="ln740">#if CURSES_ENABLED</a>
<a name="ln741">        initscr();</a>
<a name="ln742">        cbreak();</a>
<a name="ln743">        noecho();</a>
<a name="ln744">        crm_enable_stderr(FALSE);</a>
<a name="ln745">#else</a>
<a name="ln746">        one_shot = TRUE;</a>
<a name="ln747">        output_format = mon_output_plain;</a>
<a name="ln748">        printf(&quot;Defaulting to one-shot mode\n&quot;);</a>
<a name="ln749">        printf(&quot;You need to have curses available at compile time to enable console mode\n&quot;);</a>
<a name="ln750">#endif</a>
<a name="ln751">    }</a>
<a name="ln752"> </a>
<a name="ln753">    crm_info(&quot;Starting %s&quot;, crm_system_name);</a>
<a name="ln754">    if (xml_file != NULL) {</a>
<a name="ln755">        current_cib = filename2xml(xml_file);</a>
<a name="ln756">        mon_refresh_display(NULL);</a>
<a name="ln757">        return exit_code;</a>
<a name="ln758">    }</a>
<a name="ln759"> </a>
<a name="ln760">    if (current_cib == NULL) {</a>
<a name="ln761">        cib = cib_new();</a>
<a name="ln762"> </a>
<a name="ln763">        do {</a>
<a name="ln764">            if (!one_shot) {</a>
<a name="ln765">                print_as(&quot;Attempting connection to the cluster...\n&quot;);</a>
<a name="ln766">            }</a>
<a name="ln767">            exit_code = cib_connect(!one_shot);</a>
<a name="ln768"> </a>
<a name="ln769">            if (one_shot) {</a>
<a name="ln770">                break;</a>
<a name="ln771"> </a>
<a name="ln772">            } else if (exit_code != pcmk_ok) {</a>
<a name="ln773">                sleep(reconnect_msec / 1000);</a>
<a name="ln774">#if CURSES_ENABLED</a>
<a name="ln775">                if (output_format == mon_output_console) {</a>
<a name="ln776">                    clear();</a>
<a name="ln777">                    refresh();</a>
<a name="ln778">                }</a>
<a name="ln779">#endif</a>
<a name="ln780">            }</a>
<a name="ln781"> </a>
<a name="ln782">        } while (exit_code == -ENOTCONN);</a>
<a name="ln783"> </a>
<a name="ln784">        if (exit_code != pcmk_ok) {</a>
<a name="ln785">            if (output_format == mon_output_monitor) {</a>
<a name="ln786">                printf(&quot;CLUSTER WARN: Connection to cluster failed: %s\n&quot;, pcmk_strerror(exit_code));</a>
<a name="ln787">                clean_up(MON_STATUS_WARN);</a>
<a name="ln788">            } else {</a>
<a name="ln789">                print_as(&quot;\nConnection to cluster failed: %s\n&quot;, pcmk_strerror(exit_code));</a>
<a name="ln790">            }</a>
<a name="ln791">            if (output_format == mon_output_console) {</a>
<a name="ln792">                sleep(2);</a>
<a name="ln793">            }</a>
<a name="ln794">            clean_up(-exit_code);</a>
<a name="ln795">        }</a>
<a name="ln796">    }</a>
<a name="ln797"> </a>
<a name="ln798">    if (one_shot) {</a>
<a name="ln799">        return exit_code;</a>
<a name="ln800">    }</a>
<a name="ln801"> </a>
<a name="ln802">    mainloop = g_main_new(FALSE);</a>
<a name="ln803"> </a>
<a name="ln804">    mainloop_add_signal(SIGTERM, mon_shutdown);</a>
<a name="ln805">    mainloop_add_signal(SIGINT, mon_shutdown);</a>
<a name="ln806">#if CURSES_ENABLED</a>
<a name="ln807">    if (output_format == mon_output_console) {</a>
<a name="ln808">        ncurses_winch_handler = signal(SIGWINCH, mon_winresize);</a>
<a name="ln809">        if (ncurses_winch_handler == SIG_DFL ||</a>
<a name="ln810">            ncurses_winch_handler == SIG_IGN || ncurses_winch_handler == SIG_ERR)</a>
<a name="ln811">            ncurses_winch_handler = NULL;</a>
<a name="ln812">        g_io_add_watch(g_io_channel_unix_new(STDIN_FILENO), G_IO_IN, detect_user_input, NULL);</a>
<a name="ln813">    }</a>
<a name="ln814">#endif</a>
<a name="ln815">    refresh_trigger = mainloop_add_trigger(G_PRIORITY_LOW, mon_refresh_display, NULL);</a>
<a name="ln816"> </a>
<a name="ln817">    g_main_run(mainloop);</a>
<a name="ln818">    g_main_destroy(mainloop);</a>
<a name="ln819"> </a>
<a name="ln820">    crm_info(&quot;Exiting %s&quot;, crm_system_name);</a>
<a name="ln821"> </a>
<a name="ln822">    clean_up(0);</a>
<a name="ln823">    return 0;                   /* never reached */</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">#define mon_warn(fmt...) do {			\</a>
<a name="ln827">	if (!has_warnings) {			\</a>
<a name="ln828">	    print_as(&quot;CLUSTER WARN:&quot;);		\</a>
<a name="ln829">	} else {				\</a>
<a name="ln830">	    print_as(&quot;,&quot;);			\</a>
<a name="ln831">	}					\</a>
<a name="ln832">	print_as(fmt);				\</a>
<a name="ln833">	has_warnings = TRUE;			\</a>
<a name="ln834">    } while(0)</a>
<a name="ln835"> </a>
<a name="ln836">static int</a>
<a name="ln837">count_resources(pe_working_set_t * data_set, resource_t * rsc)</a>
<a name="ln838">{</a>
<a name="ln839">    int count = 0;</a>
<a name="ln840">    GListPtr gIter = NULL;</a>
<a name="ln841"> </a>
<a name="ln842">    if (rsc == NULL) {</a>
<a name="ln843">        gIter = data_set-&gt;resources;</a>
<a name="ln844">    } else if (rsc-&gt;children) {</a>
<a name="ln845">        gIter = rsc-&gt;children;</a>
<a name="ln846">    } else {</a>
<a name="ln847">        return is_not_set(rsc-&gt;flags, pe_rsc_orphan);</a>
<a name="ln848">    }</a>
<a name="ln849"> </a>
<a name="ln850">    for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln851">        count += count_resources(data_set, gIter-&gt;data);</a>
<a name="ln852">    }</a>
<a name="ln853">    return count;</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">/*!</a>
<a name="ln857"> * \internal</a>
<a name="ln858"> * \brief Print one-line status suitable for use with monitoring software</a>
<a name="ln859"> *</a>
<a name="ln860"> * \param[in] data_set  Working set of CIB state</a>
<a name="ln861"> *</a>
<a name="ln862"> * \note This function's output (and the return code when the program exits)</a>
<a name="ln863"> *       should conform to https://www.monitoring-plugins.org/doc/guidelines.html</a>
<a name="ln864"> */</a>
<a name="ln865">static void</a>
<a name="ln866">print_simple_status(pe_working_set_t * data_set)</a>
<a name="ln867">{</a>
<a name="ln868">    GListPtr gIter = NULL;</a>
<a name="ln869">    int nodes_online = 0;</a>
<a name="ln870">    int nodes_standby = 0;</a>
<a name="ln871">    int nodes_maintenance = 0;</a>
<a name="ln872"> </a>
<a name="ln873">    if (data_set-&gt;dc_node == NULL) {</a>
<a name="ln874">        mon_warn(&quot; No DC&quot;);</a>
<a name="ln875">    }</a>
<a name="ln876"> </a>
<a name="ln877">    for (gIter = data_set-&gt;nodes; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln878">        node_t *node = (node_t *) gIter-&gt;data;</a>
<a name="ln879"> </a>
<a name="ln880">        if (node-&gt;details-&gt;standby &amp;&amp; node-&gt;details-&gt;online) {</a>
<a name="ln881">            nodes_standby++;</a>
<a name="ln882">        } else if (node-&gt;details-&gt;maintenance &amp;&amp; node-&gt;details-&gt;online) {</a>
<a name="ln883">            nodes_maintenance++;</a>
<a name="ln884">        } else if (node-&gt;details-&gt;online) {</a>
<a name="ln885">            nodes_online++;</a>
<a name="ln886">        } else {</a>
<a name="ln887">            mon_warn(&quot; offline node: %s&quot;, node-&gt;details-&gt;uname);</a>
<a name="ln888">        }</a>
<a name="ln889">    }</a>
<a name="ln890"> </a>
<a name="ln891">    if (!has_warnings) {</a>
<a name="ln892">        int nresources = count_resources(data_set, NULL);</a>
<a name="ln893"> </a>
<a name="ln894">        print_as(&quot;CLUSTER OK: %d node%s online&quot;, nodes_online, s_if_plural(nodes_online));</a>
<a name="ln895">        if (nodes_standby &gt; 0) {</a>
<a name="ln896">            print_as(&quot;, %d standby node%s&quot;, nodes_standby, s_if_plural(nodes_standby));</a>
<a name="ln897">        }</a>
<a name="ln898">        if (nodes_maintenance &gt; 0) {</a>
<a name="ln899">            print_as(&quot;, %d maintenance node%s&quot;, nodes_maintenance, s_if_plural(nodes_maintenance));</a>
<a name="ln900">        }</a>
<a name="ln901">        print_as(&quot;, %d resource%s configured&quot;, nresources, s_if_plural(nresources));</a>
<a name="ln902">    }</a>
<a name="ln903"> </a>
<a name="ln904">    print_as(&quot;\n&quot;);</a>
<a name="ln905">}</a>
<a name="ln906"> </a>
<a name="ln907">/*!</a>
<a name="ln908"> * \internal</a>
<a name="ln909"> * \brief Print a [name]=[value][units] pair, optionally using time string</a>
<a name="ln910"> *</a>
<a name="ln911"> * \param[in] stream      File stream to display output to</a>
<a name="ln912"> * \param[in] name        Name to display</a>
<a name="ln913"> * \param[in] value       Value to display (or NULL to convert time instead)</a>
<a name="ln914"> * \param[in] units       Units to display (or NULL for no units)</a>
<a name="ln915"> * \param[in] epoch_time  Epoch time to convert if value is NULL</a>
<a name="ln916"> */</a>
<a name="ln917">static void</a>
<a name="ln918">print_nvpair(FILE *stream, const char *name, const char *value,</a>
<a name="ln919">             const char *units, time_t epoch_time)</a>
<a name="ln920">{</a>
<a name="ln921">    /* print name= */</a>
<a name="ln922">    switch (output_format) {</a>
<a name="ln923">        case mon_output_plain:</a>
<a name="ln924">        case mon_output_console:</a>
<a name="ln925">            print_as(&quot; %s=&quot;, name);</a>
<a name="ln926">            break;</a>
<a name="ln927"> </a>
<a name="ln928">        case mon_output_html:</a>
<a name="ln929">        case mon_output_cgi:</a>
<a name="ln930">        case mon_output_xml:</a>
<a name="ln931">            fprintf(stream, &quot; %s=&quot;, name);</a>
<a name="ln932">            break;</a>
<a name="ln933"> </a>
<a name="ln934">        default:</a>
<a name="ln935">            break;</a>
<a name="ln936">    }</a>
<a name="ln937"> </a>
<a name="ln938">    /* If we have a value (and optionally units), print it */</a>
<a name="ln939">    if (value) {</a>
<a name="ln940">        switch (output_format) {</a>
<a name="ln941">            case mon_output_plain:</a>
<a name="ln942">            case mon_output_console:</a>
<a name="ln943">                print_as(&quot;%s%s&quot;, value, (units? units : &quot;&quot;));</a>
<a name="ln944">                break;</a>
<a name="ln945"> </a>
<a name="ln946">            case mon_output_html:</a>
<a name="ln947">            case mon_output_cgi:</a>
<a name="ln948">                fprintf(stream, &quot;%s%s&quot;, value, (units? units : &quot;&quot;));</a>
<a name="ln949">                break;</a>
<a name="ln950"> </a>
<a name="ln951">            case mon_output_xml:</a>
<a name="ln952">                fprintf(stream, &quot;\&quot;%s%s\&quot;&quot;, value, (units? units : &quot;&quot;));</a>
<a name="ln953">                break;</a>
<a name="ln954"> </a>
<a name="ln955">            default:</a>
<a name="ln956">                break;</a>
<a name="ln957">        }</a>
<a name="ln958"> </a>
<a name="ln959">    /* Otherwise print user-friendly time string */</a>
<a name="ln960">    } else {</a>
<a name="ln961">        static char empty_str[] = &quot;&quot;;</a>
<a name="ln962">        char *c, *date_str = asctime(localtime(&amp;epoch_time));</a>
<a name="ln963"> </a>
<a name="ln964">        for (c = (date_str != NULL) ? date_str : empty_str; *c != '\0'; ++c) {</a>
<a name="ln965">            if (*c == '\n') {</a>
<a name="ln966">                *c = '\0';</a>
<a name="ln967">                break;</a>
<a name="ln968">            }</a>
<a name="ln969">        }</a>
<a name="ln970">        switch (output_format) {</a>
<a name="ln971">            case mon_output_plain:</a>
<a name="ln972">            case mon_output_console:</a>
<a name="ln973">                print_as(&quot;'%s'&quot;, date_str);</a>
<a name="ln974">                break;</a>
<a name="ln975"> </a>
<a name="ln976">            case mon_output_html:</a>
<a name="ln977">            case mon_output_cgi:</a>
<a name="ln978">            case mon_output_xml:</a>
<a name="ln979">                fprintf(stream, &quot;\&quot;%s\&quot;&quot;, date_str);</a>
<a name="ln980">                break;</a>
<a name="ln981"> </a>
<a name="ln982">            default:</a>
<a name="ln983">                break;</a>
<a name="ln984">        }</a>
<a name="ln985">    }</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">/*!</a>
<a name="ln989"> * \internal</a>
<a name="ln990"> * \brief Print whatever is needed to start a node section</a>
<a name="ln991"> *</a>
<a name="ln992"> * \param[in] stream     File stream to display output to</a>
<a name="ln993"> * \param[in] node       Node to print</a>
<a name="ln994"> */</a>
<a name="ln995">static void</a>
<a name="ln996">print_node_start(FILE *stream, node_t *node)</a>
<a name="ln997">{</a>
<a name="ln998">    char *node_name;</a>
<a name="ln999"> </a>
<a name="ln1000">    switch (output_format) {</a>
<a name="ln1001">        case mon_output_plain:</a>
<a name="ln1002">        case mon_output_console:</a>
<a name="ln1003">            node_name = get_node_display_name(node);</a>
<a name="ln1004">            print_as(&quot;* Node %s:\n&quot;, node_name);</a>
<a name="ln1005">            free(node_name);</a>
<a name="ln1006">            break;</a>
<a name="ln1007"> </a>
<a name="ln1008">        case mon_output_html:</a>
<a name="ln1009">        case mon_output_cgi:</a>
<a name="ln1010">            node_name = get_node_display_name(node);</a>
<a name="ln1011">            fprintf(stream, &quot;  &lt;h3&gt;Node: %s&lt;/h3&gt;\n  &lt;ul&gt;\n&quot;, node_name);</a>
<a name="ln1012">            free(node_name);</a>
<a name="ln1013">            break;</a>
<a name="ln1014"> </a>
<a name="ln1015">        case mon_output_xml:</a>
<a name="ln1016">            fprintf(stream, &quot;        &lt;node name=\&quot;%s\&quot;&gt;\n&quot;, node-&gt;details-&gt;uname);</a>
<a name="ln1017">            break;</a>
<a name="ln1018"> </a>
<a name="ln1019">        default:</a>
<a name="ln1020">            break;</a>
<a name="ln1021">    }</a>
<a name="ln1022">}</a>
<a name="ln1023"> </a>
<a name="ln1024">/*!</a>
<a name="ln1025"> * \internal</a>
<a name="ln1026"> * \brief Print whatever is needed to end a node section</a>
<a name="ln1027"> *</a>
<a name="ln1028"> * \param[in] stream     File stream to display output to</a>
<a name="ln1029"> */</a>
<a name="ln1030">static void</a>
<a name="ln1031">print_node_end(FILE *stream)</a>
<a name="ln1032">{</a>
<a name="ln1033">    switch (output_format) {</a>
<a name="ln1034">        case mon_output_html:</a>
<a name="ln1035">        case mon_output_cgi:</a>
<a name="ln1036">            fprintf(stream, &quot;  &lt;/ul&gt;\n&quot;);</a>
<a name="ln1037">            break;</a>
<a name="ln1038"> </a>
<a name="ln1039">        case mon_output_xml:</a>
<a name="ln1040">            fprintf(stream, &quot;        &lt;/node&gt;\n&quot;);</a>
<a name="ln1041">            break;</a>
<a name="ln1042"> </a>
<a name="ln1043">        default:</a>
<a name="ln1044">            break;</a>
<a name="ln1045">    }</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048">/*!</a>
<a name="ln1049"> * \internal</a>
<a name="ln1050"> * \brief Print resources section heading appropriate to options</a>
<a name="ln1051"> *</a>
<a name="ln1052"> * \param[in] stream      File stream to display output to</a>
<a name="ln1053"> */</a>
<a name="ln1054">static void</a>
<a name="ln1055">print_resources_heading(FILE *stream)</a>
<a name="ln1056">{</a>
<a name="ln1057">    const char *heading;</a>
<a name="ln1058"> </a>
<a name="ln1059">    if (group_by_node) {</a>
<a name="ln1060"> </a>
<a name="ln1061">        /* Active resources have already been printed by node */</a>
<a name="ln1062">        heading = (inactive_resources? &quot;Inactive resources&quot; : NULL);</a>
<a name="ln1063"> </a>
<a name="ln1064">    } else if (inactive_resources) {</a>
<a name="ln1065">        heading = &quot;Full list of resources&quot;;</a>
<a name="ln1066"> </a>
<a name="ln1067">    } else {</a>
<a name="ln1068">        heading = &quot;Active resources&quot;;</a>
<a name="ln1069">    }</a>
<a name="ln1070"> </a>
<a name="ln1071">    /* Print section heading */</a>
<a name="ln1072">    switch (output_format) {</a>
<a name="ln1073">        case mon_output_plain:</a>
<a name="ln1074">        case mon_output_console:</a>
<a name="ln1075">            print_as(&quot;\n%s:\n\n&quot;, heading);</a>
<a name="ln1076">            break;</a>
<a name="ln1077"> </a>
<a name="ln1078">        case mon_output_html:</a>
<a name="ln1079">        case mon_output_cgi:</a>
<a name="ln1080">            fprintf(stream, &quot; &lt;hr /&gt;\n &lt;h2&gt;%s&lt;/h2&gt;\n&quot;, heading);</a>
<a name="ln1081">            break;</a>
<a name="ln1082"> </a>
<a name="ln1083">        case mon_output_xml:</a>
<a name="ln1084">            fprintf(stream, &quot;    &lt;resources&gt;\n&quot;);</a>
<a name="ln1085">            break;</a>
<a name="ln1086"> </a>
<a name="ln1087">        default:</a>
<a name="ln1088">            break;</a>
<a name="ln1089">    }</a>
<a name="ln1090"> </a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093">/*!</a>
<a name="ln1094"> * \internal</a>
<a name="ln1095"> * \brief Print whatever resource section closing is appropriate</a>
<a name="ln1096"> *</a>
<a name="ln1097"> * \param[in] stream     File stream to display output to</a>
<a name="ln1098"> */</a>
<a name="ln1099">static void</a>
<a name="ln1100">print_resources_closing(FILE *stream, gboolean printed_heading)</a>
<a name="ln1101">{</a>
<a name="ln1102">    const char *heading;</a>
<a name="ln1103"> </a>
<a name="ln1104">    /* What type of resources we did or did not display */</a>
<a name="ln1105">    if (group_by_node) {</a>
<a name="ln1106">        heading = &quot;inactive &quot;;</a>
<a name="ln1107">    } else if (inactive_resources) {</a>
<a name="ln1108">        heading = &quot;&quot;;</a>
<a name="ln1109">    } else {</a>
<a name="ln1110">        heading = &quot;active &quot;;</a>
<a name="ln1111">    }</a>
<a name="ln1112"> </a>
<a name="ln1113">    switch (output_format) {</a>
<a name="ln1114">        case mon_output_plain:</a>
<a name="ln1115">        case mon_output_console:</a>
<a name="ln1116">            if (!printed_heading) {</a>
<a name="ln1117">                print_as(&quot;\nNo %sresources\n\n&quot;, heading);</a>
<a name="ln1118">            }</a>
<a name="ln1119">            break;</a>
<a name="ln1120"> </a>
<a name="ln1121">        case mon_output_html:</a>
<a name="ln1122">        case mon_output_cgi:</a>
<a name="ln1123">            if (!printed_heading) {</a>
<a name="ln1124">                fprintf(stream, &quot; &lt;hr /&gt;\n &lt;h2&gt;No %sresources&lt;/h2&gt;\n&quot;, heading);</a>
<a name="ln1125">            }</a>
<a name="ln1126">            break;</a>
<a name="ln1127"> </a>
<a name="ln1128">        case mon_output_xml:</a>
<a name="ln1129">            fprintf(stream, &quot;    %s\n&quot;,</a>
<a name="ln1130">                    (printed_heading? &quot;&lt;/resources&gt;&quot; : &quot;&lt;resources/&gt;&quot;));</a>
<a name="ln1131">            break;</a>
<a name="ln1132"> </a>
<a name="ln1133">        default:</a>
<a name="ln1134">            break;</a>
<a name="ln1135">    }</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138">/*!</a>
<a name="ln1139"> * \internal</a>
<a name="ln1140"> * \brief Print whatever resource section(s) are appropriate</a>
<a name="ln1141"> *</a>
<a name="ln1142"> * \param[in] stream     File stream to display output to</a>
<a name="ln1143"> * \param[in] data_set   Cluster state to display</a>
<a name="ln1144"> * \param[in] print_opts  Bitmask of pe_print_options</a>
<a name="ln1145"> */</a>
<a name="ln1146">static void</a>
<a name="ln1147">print_resources(FILE *stream, pe_working_set_t *data_set, int print_opts)</a>
<a name="ln1148">{</a>
<a name="ln1149">    GListPtr rsc_iter;</a>
<a name="ln1150">    const char *prefix = NULL;</a>
<a name="ln1151">    gboolean printed_heading = FALSE;</a>
<a name="ln1152">    gboolean brief_output = print_brief;</a>
<a name="ln1153"> </a>
<a name="ln1154">    /* If we already showed active resources by node, and</a>
<a name="ln1155">     * we're not showing inactive resources, we have nothing to do</a>
<a name="ln1156">     */</a>
<a name="ln1157">    if (group_by_node &amp;&amp; !inactive_resources) {</a>
<a name="ln1158">        return;</a>
<a name="ln1159">    }</a>
<a name="ln1160"> </a>
<a name="ln1161">    /* XML uses an indent, and ignores brief option for resources */</a>
<a name="ln1162">    if (output_format == mon_output_xml) {</a>
<a name="ln1163">        prefix = &quot;        &quot;;</a>
<a name="ln1164">        brief_output = FALSE;</a>
<a name="ln1165">    }</a>
<a name="ln1166"> </a>
<a name="ln1167">    /* If we haven't already printed resources grouped by node,</a>
<a name="ln1168">     * and brief output was requested, print resource summary */</a>
<a name="ln1169">    if (brief_output &amp;&amp; !group_by_node) {</a>
<a name="ln1170">        print_resources_heading(stream);</a>
<a name="ln1171">        printed_heading = TRUE;</a>
<a name="ln1172">        print_rscs_brief(data_set-&gt;resources, NULL, print_opts, stream,</a>
<a name="ln1173">                         inactive_resources);</a>
<a name="ln1174">    }</a>
<a name="ln1175"> </a>
<a name="ln1176">    /* For each resource, display it if appropriate */</a>
<a name="ln1177">    for (rsc_iter = data_set-&gt;resources; rsc_iter != NULL; rsc_iter = rsc_iter-&gt;next) {</a>
<a name="ln1178">        resource_t *rsc = (resource_t *) rsc_iter-&gt;data;</a>
<a name="ln1179"> </a>
<a name="ln1180">        /* Complex resources may have some sub-resources active and some inactive */</a>
<a name="ln1181">        gboolean is_active = rsc-&gt;fns-&gt;active(rsc, TRUE);</a>
<a name="ln1182">        gboolean partially_active = rsc-&gt;fns-&gt;active(rsc, FALSE);</a>
<a name="ln1183"> </a>
<a name="ln1184">        /* Skip inactive orphans (deleted but still in CIB) */</a>
<a name="ln1185">        if (is_set(rsc-&gt;flags, pe_rsc_orphan) &amp;&amp; !is_active) {</a>
<a name="ln1186">            continue;</a>
<a name="ln1187"> </a>
<a name="ln1188">        /* Skip active resources if we already displayed them by node */</a>
<a name="ln1189">        } else if (group_by_node) {</a>
<a name="ln1190">            if (is_active) {</a>
<a name="ln1191">                continue;</a>
<a name="ln1192">            }</a>
<a name="ln1193"> </a>
<a name="ln1194">        /* Skip primitives already counted in a brief summary */</a>
<a name="ln1195">        } else if (brief_output &amp;&amp; (rsc-&gt;variant == pe_native)) {</a>
<a name="ln1196">            continue;</a>
<a name="ln1197"> </a>
<a name="ln1198">        /* Skip resources that aren't at least partially active,</a>
<a name="ln1199">         * unless we're displaying inactive resources</a>
<a name="ln1200">         */</a>
<a name="ln1201">        } else if (!partially_active &amp;&amp; !inactive_resources) {</a>
<a name="ln1202">            continue;</a>
<a name="ln1203">        }</a>
<a name="ln1204"> </a>
<a name="ln1205">        /* Print this resource */</a>
<a name="ln1206">        if (printed_heading == FALSE) {</a>
<a name="ln1207">            print_resources_heading(stream);</a>
<a name="ln1208">            printed_heading = TRUE;</a>
<a name="ln1209">        }</a>
<a name="ln1210">        rsc-&gt;fns-&gt;print(rsc, prefix, print_opts, stream);</a>
<a name="ln1211">    }</a>
<a name="ln1212"> </a>
<a name="ln1213">    print_resources_closing(stream, printed_heading);</a>
<a name="ln1214">}</a>
<a name="ln1215"> </a>
<a name="ln1216">/*!</a>
<a name="ln1217"> * \internal</a>
<a name="ln1218"> * \brief Print heading for resource history</a>
<a name="ln1219"> *</a>
<a name="ln1220"> * \param[in] stream      File stream to display output to</a>
<a name="ln1221"> * \param[in] data_set    Current state of CIB</a>
<a name="ln1222"> * \param[in] node        Node that ran this resource</a>
<a name="ln1223"> * \param[in] rsc         Resource to print</a>
<a name="ln1224"> * \param[in] rsc_id      ID of resource to print</a>
<a name="ln1225"> * \param[in] all         Whether to print every resource or just failed ones</a>
<a name="ln1226"> */</a>
<a name="ln1227">static void</a>
<a name="ln1228">print_rsc_history_start(FILE *stream, pe_working_set_t *data_set, node_t *node,</a>
<a name="ln1229">                        resource_t *rsc, const char *rsc_id, gboolean all)</a>
<a name="ln1230">{</a>
<a name="ln1231">    time_t last_failure = 0;</a>
<a name="ln1232">    int failcount = rsc? get_failcount_full(node, rsc, &amp;last_failure, FALSE, NULL, data_set) : 0;</a>
<a name="ln1233"> </a>
<a name="ln1234">    if (!all &amp;&amp; !failcount &amp;&amp; (last_failure &lt;= 0)) {</a>
<a name="ln1235">        return;</a>
<a name="ln1236">    }</a>
<a name="ln1237"> </a>
<a name="ln1238">    /* Print resource ID */</a>
<a name="ln1239">    switch (output_format) {</a>
<a name="ln1240">        case mon_output_plain:</a>
<a name="ln1241">        case mon_output_console:</a>
<a name="ln1242">            print_as(&quot;   %s:&quot;, rsc_id);</a>
<a name="ln1243">            break;</a>
<a name="ln1244"> </a>
<a name="ln1245">        case mon_output_html:</a>
<a name="ln1246">        case mon_output_cgi:</a>
<a name="ln1247">            fprintf(stream, &quot;   &lt;li&gt;%s:&quot;, rsc_id);</a>
<a name="ln1248">            break;</a>
<a name="ln1249"> </a>
<a name="ln1250">        case mon_output_xml:</a>
<a name="ln1251">            fprintf(stream, &quot;            &lt;resource_history id=\&quot;%s\&quot;&quot;, rsc_id);</a>
<a name="ln1252">            break;</a>
<a name="ln1253"> </a>
<a name="ln1254">        default:</a>
<a name="ln1255">            break;</a>
<a name="ln1256">    }</a>
<a name="ln1257"> </a>
<a name="ln1258">    /* If resource is an orphan, that's all we can say about it */</a>
<a name="ln1259">    if (rsc == NULL) {</a>
<a name="ln1260">        switch (output_format) {</a>
<a name="ln1261">            case mon_output_plain:</a>
<a name="ln1262">            case mon_output_console:</a>
<a name="ln1263">                print_as(&quot; orphan&quot;);</a>
<a name="ln1264">                break;</a>
<a name="ln1265"> </a>
<a name="ln1266">            case mon_output_html:</a>
<a name="ln1267">            case mon_output_cgi:</a>
<a name="ln1268">                fprintf(stream, &quot; orphan&quot;);</a>
<a name="ln1269">                break;</a>
<a name="ln1270"> </a>
<a name="ln1271">            case mon_output_xml:</a>
<a name="ln1272">                fprintf(stream, &quot; orphan=\&quot;true\&quot;&quot;);</a>
<a name="ln1273">                break;</a>
<a name="ln1274"> </a>
<a name="ln1275">            default:</a>
<a name="ln1276">                break;</a>
<a name="ln1277">        }</a>
<a name="ln1278"> </a>
<a name="ln1279">    /* If resource is not an orphan, print some details */</a>
<a name="ln1280">    } else if (all || failcount || (last_failure &gt; 0)) {</a>
<a name="ln1281"> </a>
<a name="ln1282">        /* Print migration threshold */</a>
<a name="ln1283">        switch (output_format) {</a>
<a name="ln1284">            case mon_output_plain:</a>
<a name="ln1285">            case mon_output_console:</a>
<a name="ln1286">                print_as(&quot; migration-threshold=%d&quot;, rsc-&gt;migration_threshold);</a>
<a name="ln1287">                break;</a>
<a name="ln1288"> </a>
<a name="ln1289">            case mon_output_html:</a>
<a name="ln1290">            case mon_output_cgi:</a>
<a name="ln1291">                fprintf(stream, &quot; migration-threshold=%d&quot;, rsc-&gt;migration_threshold);</a>
<a name="ln1292">                break;</a>
<a name="ln1293"> </a>
<a name="ln1294">            case mon_output_xml:</a>
<a name="ln1295">                fprintf(stream, &quot; orphan=\&quot;false\&quot; migration-threshold=\&quot;%d\&quot;&quot;,</a>
<a name="ln1296">                        rsc-&gt;migration_threshold);</a>
<a name="ln1297">                break;</a>
<a name="ln1298"> </a>
<a name="ln1299">            default:</a>
<a name="ln1300">                break;</a>
<a name="ln1301">        }</a>
<a name="ln1302"> </a>
<a name="ln1303">        /* Print fail count if any */</a>
<a name="ln1304">        if (failcount &gt; 0) {</a>
<a name="ln1305">            switch (output_format) {</a>
<a name="ln1306">                case mon_output_plain:</a>
<a name="ln1307">                case mon_output_console:</a>
<a name="ln1308">                    print_as(&quot; &quot; CRM_FAIL_COUNT_PREFIX &quot;=%d&quot;, failcount);</a>
<a name="ln1309">                    break;</a>
<a name="ln1310"> </a>
<a name="ln1311">                case mon_output_html:</a>
<a name="ln1312">                case mon_output_cgi:</a>
<a name="ln1313">                    fprintf(stream, &quot; &quot; CRM_FAIL_COUNT_PREFIX &quot;=%d&quot;, failcount);</a>
<a name="ln1314">                    break;</a>
<a name="ln1315"> </a>
<a name="ln1316">                case mon_output_xml:</a>
<a name="ln1317">                    fprintf(stream, &quot; &quot; CRM_FAIL_COUNT_PREFIX &quot;=\&quot;%d\&quot;&quot;,</a>
<a name="ln1318">                            failcount);</a>
<a name="ln1319">                    break;</a>
<a name="ln1320"> </a>
<a name="ln1321">                default:</a>
<a name="ln1322">                    break;</a>
<a name="ln1323">            }</a>
<a name="ln1324">        }</a>
<a name="ln1325"> </a>
<a name="ln1326">        /* Print last failure time if any */</a>
<a name="ln1327">        if (last_failure &gt; 0) {</a>
<a name="ln1328">            print_nvpair(stream, CRM_LAST_FAILURE_PREFIX, NULL, NULL,</a>
<a name="ln1329">                         last_failure);</a>
<a name="ln1330">        }</a>
<a name="ln1331">    }</a>
<a name="ln1332"> </a>
<a name="ln1333">    /* End the heading */</a>
<a name="ln1334">    switch (output_format) {</a>
<a name="ln1335">        case mon_output_plain:</a>
<a name="ln1336">        case mon_output_console:</a>
<a name="ln1337">            print_as(&quot;\n&quot;);</a>
<a name="ln1338">            break;</a>
<a name="ln1339"> </a>
<a name="ln1340">        case mon_output_html:</a>
<a name="ln1341">        case mon_output_cgi:</a>
<a name="ln1342">            fprintf(stream, &quot;\n    &lt;ul&gt;\n&quot;);</a>
<a name="ln1343">            break;</a>
<a name="ln1344"> </a>
<a name="ln1345">        case mon_output_xml:</a>
<a name="ln1346">            fprintf(stream, &quot;&gt;\n&quot;);</a>
<a name="ln1347">            break;</a>
<a name="ln1348"> </a>
<a name="ln1349">        default:</a>
<a name="ln1350">            break;</a>
<a name="ln1351">    }</a>
<a name="ln1352">}</a>
<a name="ln1353"> </a>
<a name="ln1354">/*!</a>
<a name="ln1355"> * \internal</a>
<a name="ln1356"> * \brief Print closing for resource history</a>
<a name="ln1357"> *</a>
<a name="ln1358"> * \param[in] stream      File stream to display output to</a>
<a name="ln1359"> */</a>
<a name="ln1360">static void</a>
<a name="ln1361">print_rsc_history_end(FILE *stream)</a>
<a name="ln1362">{</a>
<a name="ln1363">    switch (output_format) {</a>
<a name="ln1364">        case mon_output_html:</a>
<a name="ln1365">        case mon_output_cgi:</a>
<a name="ln1366">            fprintf(stream, &quot;    &lt;/ul&gt;\n   &lt;/li&gt;\n&quot;);</a>
<a name="ln1367">            break;</a>
<a name="ln1368"> </a>
<a name="ln1369">        case mon_output_xml:</a>
<a name="ln1370">            fprintf(stream, &quot;            &lt;/resource_history&gt;\n&quot;);</a>
<a name="ln1371">            break;</a>
<a name="ln1372"> </a>
<a name="ln1373">        default:</a>
<a name="ln1374">            break;</a>
<a name="ln1375">    }</a>
<a name="ln1376">}</a>
<a name="ln1377"> </a>
<a name="ln1378">/*!</a>
<a name="ln1379"> * \internal</a>
<a name="ln1380"> * \brief Print operation history</a>
<a name="ln1381"> *</a>
<a name="ln1382"> * \param[in] stream      File stream to display output to</a>
<a name="ln1383"> * \param[in] data_set    Current state of CIB</a>
<a name="ln1384"> * \param[in] node        Node this operation is for</a>
<a name="ln1385"> * \param[in] xml_op      Root of XML tree describing this operation</a>
<a name="ln1386"> * \param[in] task        Task parsed from this operation's XML</a>
<a name="ln1387"> * \param[in] interval    Interval parsed from this operation's XML</a>
<a name="ln1388"> * \param[in] rc          Return code parsed from this operation's XML</a>
<a name="ln1389"> */</a>
<a name="ln1390">static void</a>
<a name="ln1391">print_op_history(FILE *stream, pe_working_set_t *data_set, node_t *node,</a>
<a name="ln1392">                 xmlNode *xml_op, const char *task, const char *interval, int rc)</a>
<a name="ln1393">{</a>
<a name="ln1394">    const char *value = NULL;</a>
<a name="ln1395">    const char *call = crm_element_value(xml_op, XML_LRM_ATTR_CALLID);</a>
<a name="ln1396"> </a>
<a name="ln1397">    /* Begin the operation description */</a>
<a name="ln1398">    switch (output_format) {</a>
<a name="ln1399">        case mon_output_plain:</a>
<a name="ln1400">        case mon_output_console:</a>
<a name="ln1401">            print_as(&quot;    + (%s) %s:&quot;, call, task);</a>
<a name="ln1402">            break;</a>
<a name="ln1403"> </a>
<a name="ln1404">        case mon_output_html:</a>
<a name="ln1405">        case mon_output_cgi:</a>
<a name="ln1406">            fprintf(stream, &quot;     &lt;li&gt;(%s) %s:&quot;, call, task);</a>
<a name="ln1407">            break;</a>
<a name="ln1408"> </a>
<a name="ln1409">        case mon_output_xml:</a>
<a name="ln1410">            fprintf(stream, &quot;                &lt;operation_history call=\&quot;%s\&quot; task=\&quot;%s\&quot;&quot;,</a>
<a name="ln1411">                    call, task);</a>
<a name="ln1412">            break;</a>
<a name="ln1413"> </a>
<a name="ln1414">        default:</a>
<a name="ln1415">            break;</a>
<a name="ln1416">    }</a>
<a name="ln1417"> </a>
<a name="ln1418">    /* Add name=value pairs as appropriate */</a>
<a name="ln1419">    if (safe_str_neq(interval, &quot;0&quot;)) {</a>
<a name="ln1420">        print_nvpair(stream, &quot;interval&quot;, interval, &quot;ms&quot;, 0);</a>
<a name="ln1421">    }</a>
<a name="ln1422">    if (print_timing) {</a>
<a name="ln1423">        int int_value;</a>
<a name="ln1424">        const char *attr;</a>
<a name="ln1425"> </a>
<a name="ln1426">        attr = XML_RSC_OP_LAST_CHANGE;</a>
<a name="ln1427">        value = crm_element_value(xml_op, attr);</a>
<a name="ln1428">        if (value) {</a>
<a name="ln1429">            int_value = crm_parse_int(value, NULL);</a>
<a name="ln1430">            if (int_value &gt; 0) {</a>
<a name="ln1431">                print_nvpair(stream, attr, NULL, NULL, int_value);</a>
<a name="ln1432">            }</a>
<a name="ln1433">        }</a>
<a name="ln1434"> </a>
<a name="ln1435">        attr = XML_RSC_OP_LAST_RUN;</a>
<a name="ln1436">        value = crm_element_value(xml_op, attr);</a>
<a name="ln1437">        if (value) {</a>
<a name="ln1438">            int_value = crm_parse_int(value, NULL);</a>
<a name="ln1439">            if (int_value &gt; 0) {</a>
<a name="ln1440">                print_nvpair(stream, attr, NULL, NULL, int_value);</a>
<a name="ln1441">            }</a>
<a name="ln1442">        }</a>
<a name="ln1443"> </a>
<a name="ln1444">        attr = XML_RSC_OP_T_EXEC;</a>
<a name="ln1445">        value = crm_element_value(xml_op, attr);</a>
<a name="ln1446">        if (value) {</a>
<a name="ln1447">            print_nvpair(stream, attr, value, &quot;ms&quot;, 0);</a>
<a name="ln1448">        }</a>
<a name="ln1449"> </a>
<a name="ln1450">        attr = XML_RSC_OP_T_QUEUE;</a>
<a name="ln1451">        value = crm_element_value(xml_op, attr);</a>
<a name="ln1452">        if (value) {</a>
<a name="ln1453">            print_nvpair(stream, attr, value, &quot;ms&quot;, 0);</a>
<a name="ln1454">        }</a>
<a name="ln1455">    }</a>
<a name="ln1456"> </a>
<a name="ln1457">    /* End the operation description */</a>
<a name="ln1458">    switch (output_format) {</a>
<a name="ln1459">        case mon_output_plain:</a>
<a name="ln1460">        case mon_output_console:</a>
<a name="ln1461">            print_as(&quot; rc=%d (%s)\n&quot;, rc, services_ocf_exitcode_str(rc));</a>
<a name="ln1462">            break;</a>
<a name="ln1463"> </a>
<a name="ln1464">        case mon_output_html:</a>
<a name="ln1465">        case mon_output_cgi:</a>
<a name="ln1466">            fprintf(stream, &quot; rc=%d (%s)&lt;/li&gt;\n&quot;, rc, services_ocf_exitcode_str(rc));</a>
<a name="ln1467">            break;</a>
<a name="ln1468"> </a>
<a name="ln1469">        case mon_output_xml:</a>
<a name="ln1470">            fprintf(stream, &quot; rc=\&quot;%d\&quot; rc_text=\&quot;%s\&quot; /&gt;\n&quot;, rc, services_ocf_exitcode_str(rc));</a>
<a name="ln1471">            break;</a>
<a name="ln1472"> </a>
<a name="ln1473">        default:</a>
<a name="ln1474">            break;</a>
<a name="ln1475">    }</a>
<a name="ln1476">}</a>
<a name="ln1477"> </a>
<a name="ln1478">/*!</a>
<a name="ln1479"> * \internal</a>
<a name="ln1480"> * \brief Print resource operation/failure history</a>
<a name="ln1481"> *</a>
<a name="ln1482"> * \param[in] stream      File stream to display output to</a>
<a name="ln1483"> * \param[in] data_set    Current state of CIB</a>
<a name="ln1484"> * \param[in] node        Node that ran this resource</a>
<a name="ln1485"> * \param[in] rsc_entry   Root of XML tree describing resource status</a>
<a name="ln1486"> * \param[in] operations  Whether to print operations or just failcounts</a>
<a name="ln1487"> */</a>
<a name="ln1488">static void</a>
<a name="ln1489">print_rsc_history(FILE *stream, pe_working_set_t *data_set, node_t *node,</a>
<a name="ln1490">                  xmlNode *rsc_entry, gboolean operations)</a>
<a name="ln1491">{</a>
<a name="ln1492">    GListPtr gIter = NULL;</a>
<a name="ln1493">    GListPtr op_list = NULL;</a>
<a name="ln1494">    gboolean printed = FALSE;</a>
<a name="ln1495">    const char *rsc_id = crm_element_value(rsc_entry, XML_ATTR_ID);</a>
<a name="ln1496">    resource_t *rsc = pe_find_resource(data_set-&gt;resources, rsc_id);</a>
<a name="ln1497">    xmlNode *rsc_op = NULL;</a>
<a name="ln1498"> </a>
<a name="ln1499">    /* If we're not showing operations, just print the resource failure summary */</a>
<a name="ln1500">    if (operations == FALSE) {</a>
<a name="ln1501">        print_rsc_history_start(stream, data_set, node, rsc, rsc_id, FALSE);</a>
<a name="ln1502">        print_rsc_history_end(stream);</a>
<a name="ln1503">        return;</a>
<a name="ln1504">    }</a>
<a name="ln1505"> </a>
<a name="ln1506">    /* Create a list of this resource's operations */</a>
<a name="ln1507">    for (rsc_op = __xml_first_child(rsc_entry); rsc_op != NULL; rsc_op = __xml_next(rsc_op)) {</a>
<a name="ln1508">        if (crm_str_eq((const char *)rsc_op-&gt;name, XML_LRM_TAG_RSC_OP, TRUE)) {</a>
<a name="ln1509">            op_list = g_list_append(op_list, rsc_op);</a>
<a name="ln1510">        }</a>
<a name="ln1511">    }</a>
<a name="ln1512">    op_list = g_list_sort(op_list, sort_op_by_callid);</a>
<a name="ln1513"> </a>
<a name="ln1514">    /* Print each operation */</a>
<a name="ln1515">    for (gIter = op_list; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln1516">        xmlNode *xml_op = (xmlNode *) gIter-&gt;data;</a>
<a name="ln1517">        const char *task = crm_element_value(xml_op, XML_LRM_ATTR_TASK);</a>
<a name="ln1518">        const char *interval = crm_element_value(xml_op, XML_LRM_ATTR_INTERVAL);</a>
<a name="ln1519">        const char *op_rc = crm_element_value(xml_op, XML_LRM_ATTR_RC);</a>
<a name="ln1520">        int rc = crm_parse_int(op_rc, &quot;0&quot;);</a>
<a name="ln1521"> </a>
<a name="ln1522">        /* Display 0-interval monitors as &quot;probe&quot; */</a>
<a name="ln1523">        if (safe_str_eq(task, CRMD_ACTION_STATUS) &amp;&amp; safe_str_eq(interval, &quot;0&quot;)) {</a>
<a name="ln1524">            task = &quot;probe&quot;;</a>
<a name="ln1525">        }</a>
<a name="ln1526"> </a>
<a name="ln1527">        /* Ignore notifies and some probes */</a>
<a name="ln1528">        if (safe_str_eq(task, CRMD_ACTION_NOTIFY) || (safe_str_eq(task, &quot;probe&quot;) &amp;&amp; (rc == 7))) {</a>
<a name="ln1529">            continue;</a>
<a name="ln1530">        }</a>
<a name="ln1531"> </a>
<a name="ln1532">        /* If this is the first printed operation, print heading for resource */</a>
<a name="ln1533">        if (printed == FALSE) {</a>
<a name="ln1534">            printed = TRUE;</a>
<a name="ln1535">            print_rsc_history_start(stream, data_set, node, rsc, rsc_id, TRUE);</a>
<a name="ln1536">        }</a>
<a name="ln1537"> </a>
<a name="ln1538">        /* Print the operation */</a>
<a name="ln1539">        print_op_history(stream, data_set, node, xml_op, task, interval, rc);</a>
<a name="ln1540">    }</a>
<a name="ln1541"> </a>
<a name="ln1542">    /* Free the list we created (no need to free the individual items) */</a>
<a name="ln1543">    g_list_free(op_list);</a>
<a name="ln1544"> </a>
<a name="ln1545">    /* If we printed anything, close the resource */</a>
<a name="ln1546">    if (printed) {</a>
<a name="ln1547">        print_rsc_history_end(stream);</a>
<a name="ln1548">    }</a>
<a name="ln1549">}</a>
<a name="ln1550"> </a>
<a name="ln1551">/*!</a>
<a name="ln1552"> * \internal</a>
<a name="ln1553"> * \brief Print node operation/failure history</a>
<a name="ln1554"> *</a>
<a name="ln1555"> * \param[in] stream      File stream to display output to</a>
<a name="ln1556"> * \param[in] data_set    Current state of CIB</a>
<a name="ln1557"> * \param[in] node_state  Root of XML tree describing node status</a>
<a name="ln1558"> * \param[in] operations  Whether to print operations or just failcounts</a>
<a name="ln1559"> */</a>
<a name="ln1560">static void</a>
<a name="ln1561">print_node_history(FILE *stream, pe_working_set_t *data_set,</a>
<a name="ln1562">                   xmlNode *node_state, gboolean operations)</a>
<a name="ln1563">{</a>
<a name="ln1564">    node_t *node = pe_find_node_id(data_set-&gt;nodes, ID(node_state));</a>
<a name="ln1565">    xmlNode *lrm_rsc = NULL;</a>
<a name="ln1566">    xmlNode *rsc_entry = NULL;</a>
<a name="ln1567"> </a>
<a name="ln1568">    if (node &amp;&amp; node-&gt;details &amp;&amp; node-&gt;details-&gt;online) {</a>
<a name="ln1569">        print_node_start(stream, node);</a>
<a name="ln1570"> </a>
<a name="ln1571">        lrm_rsc = find_xml_node(node_state, XML_CIB_TAG_LRM, FALSE);</a>
<a name="ln1572">        lrm_rsc = find_xml_node(lrm_rsc, XML_LRM_TAG_RESOURCES, FALSE);</a>
<a name="ln1573"> </a>
<a name="ln1574">        /* Print history of each of the node's resources */</a>
<a name="ln1575">        for (rsc_entry = __xml_first_child(lrm_rsc); rsc_entry != NULL;</a>
<a name="ln1576">             rsc_entry = __xml_next(rsc_entry)) {</a>
<a name="ln1577"> </a>
<a name="ln1578">            if (crm_str_eq((const char *)rsc_entry-&gt;name, XML_LRM_TAG_RESOURCE, TRUE)) {</a>
<a name="ln1579">                print_rsc_history(stream, data_set, node, rsc_entry, operations);</a>
<a name="ln1580">            }</a>
<a name="ln1581">        }</a>
<a name="ln1582"> </a>
<a name="ln1583">        print_node_end(stream);</a>
<a name="ln1584">    }</a>
<a name="ln1585">}</a>
<a name="ln1586"> </a>
<a name="ln1587">/*!</a>
<a name="ln1588"> * \internal</a>
<a name="ln1589"> * \brief Print extended information about an attribute if appropriate</a>
<a name="ln1590"> *</a>
<a name="ln1591"> * \param[in] data_set  Working set of CIB state</a>
<a name="ln1592"> *</a>
<a name="ln1593"> * \return TRUE if extended information was printed, FALSE otherwise</a>
<a name="ln1594"> * \note Currently, extended information is only supported for ping/pingd</a>
<a name="ln1595"> *       resources, for which a message will be printed if connectivity is lost</a>
<a name="ln1596"> *       or degraded.</a>
<a name="ln1597"> */</a>
<a name="ln1598">static gboolean</a>
<a name="ln1599">print_attr_msg(FILE *stream, node_t * node, GListPtr rsc_list, const char *attrname, const char *attrvalue)</a>
<a name="ln1600">{</a>
<a name="ln1601">    GListPtr gIter = NULL;</a>
<a name="ln1602"> </a>
<a name="ln1603">    for (gIter = rsc_list; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln1604">        resource_t *rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln1605">        const char *type = g_hash_table_lookup(rsc-&gt;meta, &quot;type&quot;);</a>
<a name="ln1606"> </a>
<a name="ln1607">        if (rsc-&gt;children != NULL) {</a>
<a name="ln1608">            if (print_attr_msg(stream, node, rsc-&gt;children, attrname, attrvalue)) {</a>
<a name="ln1609">                return TRUE;</a>
<a name="ln1610">            }</a>
<a name="ln1611">        }</a>
<a name="ln1612"> </a>
<a name="ln1613">        if (safe_str_eq(type, &quot;ping&quot;) || safe_str_eq(type, &quot;pingd&quot;)) {</a>
<a name="ln1614">            const char *name = g_hash_table_lookup(rsc-&gt;parameters, &quot;name&quot;);</a>
<a name="ln1615"> </a>
<a name="ln1616">            if (name == NULL) {</a>
<a name="ln1617">                name = &quot;pingd&quot;;</a>
<a name="ln1618">            }</a>
<a name="ln1619"> </a>
<a name="ln1620">            /* To identify the resource with the attribute name. */</a>
<a name="ln1621">            if (safe_str_eq(name, attrname)) {</a>
<a name="ln1622">                int host_list_num = 0;</a>
<a name="ln1623">                int expected_score = 0;</a>
<a name="ln1624">                int value = crm_parse_int(attrvalue, &quot;0&quot;);</a>
<a name="ln1625">                const char *hosts = g_hash_table_lookup(rsc-&gt;parameters, &quot;host_list&quot;);</a>
<a name="ln1626">                const char *multiplier = g_hash_table_lookup(rsc-&gt;parameters, &quot;multiplier&quot;);</a>
<a name="ln1627"> </a>
<a name="ln1628">                if(hosts) {</a>
<a name="ln1629">                    char **host_list = g_strsplit(hosts, &quot; &quot;, 0);</a>
<a name="ln1630">                    host_list_num = g_strv_length(host_list);</a>
<a name="ln1631">                    g_strfreev(host_list);</a>
<a name="ln1632">                }</a>
<a name="ln1633"> </a>
<a name="ln1634">                /* pingd multiplier is the same as the default value. */</a>
<a name="ln1635">                expected_score = host_list_num * crm_parse_int(multiplier, &quot;1&quot;);</a>
<a name="ln1636"> </a>
<a name="ln1637">                switch (output_format) {</a>
<a name="ln1638">                    case mon_output_plain:</a>
<a name="ln1639">                    case mon_output_console:</a>
<a name="ln1640">                        if (value &lt;= 0) {</a>
<a name="ln1641">                            print_as(&quot;\t: Connectivity is lost&quot;);</a>
<a name="ln1642">                        } else if (value &lt; expected_score) {</a>
<a name="ln1643">                            print_as(&quot;\t: Connectivity is degraded (Expected=%d)&quot;, expected_score);</a>
<a name="ln1644">                        }</a>
<a name="ln1645">                        break;</a>
<a name="ln1646"> </a>
<a name="ln1647">                    case mon_output_html:</a>
<a name="ln1648">                    case mon_output_cgi:</a>
<a name="ln1649">                        if (value &lt;= 0) {</a>
<a name="ln1650">                            fprintf(stream, &quot; &lt;b&gt;(connectivity is lost)&lt;/b&gt;&quot;);</a>
<a name="ln1651">                        } else if (value &lt; expected_score) {</a>
<a name="ln1652">                            fprintf(stream, &quot; &lt;b&gt;(connectivity is degraded -- expected %d)&lt;/b&gt;&quot;,</a>
<a name="ln1653">                                    expected_score);</a>
<a name="ln1654">                        }</a>
<a name="ln1655">                        break;</a>
<a name="ln1656"> </a>
<a name="ln1657">                    case mon_output_xml:</a>
<a name="ln1658">                        fprintf(stream, &quot; expected=\&quot;%d\&quot;&quot;, expected_score);</a>
<a name="ln1659">                        break;</a>
<a name="ln1660"> </a>
<a name="ln1661">                    default:</a>
<a name="ln1662">                        break;</a>
<a name="ln1663">                }</a>
<a name="ln1664">                return TRUE;</a>
<a name="ln1665">            }</a>
<a name="ln1666">        }</a>
<a name="ln1667">    }</a>
<a name="ln1668">    return FALSE;</a>
<a name="ln1669">}</a>
<a name="ln1670"> </a>
<a name="ln1671">static int</a>
<a name="ln1672">compare_attribute(gconstpointer a, gconstpointer b)</a>
<a name="ln1673">{</a>
<a name="ln1674">    int rc;</a>
<a name="ln1675"> </a>
<a name="ln1676">    rc = strcmp((const char *)a, (const char *)b);</a>
<a name="ln1677"> </a>
<a name="ln1678">    return rc;</a>
<a name="ln1679">}</a>
<a name="ln1680"> </a>
<a name="ln1681">static void</a>
<a name="ln1682">create_attr_list(gpointer name, gpointer value, gpointer data)</a>
<a name="ln1683">{</a>
<a name="ln1684">    int i;</a>
<a name="ln1685">    const char *filt_str[] = FILTER_STR;</a>
<a name="ln1686"> </a>
<a name="ln1687">    CRM_CHECK(name != NULL, return);</a>
<a name="ln1688"> </a>
<a name="ln1689">    /* filtering automatic attributes */</a>
<a name="ln1690">    for (i = 0; filt_str[i] != NULL; i++) {</a>
<a name="ln1691">        if (g_str_has_prefix(name, filt_str[i])) {</a>
<a name="ln1692">            return;</a>
<a name="ln1693">        }</a>
<a name="ln1694">    }</a>
<a name="ln1695"> </a>
<a name="ln1696">    attr_list = g_list_insert_sorted(attr_list, name, compare_attribute);</a>
<a name="ln1697">}</a>
<a name="ln1698"> </a>
<a name="ln1699">/* structure for passing multiple user data to g_list_foreach() */</a>
<a name="ln1700">struct mon_attr_data {</a>
<a name="ln1701">    FILE *stream;</a>
<a name="ln1702">    node_t *node;</a>
<a name="ln1703">};</a>
<a name="ln1704"> </a>
<a name="ln1705">static void</a>
<a name="ln1706">print_node_attribute(gpointer name, gpointer user_data)</a>
<a name="ln1707">{</a>
<a name="ln1708">    const char *value = NULL;</a>
<a name="ln1709">    struct mon_attr_data *data = (struct mon_attr_data *) user_data;</a>
<a name="ln1710"> </a>
<a name="ln1711">    value = g_hash_table_lookup(data-&gt;node-&gt;details-&gt;attrs, name);</a>
<a name="ln1712"> </a>
<a name="ln1713">    /* Print attribute name and value */</a>
<a name="ln1714">    switch (output_format) {</a>
<a name="ln1715">        case mon_output_plain:</a>
<a name="ln1716">        case mon_output_console:</a>
<a name="ln1717">            print_as(&quot;    + %-32s\t: %-10s&quot;, (char *)name, value);</a>
<a name="ln1718">            break;</a>
<a name="ln1719"> </a>
<a name="ln1720">        case mon_output_html:</a>
<a name="ln1721">        case mon_output_cgi:</a>
<a name="ln1722">            fprintf(data-&gt;stream, &quot;   &lt;li&gt;%s: %s&quot;,</a>
<a name="ln1723">                    (char *)name, value);</a>
<a name="ln1724">            break;</a>
<a name="ln1725"> </a>
<a name="ln1726">        case mon_output_xml:</a>
<a name="ln1727">            fprintf(data-&gt;stream,</a>
<a name="ln1728">                    &quot;            &lt;attribute name=\&quot;%s\&quot; value=\&quot;%s\&quot;&quot;,</a>
<a name="ln1729">                    (char *)name, value);</a>
<a name="ln1730">            break;</a>
<a name="ln1731"> </a>
<a name="ln1732">        default:</a>
<a name="ln1733">            break;</a>
<a name="ln1734">    }</a>
<a name="ln1735"> </a>
<a name="ln1736">    /* Print extended information if appropriate */</a>
<a name="ln1737">    print_attr_msg(data-&gt;stream, data-&gt;node, data-&gt;node-&gt;details-&gt;running_rsc,</a>
<a name="ln1738">                   name, value);</a>
<a name="ln1739"> </a>
<a name="ln1740">    /* Close out the attribute */</a>
<a name="ln1741">    switch (output_format) {</a>
<a name="ln1742">        case mon_output_plain:</a>
<a name="ln1743">        case mon_output_console:</a>
<a name="ln1744">            print_as(&quot;\n&quot;);</a>
<a name="ln1745">            break;</a>
<a name="ln1746"> </a>
<a name="ln1747">        case mon_output_html:</a>
<a name="ln1748">        case mon_output_cgi:</a>
<a name="ln1749">            fprintf(data-&gt;stream, &quot;&lt;/li&gt;\n&quot;);</a>
<a name="ln1750">            break;</a>
<a name="ln1751"> </a>
<a name="ln1752">        case mon_output_xml:</a>
<a name="ln1753">            fprintf(data-&gt;stream, &quot; /&gt;\n&quot;);</a>
<a name="ln1754">            break;</a>
<a name="ln1755"> </a>
<a name="ln1756">        default:</a>
<a name="ln1757">            break;</a>
<a name="ln1758">    }</a>
<a name="ln1759">}</a>
<a name="ln1760"> </a>
<a name="ln1761">static void</a>
<a name="ln1762">print_node_summary(FILE *stream, pe_working_set_t * data_set, gboolean operations)</a>
<a name="ln1763">{</a>
<a name="ln1764">    xmlNode *node_state = NULL;</a>
<a name="ln1765">    xmlNode *cib_status = get_object_root(XML_CIB_TAG_STATUS, data_set-&gt;input);</a>
<a name="ln1766"> </a>
<a name="ln1767">    /* Print heading */</a>
<a name="ln1768">    switch (output_format) {</a>
<a name="ln1769">        case mon_output_plain:</a>
<a name="ln1770">        case mon_output_console:</a>
<a name="ln1771">            if (operations) {</a>
<a name="ln1772">                print_as(&quot;\nOperations:\n&quot;);</a>
<a name="ln1773">            } else {</a>
<a name="ln1774">                print_as(&quot;\nMigration Summary:\n&quot;);</a>
<a name="ln1775">            }</a>
<a name="ln1776">            break;</a>
<a name="ln1777"> </a>
<a name="ln1778">        case mon_output_html:</a>
<a name="ln1779">        case mon_output_cgi:</a>
<a name="ln1780">            if (operations) {</a>
<a name="ln1781">                fprintf(stream, &quot; &lt;hr /&gt;\n &lt;h2&gt;Operations&lt;/h2&gt;\n&quot;);</a>
<a name="ln1782">            } else {</a>
<a name="ln1783">                fprintf(stream, &quot; &lt;hr /&gt;\n &lt;h2&gt;Migration Summary&lt;/h2&gt;\n&quot;);</a>
<a name="ln1784">            }</a>
<a name="ln1785">            break;</a>
<a name="ln1786"> </a>
<a name="ln1787">        case mon_output_xml:</a>
<a name="ln1788">            fprintf(stream, &quot;    &lt;node_history&gt;\n&quot;);</a>
<a name="ln1789">            break;</a>
<a name="ln1790"> </a>
<a name="ln1791">        default:</a>
<a name="ln1792">            break;</a>
<a name="ln1793">    }</a>
<a name="ln1794"> </a>
<a name="ln1795">    /* Print each node in the CIB status */</a>
<a name="ln1796">    for (node_state = __xml_first_child(cib_status); node_state != NULL;</a>
<a name="ln1797">         node_state = __xml_next(node_state)) {</a>
<a name="ln1798">        if (crm_str_eq((const char *)node_state-&gt;name, XML_CIB_TAG_STATE, TRUE)) {</a>
<a name="ln1799">            print_node_history(stream, data_set, node_state, operations);</a>
<a name="ln1800">        }</a>
<a name="ln1801">    }</a>
<a name="ln1802"> </a>
<a name="ln1803">    /* Close section */</a>
<a name="ln1804">    switch (output_format) {</a>
<a name="ln1805">        case mon_output_xml:</a>
<a name="ln1806">            fprintf(stream, &quot;    &lt;/node_history&gt;\n&quot;);</a>
<a name="ln1807">            break;</a>
<a name="ln1808"> </a>
<a name="ln1809">        default:</a>
<a name="ln1810">            break;</a>
<a name="ln1811">    }</a>
<a name="ln1812">}</a>
<a name="ln1813"> </a>
<a name="ln1814">static void</a>
<a name="ln1815">print_ticket(gpointer name, gpointer value, gpointer data)</a>
<a name="ln1816">{</a>
<a name="ln1817">    ticket_t *ticket = (ticket_t *) value;</a>
<a name="ln1818">    FILE *stream = (FILE *) data;</a>
<a name="ln1819"> </a>
<a name="ln1820">    switch (output_format) {</a>
<a name="ln1821">        case mon_output_plain:</a>
<a name="ln1822">        case mon_output_console:</a>
<a name="ln1823">            print_as(&quot;* %s:\t%s%s&quot;, ticket-&gt;id,</a>
<a name="ln1824">                     (ticket-&gt;granted? &quot;granted&quot; : &quot;revoked&quot;),</a>
<a name="ln1825">                     (ticket-&gt;standby? &quot; [standby]&quot; : &quot;&quot;));</a>
<a name="ln1826">            break;</a>
<a name="ln1827"> </a>
<a name="ln1828">        case mon_output_html:</a>
<a name="ln1829">        case mon_output_cgi:</a>
<a name="ln1830">            fprintf(stream, &quot;  &lt;li&gt;%s: %s%s&quot;, ticket-&gt;id,</a>
<a name="ln1831">                    (ticket-&gt;granted? &quot;granted&quot; : &quot;revoked&quot;),</a>
<a name="ln1832">                    (ticket-&gt;standby? &quot; [standby]&quot; : &quot;&quot;));</a>
<a name="ln1833">            break;</a>
<a name="ln1834"> </a>
<a name="ln1835">        case mon_output_xml:</a>
<a name="ln1836">            fprintf(stream, &quot;        &lt;ticket id=\&quot;%s\&quot; status=\&quot;%s\&quot; standby=\&quot;%s\&quot;&quot;,</a>
<a name="ln1837">                    ticket-&gt;id, (ticket-&gt;granted? &quot;granted&quot; : &quot;revoked&quot;),</a>
<a name="ln1838">                    (ticket-&gt;standby? &quot;true&quot; : &quot;false&quot;));</a>
<a name="ln1839">            break;</a>
<a name="ln1840"> </a>
<a name="ln1841">        default:</a>
<a name="ln1842">            break;</a>
<a name="ln1843">    }</a>
<a name="ln1844">    if (ticket-&gt;last_granted &gt; -1) {</a>
<a name="ln1845">        print_nvpair(stdout, &quot;last-granted&quot;, NULL, NULL, ticket-&gt;last_granted);</a>
<a name="ln1846">    }</a>
<a name="ln1847">    switch (output_format) {</a>
<a name="ln1848">        case mon_output_plain:</a>
<a name="ln1849">        case mon_output_console:</a>
<a name="ln1850">            print_as(&quot;\n&quot;);</a>
<a name="ln1851">            break;</a>
<a name="ln1852"> </a>
<a name="ln1853">        case mon_output_html:</a>
<a name="ln1854">        case mon_output_cgi:</a>
<a name="ln1855">            fprintf(stream, &quot;&lt;/li&gt;\n&quot;);</a>
<a name="ln1856">            break;</a>
<a name="ln1857"> </a>
<a name="ln1858">        case mon_output_xml:</a>
<a name="ln1859">            fprintf(stream, &quot; /&gt;\n&quot;);</a>
<a name="ln1860">            break;</a>
<a name="ln1861"> </a>
<a name="ln1862">        default:</a>
<a name="ln1863">            break;</a>
<a name="ln1864">    }</a>
<a name="ln1865">}</a>
<a name="ln1866"> </a>
<a name="ln1867">static void</a>
<a name="ln1868">print_cluster_tickets(FILE *stream, pe_working_set_t * data_set)</a>
<a name="ln1869">{</a>
<a name="ln1870">    /* Print section heading */</a>
<a name="ln1871">    switch (output_format) {</a>
<a name="ln1872">        case mon_output_plain:</a>
<a name="ln1873">        case mon_output_console:</a>
<a name="ln1874">            print_as(&quot;\nTickets:\n&quot;);</a>
<a name="ln1875">            break;</a>
<a name="ln1876"> </a>
<a name="ln1877">        case mon_output_html:</a>
<a name="ln1878">        case mon_output_cgi:</a>
<a name="ln1879">            fprintf(stream, &quot; &lt;hr /&gt;\n &lt;h2&gt;Tickets&lt;/h2&gt;\n &lt;ul&gt;\n&quot;);</a>
<a name="ln1880">            break;</a>
<a name="ln1881"> </a>
<a name="ln1882">        case mon_output_xml:</a>
<a name="ln1883">            fprintf(stream, &quot;    &lt;tickets&gt;\n&quot;);</a>
<a name="ln1884">            break;</a>
<a name="ln1885"> </a>
<a name="ln1886">        default:</a>
<a name="ln1887">            break;</a>
<a name="ln1888">    }</a>
<a name="ln1889"> </a>
<a name="ln1890">    /* Print each ticket */</a>
<a name="ln1891">    g_hash_table_foreach(data_set-&gt;tickets, print_ticket, stream);</a>
<a name="ln1892"> </a>
<a name="ln1893">    /* Close section */</a>
<a name="ln1894">    switch (output_format) {</a>
<a name="ln1895">        case mon_output_html:</a>
<a name="ln1896">        case mon_output_cgi:</a>
<a name="ln1897">            fprintf(stream, &quot; &lt;/ul&gt;\n&quot;);</a>
<a name="ln1898">            break;</a>
<a name="ln1899"> </a>
<a name="ln1900">        case mon_output_xml:</a>
<a name="ln1901">            fprintf(stream, &quot;    &lt;/tickets&gt;\n&quot;);</a>
<a name="ln1902">            break;</a>
<a name="ln1903"> </a>
<a name="ln1904">        default:</a>
<a name="ln1905">            break;</a>
<a name="ln1906">    }</a>
<a name="ln1907">}</a>
<a name="ln1908"> </a>
<a name="ln1909">/*!</a>
<a name="ln1910"> * \internal</a>
<a name="ln1911"> * \brief Return human-friendly string representing node name</a>
<a name="ln1912"> *</a>
<a name="ln1913"> * The returned string will be in the format</a>
<a name="ln1914"> *    uname[@hostUname] [(nodeID)]</a>
<a name="ln1915"> * &quot;@hostUname&quot; will be printed if the node is a guest node.</a>
<a name="ln1916"> * &quot;(nodeID)&quot; will be printed if the node ID is different from the node uname,</a>
<a name="ln1917"> *  and detailed output has been requested.</a>
<a name="ln1918"> *</a>
<a name="ln1919"> * \param[in] node  Node to represent</a>
<a name="ln1920"> * \return Newly allocated string with representation of node name</a>
<a name="ln1921"> * \note It is the caller's responsibility to free the result with free().</a>
<a name="ln1922"> */</a>
<a name="ln1923">static char *</a>
<a name="ln1924">get_node_display_name(node_t *node)</a>
<a name="ln1925">{</a>
<a name="ln1926">    char *node_name;</a>
<a name="ln1927">    const char *node_host = NULL;</a>
<a name="ln1928">    const char *node_id = NULL;</a>
<a name="ln1929">    int name_len;</a>
<a name="ln1930"> </a>
<a name="ln1931">    CRM_ASSERT((node != NULL) &amp;&amp; (node-&gt;details != NULL) &amp;&amp; (node-&gt;details-&gt;uname != NULL));</a>
<a name="ln1932"> </a>
<a name="ln1933">    /* Host is displayed only if this is a guest node */</a>
<a name="ln1934">    if (is_container_remote_node(node)) {</a>
<a name="ln1935">        if (node-&gt;details-&gt;remote_rsc-&gt;running_on) {</a>
<a name="ln1936">            /* running_on is a list, but guest nodes will have exactly one entry</a>
<a name="ln1937">             * unless they are in the process of migrating, in which case they</a>
<a name="ln1938">             * will have two; either way, we can use the first item in the list</a>
<a name="ln1939">             */</a>
<a name="ln1940">            node_t *host_node = (node_t *) node-&gt;details-&gt;remote_rsc-&gt;running_on-&gt;data;</a>
<a name="ln1941"> </a>
<a name="ln1942">            if (host_node &amp;&amp; host_node-&gt;details) {</a>
<a name="ln1943">                node_host = host_node-&gt;details-&gt;uname;</a>
<a name="ln1944">            }</a>
<a name="ln1945">        }</a>
<a name="ln1946">        if (node_host == NULL) {</a>
<a name="ln1947">            node_host = &quot;&quot;; /* so we at least get &quot;uname@&quot; to indicate guest */</a>
<a name="ln1948">        }</a>
<a name="ln1949">    }</a>
<a name="ln1950"> </a>
<a name="ln1951">    /* Node ID is displayed if different from uname and detail is requested */</a>
<a name="ln1952">    if (print_clone_detail &amp;&amp; safe_str_neq(node-&gt;details-&gt;uname, node-&gt;details-&gt;id)) {</a>
<a name="ln1953">        node_id = node-&gt;details-&gt;id;</a>
<a name="ln1954">    }</a>
<a name="ln1955"> </a>
<a name="ln1956">    /* Determine name length */</a>
<a name="ln1957">    name_len = strlen(node-&gt;details-&gt;uname) + 1;</a>
<a name="ln1958">    if (node_host) {</a>
<a name="ln1959">        name_len += strlen(node_host) + 1; /* &quot;@node_host&quot; */</a>
<a name="ln1960">    }</a>
<a name="ln1961">    if (node_id) {</a>
<a name="ln1962">        name_len += strlen(node_id) + 3; /* + &quot; (node_id)&quot; */</a>
<a name="ln1963">    }</a>
<a name="ln1964"> </a>
<a name="ln1965">    /* Allocate and populate display name */</a>
<a name="ln1966">    node_name = malloc(name_len);</a>
<a name="ln1967">    CRM_ASSERT(node_name != NULL);</a>
<a name="ln1968">    strcpy(node_name, node-&gt;details-&gt;uname);</a>
<a name="ln1969">    if (node_host) {</a>
<a name="ln1970">        strcat(node_name, &quot;@&quot;);</a>
<a name="ln1971">        strcat(node_name, node_host);</a>
<a name="ln1972">    }</a>
<a name="ln1973">    if (node_id) {</a>
<a name="ln1974">        strcat(node_name, &quot; (&quot;);</a>
<a name="ln1975">        strcat(node_name, node_id);</a>
<a name="ln1976">        strcat(node_name, &quot;)&quot;);</a>
<a name="ln1977">    }</a>
<a name="ln1978">    return node_name;</a>
<a name="ln1979">}</a>
<a name="ln1980"> </a>
<a name="ln1981">/*!</a>
<a name="ln1982"> * \internal</a>
<a name="ln1983"> * \brief Print a negative location constraint</a>
<a name="ln1984"> *</a>
<a name="ln1985"> * \param[in] stream     File stream to display output to</a>
<a name="ln1986"> * \param[in] node       Node affected by constraint</a>
<a name="ln1987"> * \param[in] location   Constraint to print</a>
<a name="ln1988"> */</a>
<a name="ln1989">static void print_ban(FILE *stream, node_t *node, rsc_to_node_t *location)</a>
<a name="ln1990">{</a>
<a name="ln1991">    char *node_name = NULL;</a>
<a name="ln1992"> </a>
<a name="ln1993">    switch (output_format) {</a>
<a name="ln1994">        case mon_output_plain:</a>
<a name="ln1995">        case mon_output_console:</a>
<a name="ln1996">            node_name = get_node_display_name(node);</a>
<a name="ln1997">            print_as(&quot; %s\tprevents %s from running %son %s\n&quot;,</a>
<a name="ln1998">                     location-&gt;id, location-&gt;rsc_lh-&gt;id,</a>
<a name="ln1999">                     ((location-&gt;role_filter == RSC_ROLE_MASTER)? &quot;as Master &quot; : &quot;&quot;),</a>
<a name="ln2000">                     node_name);</a>
<a name="ln2001">            break;</a>
<a name="ln2002"> </a>
<a name="ln2003">        case mon_output_html:</a>
<a name="ln2004">        case mon_output_cgi:</a>
<a name="ln2005">            node_name = get_node_display_name(node);</a>
<a name="ln2006">            fprintf(stream, &quot;  &lt;li&gt;%s prevents %s from running %son %s&lt;/li&gt;\n&quot;,</a>
<a name="ln2007">                     location-&gt;id, location-&gt;rsc_lh-&gt;id,</a>
<a name="ln2008">                     ((location-&gt;role_filter == RSC_ROLE_MASTER)? &quot;as Master &quot; : &quot;&quot;),</a>
<a name="ln2009">                     node_name);</a>
<a name="ln2010">            break;</a>
<a name="ln2011"> </a>
<a name="ln2012">        case mon_output_xml:</a>
<a name="ln2013">            fprintf(stream,</a>
<a name="ln2014">                    &quot;        &lt;ban id=\&quot;%s\&quot; resource=\&quot;%s\&quot; node=\&quot;%s\&quot; weight=\&quot;%d\&quot; master_only=\&quot;%s\&quot; /&gt;\n&quot;,</a>
<a name="ln2015">                    location-&gt;id, location-&gt;rsc_lh-&gt;id, node-&gt;details-&gt;uname, node-&gt;weight,</a>
<a name="ln2016">                    ((location-&gt;role_filter == RSC_ROLE_MASTER)? &quot;true&quot; : &quot;false&quot;));</a>
<a name="ln2017">            break;</a>
<a name="ln2018"> </a>
<a name="ln2019">        default:</a>
<a name="ln2020">            break;</a>
<a name="ln2021">    }</a>
<a name="ln2022">    free(node_name);</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025">/*!</a>
<a name="ln2026"> * \internal</a>
<a name="ln2027"> * \brief Print section for negative location constraints</a>
<a name="ln2028"> *</a>
<a name="ln2029"> * \param[in] stream     File stream to display output to</a>
<a name="ln2030"> * \param[in] data_set   Working set corresponding to CIB status to display</a>
<a name="ln2031"> */</a>
<a name="ln2032">static void print_neg_locations(FILE *stream, pe_working_set_t *data_set)</a>
<a name="ln2033">{</a>
<a name="ln2034">    GListPtr gIter, gIter2;</a>
<a name="ln2035"> </a>
<a name="ln2036">    /* Print section heading */</a>
<a name="ln2037">    switch (output_format) {</a>
<a name="ln2038">        case mon_output_plain:</a>
<a name="ln2039">        case mon_output_console:</a>
<a name="ln2040">            print_as(&quot;\nNegative Location Constraints:\n&quot;);</a>
<a name="ln2041">            break;</a>
<a name="ln2042"> </a>
<a name="ln2043">        case mon_output_html:</a>
<a name="ln2044">        case mon_output_cgi:</a>
<a name="ln2045">            fprintf(stream, &quot; &lt;hr /&gt;\n &lt;h2&gt;Negative Location Constraints&lt;/h2&gt;\n &lt;ul&gt;\n&quot;);</a>
<a name="ln2046">            break;</a>
<a name="ln2047"> </a>
<a name="ln2048">        case mon_output_xml:</a>
<a name="ln2049">            fprintf(stream, &quot;    &lt;bans&gt;\n&quot;);</a>
<a name="ln2050">            break;</a>
<a name="ln2051"> </a>
<a name="ln2052">        default:</a>
<a name="ln2053">            break;</a>
<a name="ln2054">    }</a>
<a name="ln2055"> </a>
<a name="ln2056">    /* Print each ban */</a>
<a name="ln2057">    for (gIter = data_set-&gt;placement_constraints; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2058">        rsc_to_node_t *location = (rsc_to_node_t *) gIter-&gt;data;</a>
<a name="ln2059">        if (!g_str_has_prefix(location-&gt;id, print_neg_location_prefix))</a>
<a name="ln2060">            continue;</a>
<a name="ln2061">        for (gIter2 = location-&gt;node_list_rh; gIter2 != NULL; gIter2 = gIter2-&gt;next) {</a>
<a name="ln2062">            node_t *node = (node_t *) gIter2-&gt;data;</a>
<a name="ln2063"> </a>
<a name="ln2064">            if (node-&gt;weight &lt; 0) {</a>
<a name="ln2065">                print_ban(stream, node, location);</a>
<a name="ln2066">            }</a>
<a name="ln2067">        }</a>
<a name="ln2068">    }</a>
<a name="ln2069"> </a>
<a name="ln2070">    /* Close section */</a>
<a name="ln2071">    switch (output_format) {</a>
<a name="ln2072">        case mon_output_cgi:</a>
<a name="ln2073">        case mon_output_html:</a>
<a name="ln2074">            fprintf(stream, &quot; &lt;/ul&gt;\n&quot;);</a>
<a name="ln2075">            break;</a>
<a name="ln2076"> </a>
<a name="ln2077">        case mon_output_xml:</a>
<a name="ln2078">            fprintf(stream, &quot;    &lt;/bans&gt;\n&quot;);</a>
<a name="ln2079">            break;</a>
<a name="ln2080"> </a>
<a name="ln2081">        default:</a>
<a name="ln2082">            break;</a>
<a name="ln2083">    }</a>
<a name="ln2084">}</a>
<a name="ln2085"> </a>
<a name="ln2086">static void</a>
<a name="ln2087">crm_mon_get_parameters(resource_t *rsc, pe_working_set_t * data_set)</a>
<a name="ln2088">{</a>
<a name="ln2089">    get_rsc_attributes(rsc-&gt;parameters, rsc, NULL, data_set);</a>
<a name="ln2090">    crm_trace(&quot;Beekhof: unpacked params for %s (%d)&quot;, rsc-&gt;id, g_hash_table_size(rsc-&gt;parameters));</a>
<a name="ln2091">    if(rsc-&gt;children) {</a>
<a name="ln2092">        GListPtr gIter = NULL;</a>
<a name="ln2093"> </a>
<a name="ln2094">        for (gIter = rsc-&gt;children; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2095">            crm_mon_get_parameters(gIter-&gt;data, data_set);</a>
<a name="ln2096">        }</a>
<a name="ln2097">    }</a>
<a name="ln2098">}</a>
<a name="ln2099"> </a>
<a name="ln2100">/*!</a>
<a name="ln2101"> * \internal</a>
<a name="ln2102"> * \brief Print node attributes section</a>
<a name="ln2103"> *</a>
<a name="ln2104"> * \param[in] stream     File stream to display output to</a>
<a name="ln2105"> * \param[in] data_set   Working set of CIB state</a>
<a name="ln2106"> */</a>
<a name="ln2107">static void</a>
<a name="ln2108">print_node_attributes(FILE *stream, pe_working_set_t *data_set)</a>
<a name="ln2109">{</a>
<a name="ln2110">    GListPtr gIter = NULL;</a>
<a name="ln2111"> </a>
<a name="ln2112">    /* Print section heading */</a>
<a name="ln2113">    switch (output_format) {</a>
<a name="ln2114">        case mon_output_plain:</a>
<a name="ln2115">        case mon_output_console:</a>
<a name="ln2116">            print_as(&quot;\nNode Attributes:\n&quot;);</a>
<a name="ln2117">            break;</a>
<a name="ln2118"> </a>
<a name="ln2119">        case mon_output_html:</a>
<a name="ln2120">        case mon_output_cgi:</a>
<a name="ln2121">            fprintf(stream, &quot; &lt;hr /&gt;\n &lt;h2&gt;Node Attributes&lt;/h2&gt;\n&quot;);</a>
<a name="ln2122">            break;</a>
<a name="ln2123"> </a>
<a name="ln2124">        case mon_output_xml:</a>
<a name="ln2125">            fprintf(stream, &quot;    &lt;node_attributes&gt;\n&quot;);</a>
<a name="ln2126">            break;</a>
<a name="ln2127"> </a>
<a name="ln2128">        default:</a>
<a name="ln2129">            break;</a>
<a name="ln2130">    }</a>
<a name="ln2131"> </a>
<a name="ln2132">    /* Unpack all resource parameters (it would be more efficient to do this</a>
<a name="ln2133">     * only when needed for the first time in print_attr_msg())</a>
<a name="ln2134">     */</a>
<a name="ln2135">    for (gIter = data_set-&gt;resources; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2136">        crm_mon_get_parameters(gIter-&gt;data, data_set);</a>
<a name="ln2137">    }</a>
<a name="ln2138"> </a>
<a name="ln2139">    /* Display each node's attributes */</a>
<a name="ln2140">    for (gIter = data_set-&gt;nodes; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2141">        struct mon_attr_data data;</a>
<a name="ln2142"> </a>
<a name="ln2143">        data.stream = stream;</a>
<a name="ln2144">        data.node = (node_t *) gIter-&gt;data;</a>
<a name="ln2145"> </a>
<a name="ln2146">        if (data.node &amp;&amp; data.node-&gt;details &amp;&amp; data.node-&gt;details-&gt;online) {</a>
<a name="ln2147">            print_node_start(stream, data.node);</a>
<a name="ln2148">            g_hash_table_foreach(data.node-&gt;details-&gt;attrs, create_attr_list, NULL);</a>
<a name="ln2149">            g_list_foreach(attr_list, print_node_attribute, &amp;data);</a>
<a name="ln2150">            g_list_free(attr_list);</a>
<a name="ln2151">            attr_list = NULL;</a>
<a name="ln2152">            print_node_end(stream);</a>
<a name="ln2153">        }</a>
<a name="ln2154">    }</a>
<a name="ln2155"> </a>
<a name="ln2156">    /* Print section footer */</a>
<a name="ln2157">    switch (output_format) {</a>
<a name="ln2158">        case mon_output_xml:</a>
<a name="ln2159">            fprintf(stream, &quot;    &lt;/node_attributes&gt;\n&quot;);</a>
<a name="ln2160">            break;</a>
<a name="ln2161"> </a>
<a name="ln2162">        default:</a>
<a name="ln2163">            break;</a>
<a name="ln2164">    }</a>
<a name="ln2165">}</a>
<a name="ln2166"> </a>
<a name="ln2167">/*!</a>
<a name="ln2168"> * \internal</a>
<a name="ln2169"> * \brief Return resource display options corresponding to command-line choices</a>
<a name="ln2170"> *</a>
<a name="ln2171"> * \return Bitmask of pe_print_options suitable for resource print functions</a>
<a name="ln2172"> */</a>
<a name="ln2173">static int</a>
<a name="ln2174">get_resource_display_options(void)</a>
<a name="ln2175">{</a>
<a name="ln2176">    int print_opts;</a>
<a name="ln2177"> </a>
<a name="ln2178">    /* Determine basic output format */</a>
<a name="ln2179">    switch (output_format) {</a>
<a name="ln2180">        case mon_output_console:</a>
<a name="ln2181">            print_opts = pe_print_ncurses;</a>
<a name="ln2182">            break;</a>
<a name="ln2183">        case mon_output_html:</a>
<a name="ln2184">        case mon_output_cgi:</a>
<a name="ln2185">            print_opts = pe_print_html;</a>
<a name="ln2186">            break;</a>
<a name="ln2187">        case mon_output_xml:</a>
<a name="ln2188">            print_opts = pe_print_xml;</a>
<a name="ln2189">            break;</a>
<a name="ln2190">        default:</a>
<a name="ln2191">            print_opts = pe_print_printf;</a>
<a name="ln2192">            break;</a>
<a name="ln2193">    }</a>
<a name="ln2194"> </a>
<a name="ln2195">    /* Add optional display elements */</a>
<a name="ln2196">    if (print_pending) {</a>
<a name="ln2197">        print_opts |= pe_print_pending;</a>
<a name="ln2198">    }</a>
<a name="ln2199">    if (print_clone_detail) {</a>
<a name="ln2200">        print_opts |= pe_print_clone_details;</a>
<a name="ln2201">    }</a>
<a name="ln2202">    if (!inactive_resources) {</a>
<a name="ln2203">        print_opts |= pe_print_clone_active;</a>
<a name="ln2204">    }</a>
<a name="ln2205">    if (print_brief) {</a>
<a name="ln2206">        print_opts |= pe_print_brief;</a>
<a name="ln2207">    }</a>
<a name="ln2208">    return print_opts;</a>
<a name="ln2209">}</a>
<a name="ln2210"> </a>
<a name="ln2211">/*!</a>
<a name="ln2212"> * \internal</a>
<a name="ln2213"> * \brief Return human-friendly string representing current time</a>
<a name="ln2214"> *</a>
<a name="ln2215"> * \return Current time as string (as by ctime() but without newline) on success</a>
<a name="ln2216"> *         or &quot;Could not determine current time&quot; on error</a>
<a name="ln2217"> * \note The return value points to a statically allocated string which might be</a>
<a name="ln2218"> *       overwritten by subsequent calls to any of the C library date and time functions.</a>
<a name="ln2219"> */</a>
<a name="ln2220">static const char *</a>
<a name="ln2221">crm_now_string(void)</a>
<a name="ln2222">{</a>
<a name="ln2223">    time_t a_time = time(NULL);</a>
<a name="ln2224">    char *since_epoch = ctime(&amp;a_time);</a>
<a name="ln2225"> </a>
<a name="ln2226">    if ((a_time == (time_t) -1) || (since_epoch == NULL)) {</a>
<a name="ln2227">        return &quot;Could not determine current time&quot;;</a>
<a name="ln2228">    }</a>
<a name="ln2229">    since_epoch[strlen(since_epoch) - 1] = EOS; /* trim newline */</a>
<a name="ln2230">    return (since_epoch);</a>
<a name="ln2231">}</a>
<a name="ln2232"> </a>
<a name="ln2233">/*!</a>
<a name="ln2234"> * \internal</a>
<a name="ln2235"> * \brief Print header for cluster summary if needed</a>
<a name="ln2236"> *</a>
<a name="ln2237"> * \param[in] stream     File stream to display output to</a>
<a name="ln2238"> */</a>
<a name="ln2239">static void</a>
<a name="ln2240">print_cluster_summary_header(FILE *stream)</a>
<a name="ln2241">{</a>
<a name="ln2242">    switch (output_format) {</a>
<a name="ln2243">        case mon_output_html:</a>
<a name="ln2244">        case mon_output_cgi:</a>
<a name="ln2245">            fprintf(stream, &quot; &lt;h2&gt;Cluster Summary&lt;/h2&gt;\n &lt;p&gt;\n&quot;);</a>
<a name="ln2246">            break;</a>
<a name="ln2247"> </a>
<a name="ln2248">        case mon_output_xml:</a>
<a name="ln2249">            fprintf(stream, &quot;    &lt;summary&gt;\n&quot;);</a>
<a name="ln2250">            break;</a>
<a name="ln2251"> </a>
<a name="ln2252">        default:</a>
<a name="ln2253">            break;</a>
<a name="ln2254">    }</a>
<a name="ln2255">}</a>
<a name="ln2256"> </a>
<a name="ln2257">/*!</a>
<a name="ln2258"> * \internal</a>
<a name="ln2259"> * \brief Print footer for cluster summary if needed</a>
<a name="ln2260"> *</a>
<a name="ln2261"> * \param[in] stream     File stream to display output to</a>
<a name="ln2262"> */</a>
<a name="ln2263">static void</a>
<a name="ln2264">print_cluster_summary_footer(FILE *stream)</a>
<a name="ln2265">{</a>
<a name="ln2266">    switch (output_format) {</a>
<a name="ln2267">        case mon_output_cgi:</a>
<a name="ln2268">        case mon_output_html:</a>
<a name="ln2269">            fprintf(stream, &quot; &lt;/p&gt;\n&quot;);</a>
<a name="ln2270">            break;</a>
<a name="ln2271"> </a>
<a name="ln2272">        case mon_output_xml:</a>
<a name="ln2273">            fprintf(stream, &quot;    &lt;/summary&gt;\n&quot;);</a>
<a name="ln2274">            break;</a>
<a name="ln2275"> </a>
<a name="ln2276">        default:</a>
<a name="ln2277">            break;</a>
<a name="ln2278">    }</a>
<a name="ln2279">}</a>
<a name="ln2280"> </a>
<a name="ln2281">/*!</a>
<a name="ln2282"> * \internal</a>
<a name="ln2283"> * \brief Print times the display was last updated and CIB last changed</a>
<a name="ln2284"> *</a>
<a name="ln2285"> * \param[in] stream     File stream to display output to</a>
<a name="ln2286"> * \param[in] data_set   Working set of CIB state</a>
<a name="ln2287"> */</a>
<a name="ln2288">static void</a>
<a name="ln2289">print_cluster_times(FILE *stream, pe_working_set_t *data_set)</a>
<a name="ln2290">{</a>
<a name="ln2291">    const char *last_written = crm_element_value(data_set-&gt;input, XML_CIB_ATTR_WRITTEN);</a>
<a name="ln2292">    const char *user = crm_element_value(data_set-&gt;input, XML_ATTR_UPDATE_USER);</a>
<a name="ln2293">    const char *client = crm_element_value(data_set-&gt;input, XML_ATTR_UPDATE_CLIENT);</a>
<a name="ln2294">    const char *origin = crm_element_value(data_set-&gt;input, XML_ATTR_UPDATE_ORIG);</a>
<a name="ln2295"> </a>
<a name="ln2296">    switch (output_format) {</a>
<a name="ln2297">        case mon_output_plain:</a>
<a name="ln2298">        case mon_output_console:</a>
<a name="ln2299">            print_as(&quot;Last updated: %s&quot;, crm_now_string());</a>
<a name="ln2300">            print_as((user || client || origin)? &quot;\n&quot; : &quot;\t\t&quot;);</a>
<a name="ln2301">            print_as(&quot;Last change: %s&quot;, last_written ? last_written : &quot;&quot;);</a>
<a name="ln2302">            if (user) {</a>
<a name="ln2303">                print_as(&quot; by %s&quot;, user);</a>
<a name="ln2304">            }</a>
<a name="ln2305">            if (client) {</a>
<a name="ln2306">                print_as(&quot; via %s&quot;, client);</a>
<a name="ln2307">            }</a>
<a name="ln2308">            if (origin) {</a>
<a name="ln2309">                print_as(&quot; on %s&quot;, origin);</a>
<a name="ln2310">            }</a>
<a name="ln2311">            print_as(&quot;\n&quot;);</a>
<a name="ln2312">            break;</a>
<a name="ln2313"> </a>
<a name="ln2314">        case mon_output_html:</a>
<a name="ln2315">        case mon_output_cgi:</a>
<a name="ln2316">            fprintf(stream, &quot; &lt;b&gt;Last updated:&lt;/b&gt; %s&lt;br/&gt;\n&quot;, crm_now_string());</a>
<a name="ln2317">            fprintf(stream, &quot; &lt;b&gt;Last change:&lt;/b&gt; %s&quot;, last_written ? last_written : &quot;&quot;);</a>
<a name="ln2318">            if (user) {</a>
<a name="ln2319">                fprintf(stream, &quot; by %s&quot;, user);</a>
<a name="ln2320">            }</a>
<a name="ln2321">            if (client) {</a>
<a name="ln2322">                fprintf(stream, &quot; via %s&quot;, client);</a>
<a name="ln2323">            }</a>
<a name="ln2324">            if (origin) {</a>
<a name="ln2325">                fprintf(stream, &quot; on %s&quot;, origin);</a>
<a name="ln2326">            }</a>
<a name="ln2327">            fprintf(stream, &quot;&lt;br/&gt;\n&quot;);</a>
<a name="ln2328">            break;</a>
<a name="ln2329"> </a>
<a name="ln2330">        case mon_output_xml:</a>
<a name="ln2331">            fprintf(stream, &quot;        &lt;last_update time=\&quot;%s\&quot; /&gt;\n&quot;, crm_now_string());</a>
<a name="ln2332">            fprintf(stream, &quot;        &lt;last_change time=\&quot;%s\&quot; user=\&quot;%s\&quot; client=\&quot;%s\&quot; origin=\&quot;%s\&quot; /&gt;\n&quot;,</a>
<a name="ln2333">                    last_written ? last_written : &quot;&quot;, user ? user : &quot;&quot;,</a>
<a name="ln2334">                    client ? client : &quot;&quot;, origin ? origin : &quot;&quot;);</a>
<a name="ln2335">            break;</a>
<a name="ln2336"> </a>
<a name="ln2337">        default:</a>
<a name="ln2338">            break;</a>
<a name="ln2339">    }</a>
<a name="ln2340">}</a>
<a name="ln2341"> </a>
<a name="ln2342">/*!</a>
<a name="ln2343"> * \internal</a>
<a name="ln2344"> * \brief Print cluster stack</a>
<a name="ln2345"> *</a>
<a name="ln2346"> * \param[in] stream     File stream to display output to</a>
<a name="ln2347"> * \param[in] stack_s    Stack name</a>
<a name="ln2348"> */</a>
<a name="ln2349">static void</a>
<a name="ln2350">print_cluster_stack(FILE *stream, const char *stack_s)</a>
<a name="ln2351">{</a>
<a name="ln2352">    switch (output_format) {</a>
<a name="ln2353">        case mon_output_plain:</a>
<a name="ln2354">        case mon_output_console:</a>
<a name="ln2355">            print_as(&quot;Stack: %s\n&quot;, stack_s);</a>
<a name="ln2356">            break;</a>
<a name="ln2357"> </a>
<a name="ln2358">        case mon_output_html:</a>
<a name="ln2359">        case mon_output_cgi:</a>
<a name="ln2360">            fprintf(stream, &quot; &lt;b&gt;Stack:&lt;/b&gt; %s&lt;br/&gt;\n&quot;, stack_s);</a>
<a name="ln2361">            break;</a>
<a name="ln2362"> </a>
<a name="ln2363">        case mon_output_xml:</a>
<a name="ln2364">            fprintf(stream, &quot;        &lt;stack type=\&quot;%s\&quot; /&gt;\n&quot;, stack_s);</a>
<a name="ln2365">            break;</a>
<a name="ln2366"> </a>
<a name="ln2367">        default:</a>
<a name="ln2368">            break;</a>
<a name="ln2369">    }</a>
<a name="ln2370">}</a>
<a name="ln2371"> </a>
<a name="ln2372">/*!</a>
<a name="ln2373"> * \internal</a>
<a name="ln2374"> * \brief Print current DC and its version</a>
<a name="ln2375"> *</a>
<a name="ln2376"> * \param[in] stream     File stream to display output to</a>
<a name="ln2377"> * \param[in] data_set   Working set of CIB state</a>
<a name="ln2378"> */</a>
<a name="ln2379">static void</a>
<a name="ln2380">print_cluster_dc(FILE *stream, pe_working_set_t *data_set)</a>
<a name="ln2381">{</a>
<a name="ln2382">    node_t *dc = data_set-&gt;dc_node;</a>
<a name="ln2383">    xmlNode *dc_version = get_xpath_object(&quot;//nvpair[@name='dc-version']&quot;,</a>
<a name="ln2384">                                           data_set-&gt;input, LOG_DEBUG);</a>
<a name="ln2385">    const char *dc_version_s = dc_version?</a>
<a name="ln2386">                               crm_element_value(dc_version, XML_NVPAIR_ATTR_VALUE)</a>
<a name="ln2387">                               : NULL;</a>
<a name="ln2388">    const char *quorum = crm_element_value(data_set-&gt;input, XML_ATTR_HAVE_QUORUM);</a>
<a name="ln2389">    char *dc_name = dc? get_node_display_name(dc) : NULL;</a>
<a name="ln2390"> </a>
<a name="ln2391">    switch (output_format) {</a>
<a name="ln2392">        case mon_output_plain:</a>
<a name="ln2393">        case mon_output_console:</a>
<a name="ln2394">            print_as(&quot;Current DC: &quot;);</a>
<a name="ln2395">            if (dc) {</a>
<a name="ln2396">                print_as(&quot;%s (version %s) - partition %s quorum\n&quot;,</a>
<a name="ln2397">                         dc_name, (dc_version_s? dc_version_s : &quot;unknown&quot;),</a>
<a name="ln2398">                         (crm_is_true(quorum) ? &quot;with&quot; : &quot;WITHOUT&quot;));</a>
<a name="ln2399">            } else {</a>
<a name="ln2400">                print_as(&quot;NONE\n&quot;);</a>
<a name="ln2401">            }</a>
<a name="ln2402">            break;</a>
<a name="ln2403"> </a>
<a name="ln2404">        case mon_output_html:</a>
<a name="ln2405">        case mon_output_cgi:</a>
<a name="ln2406">            fprintf(stream, &quot; &lt;b&gt;Current DC:&lt;/b&gt; &quot;);</a>
<a name="ln2407">            if (dc) {</a>
<a name="ln2408">                fprintf(stream, &quot;%s (version %s) - partition %s quorum&quot;,</a>
<a name="ln2409">                        dc_name, (dc_version_s? dc_version_s : &quot;unknown&quot;),</a>
<a name="ln2410">                        (crm_is_true(quorum)? &quot;with&quot; : &quot;&lt;font color=\&quot;red\&quot;&gt;&lt;b&gt;WITHOUT&lt;/b&gt;&lt;/font&gt;&quot;));</a>
<a name="ln2411">            } else {</a>
<a name="ln2412">                fprintf(stream, &quot;&lt;font color=\&quot;red\&quot;&gt;&lt;b&gt;NONE&lt;/b&gt;&lt;/font&gt;&quot;);</a>
<a name="ln2413">            }</a>
<a name="ln2414">            fprintf(stream, &quot;&lt;br/&gt;\n&quot;);</a>
<a name="ln2415">            break;</a>
<a name="ln2416"> </a>
<a name="ln2417">        case mon_output_xml:</a>
<a name="ln2418">            fprintf(stream,  &quot;        &lt;current_dc &quot;);</a>
<a name="ln2419">            if (dc) {</a>
<a name="ln2420">                fprintf(stream,</a>
<a name="ln2421">                        &quot;present=\&quot;true\&quot; version=\&quot;%s\&quot; name=\&quot;%s\&quot; id=\&quot;%s\&quot; with_quorum=\&quot;%s\&quot;&quot;,</a>
<a name="ln2422">                        (dc_version_s? dc_version_s : &quot;&quot;), dc-&gt;details-&gt;uname, dc-&gt;details-&gt;id,</a>
<a name="ln2423">                        (crm_is_true(quorum) ? &quot;true&quot; : &quot;false&quot;));</a>
<a name="ln2424">            } else {</a>
<a name="ln2425">                fprintf(stream, &quot;present=\&quot;false\&quot;&quot;);</a>
<a name="ln2426">            }</a>
<a name="ln2427">            fprintf(stream, &quot; /&gt;\n&quot;);</a>
<a name="ln2428">            break;</a>
<a name="ln2429"> </a>
<a name="ln2430">        default:</a>
<a name="ln2431">            break;</a>
<a name="ln2432">    }</a>
<a name="ln2433">    free(dc_name);</a>
<a name="ln2434">}</a>
<a name="ln2435"> </a>
<a name="ln2436">/*!</a>
<a name="ln2437"> * \internal</a>
<a name="ln2438"> * \brief Print counts of configured nodes and resources</a>
<a name="ln2439"> *</a>
<a name="ln2440"> * \param[in] stream     File stream to display output to</a>
<a name="ln2441"> * \param[in] data_set   Working set of CIB state</a>
<a name="ln2442"> * \param[in] stack_s    Stack name</a>
<a name="ln2443"> */</a>
<a name="ln2444">static void</a>
<a name="ln2445">print_cluster_counts(FILE *stream, pe_working_set_t *data_set, const char *stack_s)</a>
<a name="ln2446">{</a>
<a name="ln2447">    int nnodes = g_list_length(data_set-&gt;nodes);</a>
<a name="ln2448">    int nresources = count_resources(data_set, NULL);</a>
<a name="ln2449">    xmlNode *quorum_node = get_xpath_object(&quot;//nvpair[@name='&quot; XML_ATTR_EXPECTED_VOTES &quot;']&quot;,</a>
<a name="ln2450">                                            data_set-&gt;input, LOG_DEBUG);</a>
<a name="ln2451">    const char *quorum_votes = quorum_node?</a>
<a name="ln2452">                               crm_element_value(quorum_node, XML_NVPAIR_ATTR_VALUE)</a>
<a name="ln2453">                               : &quot;unknown&quot;;</a>
<a name="ln2454"> </a>
<a name="ln2455">    switch (output_format) {</a>
<a name="ln2456">        case mon_output_plain:</a>
<a name="ln2457">        case mon_output_console:</a>
<a name="ln2458"> </a>
<a name="ln2459">            print_as(&quot;\n%d node%s configured&quot;, nnodes, s_if_plural(nnodes));</a>
<a name="ln2460">            if (stack_s &amp;&amp; strstr(stack_s, &quot;classic openais&quot;) != NULL) {</a>
<a name="ln2461">                print_as(&quot; (%s expected votes)&quot;, quorum_votes);</a>
<a name="ln2462">            }</a>
<a name="ln2463">            print_as(&quot;\n&quot;);</a>
<a name="ln2464"> </a>
<a name="ln2465">            print_as(&quot;%d resource%s configured&quot;,</a>
<a name="ln2466">                     nresources, s_if_plural(nresources));</a>
<a name="ln2467">            if(data_set-&gt;disabled_resources || data_set-&gt;blocked_resources) {</a>
<a name="ln2468">                print_as(&quot; (&quot;);</a>
<a name="ln2469">                if (data_set-&gt;disabled_resources) {</a>
<a name="ln2470">                    print_as(&quot;%d DISABLED&quot;, data_set-&gt;disabled_resources);</a>
<a name="ln2471">                }</a>
<a name="ln2472">                if (data_set-&gt;disabled_resources &amp;&amp; data_set-&gt;blocked_resources) {</a>
<a name="ln2473">                    print_as(&quot;, &quot;);</a>
<a name="ln2474">                }</a>
<a name="ln2475">                if (data_set-&gt;blocked_resources) {</a>
<a name="ln2476">                    print_as(&quot;%d BLOCKED from starting due to failure&quot;,</a>
<a name="ln2477">                             data_set-&gt;blocked_resources);</a>
<a name="ln2478">                }</a>
<a name="ln2479">                print_as(&quot;)&quot;);</a>
<a name="ln2480">            }</a>
<a name="ln2481">            print_as(&quot;\n&quot;);</a>
<a name="ln2482"> </a>
<a name="ln2483">            break;</a>
<a name="ln2484"> </a>
<a name="ln2485">        case mon_output_html:</a>
<a name="ln2486">        case mon_output_cgi:</a>
<a name="ln2487"> </a>
<a name="ln2488">            fprintf(stream, &quot; %d node%s configured&quot;, nnodes, s_if_plural(nnodes));</a>
<a name="ln2489">            if (stack_s &amp;&amp; strstr(stack_s, &quot;classic openais&quot;) != NULL) {</a>
<a name="ln2490">                fprintf(stream, &quot; (%s expected votes)&quot;, quorum_votes);</a>
<a name="ln2491">            }</a>
<a name="ln2492">            fprintf(stream, &quot;&lt;br/&gt;\n&quot;);</a>
<a name="ln2493"> </a>
<a name="ln2494">            fprintf(stream, &quot; %d resource%s configured&quot;,</a>
<a name="ln2495">                    nresources, s_if_plural(nresources));</a>
<a name="ln2496">            if (data_set-&gt;disabled_resources || data_set-&gt;blocked_resources) {</a>
<a name="ln2497">                fprintf(stream, &quot; (&quot;);</a>
<a name="ln2498">                if (data_set-&gt;disabled_resources) {</a>
<a name="ln2499">                    fprintf(stream, &quot;%d &lt;strong&gt;DISABLED&lt;/strong&gt;&quot;,</a>
<a name="ln2500">                            data_set-&gt;disabled_resources);</a>
<a name="ln2501">                }</a>
<a name="ln2502">                if (data_set-&gt;disabled_resources &amp;&amp; data_set-&gt;blocked_resources) {</a>
<a name="ln2503">                    fprintf(stream, &quot;, &quot;);</a>
<a name="ln2504">                }</a>
<a name="ln2505">                if (data_set-&gt;blocked_resources) {</a>
<a name="ln2506">                    fprintf(stream,</a>
<a name="ln2507">                            &quot;%d &lt;strong&gt;BLOCKED&lt;/strong&gt; from starting due to failure&quot;,</a>
<a name="ln2508">                            data_set-&gt;blocked_resources);</a>
<a name="ln2509">                }</a>
<a name="ln2510">                fprintf(stream, &quot;)&quot;);</a>
<a name="ln2511">            }</a>
<a name="ln2512">            fprintf(stream, &quot;&lt;br/&gt;\n&quot;);</a>
<a name="ln2513">            break;</a>
<a name="ln2514"> </a>
<a name="ln2515">        case mon_output_xml:</a>
<a name="ln2516">            fprintf(stream,</a>
<a name="ln2517">                    &quot;        &lt;nodes_configured number=\&quot;%d\&quot; expected_votes=\&quot;%s\&quot; /&gt;\n&quot;,</a>
<a name="ln2518">                    g_list_length(data_set-&gt;nodes), quorum_votes);</a>
<a name="ln2519">            fprintf(stream,</a>
<a name="ln2520">                    &quot;        &lt;resources_configured number=\&quot;%d\&quot; disabled=\&quot;%d\&quot; blocked=\&quot;%d\&quot; /&gt;\n&quot;,</a>
<a name="ln2521">                    count_resources(data_set, NULL),</a>
<a name="ln2522">                    data_set-&gt;disabled_resources, data_set-&gt;blocked_resources);</a>
<a name="ln2523">            break;</a>
<a name="ln2524"> </a>
<a name="ln2525">        default:</a>
<a name="ln2526">            break;</a>
<a name="ln2527">    }</a>
<a name="ln2528">}</a>
<a name="ln2529"> </a>
<a name="ln2530">/*!</a>
<a name="ln2531"> * \internal</a>
<a name="ln2532"> * \brief Print cluster-wide options</a>
<a name="ln2533"> *</a>
<a name="ln2534"> * \param[in] stream     File stream to display output to</a>
<a name="ln2535"> * \param[in] data_set   Working set of CIB state</a>
<a name="ln2536"> *</a>
<a name="ln2537"> * \note Currently this is only implemented for HTML and XML output, and</a>
<a name="ln2538"> *       prints only a few options. If there is demand, more could be added.</a>
<a name="ln2539"> */</a>
<a name="ln2540">static void</a>
<a name="ln2541">print_cluster_options(FILE *stream, pe_working_set_t *data_set)</a>
<a name="ln2542">{</a>
<a name="ln2543">    switch (output_format) {</a>
<a name="ln2544">        case mon_output_plain:</a>
<a name="ln2545">        case mon_output_console:</a>
<a name="ln2546">            if (is_set(data_set-&gt;flags, pe_flag_maintenance_mode)) {</a>
<a name="ln2547">                print_as(&quot;\n              *** Resource management is DISABLED ***&quot;);</a>
<a name="ln2548">                print_as(&quot;\n  The cluster will not attempt to start, stop or recover services&quot;);</a>
<a name="ln2549">                print_as(&quot;\n&quot;);</a>
<a name="ln2550">            }</a>
<a name="ln2551">            break;</a>
<a name="ln2552"> </a>
<a name="ln2553">        case mon_output_html:</a>
<a name="ln2554">            fprintf(stream, &quot; &lt;/p&gt;\n &lt;h3&gt;Config Options&lt;/h3&gt;\n&quot;);</a>
<a name="ln2555">            fprintf(stream, &quot; &lt;table&gt;\n&quot;);</a>
<a name="ln2556">            fprintf(stream, &quot;  &lt;tr&gt;&lt;th&gt;STONITH of failed nodes&lt;/th&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;\n&quot;,</a>
<a name="ln2557">                    is_set(data_set-&gt;flags, pe_flag_stonith_enabled)? &quot;enabled&quot; : &quot;disabled&quot;);</a>
<a name="ln2558"> </a>
<a name="ln2559">            fprintf(stream, &quot;  &lt;tr&gt;&lt;th&gt;Cluster is&lt;/th&gt;&lt;td&gt;%ssymmetric&lt;/td&gt;&lt;/tr&gt;\n&quot;,</a>
<a name="ln2560">                    is_set(data_set-&gt;flags, pe_flag_symmetric_cluster)? &quot;&quot; : &quot;a&quot;);</a>
<a name="ln2561"> </a>
<a name="ln2562">            fprintf(stream, &quot;  &lt;tr&gt;&lt;th&gt;No Quorum Policy&lt;/th&gt;&lt;td&gt;&quot;);</a>
<a name="ln2563">            switch (data_set-&gt;no_quorum_policy) {</a>
<a name="ln2564">                case no_quorum_freeze:</a>
<a name="ln2565">                    fprintf(stream, &quot;Freeze resources&quot;);</a>
<a name="ln2566">                    break;</a>
<a name="ln2567">                case no_quorum_stop:</a>
<a name="ln2568">                    fprintf(stream, &quot;Stop ALL resources&quot;);</a>
<a name="ln2569">                    break;</a>
<a name="ln2570">                case no_quorum_ignore:</a>
<a name="ln2571">                    fprintf(stream, &quot;Ignore&quot;);</a>
<a name="ln2572">                    break;</a>
<a name="ln2573">                case no_quorum_suicide:</a>
<a name="ln2574">                    fprintf(stream, &quot;Suicide&quot;);</a>
<a name="ln2575">                    break;</a>
<a name="ln2576">            }</a>
<a name="ln2577">            fprintf(stream, &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);</a>
<a name="ln2578"> </a>
<a name="ln2579">            fprintf(stream, &quot;  &lt;tr&gt;&lt;th&gt;Resource management&lt;/th&gt;&lt;td&gt;&quot;);</a>
<a name="ln2580">            if (is_set(data_set-&gt;flags, pe_flag_maintenance_mode)) {</a>
<a name="ln2581">                fprintf(stream, &quot;&lt;strong&gt;DISABLED&lt;/strong&gt; (the cluster will &quot;</a>
<a name="ln2582">                                &quot;not attempt to start, stop or recover services)&quot;);</a>
<a name="ln2583">            } else {</a>
<a name="ln2584">                fprintf(stream, &quot;enabled&quot;);</a>
<a name="ln2585">            }</a>
<a name="ln2586">            fprintf(stream, &quot;&lt;/td&gt;&lt;/tr&gt;\n&quot;);</a>
<a name="ln2587"> </a>
<a name="ln2588">            fprintf(stream, &quot;&lt;/table&gt;\n &lt;p&gt;\n&quot;);</a>
<a name="ln2589">            break;</a>
<a name="ln2590"> </a>
<a name="ln2591">        case mon_output_xml:</a>
<a name="ln2592">            fprintf(stream, &quot;        &lt;cluster_options&quot;);</a>
<a name="ln2593">            fprintf(stream, &quot; stonith-enabled=\&quot;%s\&quot;&quot;,</a>
<a name="ln2594">                    is_set(data_set-&gt;flags, pe_flag_stonith_enabled)?</a>
<a name="ln2595">                    &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln2596">            fprintf(stream, &quot; symmetric-cluster=\&quot;%s\&quot;&quot;,</a>
<a name="ln2597">                    is_set(data_set-&gt;flags, pe_flag_symmetric_cluster)?</a>
<a name="ln2598">                    &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln2599">            fprintf(stream, &quot; no-quorum-policy=\&quot;&quot;);</a>
<a name="ln2600">            switch (data_set-&gt;no_quorum_policy) {</a>
<a name="ln2601">                case no_quorum_freeze:</a>
<a name="ln2602">                    fprintf(stream, &quot;freeze&quot;);</a>
<a name="ln2603">                    break;</a>
<a name="ln2604">                case no_quorum_stop:</a>
<a name="ln2605">                    fprintf(stream, &quot;stop&quot;);</a>
<a name="ln2606">                    break;</a>
<a name="ln2607">                case no_quorum_ignore:</a>
<a name="ln2608">                    fprintf(stream, &quot;ignore&quot;);</a>
<a name="ln2609">                    break;</a>
<a name="ln2610">                case no_quorum_suicide:</a>
<a name="ln2611">                    fprintf(stream, &quot;suicide&quot;);</a>
<a name="ln2612">                    break;</a>
<a name="ln2613">            }</a>
<a name="ln2614">            fprintf(stream, &quot;\&quot;&quot;);</a>
<a name="ln2615">            fprintf(stream, &quot; maintenance-mode=\&quot;%s\&quot;&quot;,</a>
<a name="ln2616">                    is_set(data_set-&gt;flags, pe_flag_maintenance_mode)?</a>
<a name="ln2617">                    &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln2618">            fprintf(stream, &quot; /&gt;\n&quot;);</a>
<a name="ln2619">            break;</a>
<a name="ln2620"> </a>
<a name="ln2621">        default:</a>
<a name="ln2622">            break;</a>
<a name="ln2623">    }</a>
<a name="ln2624">}</a>
<a name="ln2625"> </a>
<a name="ln2626">/*!</a>
<a name="ln2627"> * \internal</a>
<a name="ln2628"> * \brief Get the name of the stack in use (or &quot;unknown&quot; if not available)</a>
<a name="ln2629"> *</a>
<a name="ln2630"> * \param[in] data_set   Working set of CIB state</a>
<a name="ln2631"> *</a>
<a name="ln2632"> * \return String representing stack name</a>
<a name="ln2633"> */</a>
<a name="ln2634">static const char *</a>
<a name="ln2635">get_cluster_stack(pe_working_set_t *data_set)</a>
<a name="ln2636">{</a>
<a name="ln2637">    xmlNode *stack = get_xpath_object(&quot;//nvpair[@name='cluster-infrastructure']&quot;,</a>
<a name="ln2638">                                      data_set-&gt;input, LOG_DEBUG);</a>
<a name="ln2639">    return stack? crm_element_value(stack, XML_NVPAIR_ATTR_VALUE) : &quot;unknown&quot;;</a>
<a name="ln2640">}</a>
<a name="ln2641"> </a>
<a name="ln2642">/*!</a>
<a name="ln2643"> * \internal</a>
<a name="ln2644"> * \brief Print a summary of cluster-wide information</a>
<a name="ln2645"> *</a>
<a name="ln2646"> * \param[in] stream     File stream to display output to</a>
<a name="ln2647"> * \param[in] data_set   Working set of CIB state</a>
<a name="ln2648"> */</a>
<a name="ln2649">static void</a>
<a name="ln2650">print_cluster_summary(FILE *stream, pe_working_set_t *data_set)</a>
<a name="ln2651">{</a>
<a name="ln2652">    const char *stack_s = get_cluster_stack(data_set);</a>
<a name="ln2653">    gboolean header_printed = FALSE;</a>
<a name="ln2654"> </a>
<a name="ln2655">    if (show &amp; mon_show_stack) {</a>
<a name="ln2656">        if (header_printed == FALSE) {</a>
<a name="ln2657">            print_cluster_summary_header(stream);</a>
<a name="ln2658">            header_printed = TRUE;</a>
<a name="ln2659">        }</a>
<a name="ln2660">        print_cluster_stack(stream, stack_s);</a>
<a name="ln2661">    }</a>
<a name="ln2662"> </a>
<a name="ln2663">    /* Always print DC if none, even if not requested */</a>
<a name="ln2664">    if ((data_set-&gt;dc_node == NULL) || (show &amp; mon_show_dc)) {</a>
<a name="ln2665">        if (header_printed == FALSE) {</a>
<a name="ln2666">            print_cluster_summary_header(stream);</a>
<a name="ln2667">            header_printed = TRUE;</a>
<a name="ln2668">        }</a>
<a name="ln2669">        print_cluster_dc(stream, data_set);</a>
<a name="ln2670">    }</a>
<a name="ln2671"> </a>
<a name="ln2672">    if (show &amp; mon_show_times) {</a>
<a name="ln2673">        if (header_printed == FALSE) {</a>
<a name="ln2674">            print_cluster_summary_header(stream);</a>
<a name="ln2675">            header_printed = TRUE;</a>
<a name="ln2676">        }</a>
<a name="ln2677">        print_cluster_times(stream, data_set);</a>
<a name="ln2678">    }</a>
<a name="ln2679"> </a>
<a name="ln2680">    if (is_set(data_set-&gt;flags, pe_flag_maintenance_mode)</a>
<a name="ln2681">        || data_set-&gt;disabled_resources</a>
<a name="ln2682">        || data_set-&gt;blocked_resources</a>
<a name="ln2683">        || is_set(show, mon_show_count)) {</a>
<a name="ln2684">        if (header_printed == FALSE) {</a>
<a name="ln2685">            print_cluster_summary_header(stream);</a>
<a name="ln2686">            header_printed = TRUE;</a>
<a name="ln2687">        }</a>
<a name="ln2688">        print_cluster_counts(stream, data_set, stack_s);</a>
<a name="ln2689">    }</a>
<a name="ln2690"> </a>
<a name="ln2691">    /* There is not a separate option for showing cluster options, so show with</a>
<a name="ln2692">     * stack for now; a separate option could be added if there is demand</a>
<a name="ln2693">     */</a>
<a name="ln2694">    if (show &amp; mon_show_stack) {</a>
<a name="ln2695">        print_cluster_options(stream, data_set);</a>
<a name="ln2696">    }</a>
<a name="ln2697"> </a>
<a name="ln2698">    if (header_printed) {</a>
<a name="ln2699">        print_cluster_summary_footer(stream);</a>
<a name="ln2700">    }</a>
<a name="ln2701">}</a>
<a name="ln2702"> </a>
<a name="ln2703">/*!</a>
<a name="ln2704"> * \internal</a>
<a name="ln2705"> * \brief Print a failed action</a>
<a name="ln2706"> *</a>
<a name="ln2707"> * \param[in] stream     File stream to display output to</a>
<a name="ln2708"> * \param[in] xml_op     Root of XML tree describing failed action</a>
<a name="ln2709"> */</a>
<a name="ln2710">static void</a>
<a name="ln2711">print_failed_action(FILE *stream, xmlNode *xml_op)</a>
<a name="ln2712">{</a>
<a name="ln2713">    const char *op_key = crm_element_value(xml_op, XML_LRM_ATTR_TASK_KEY);</a>
<a name="ln2714">    const char *op_key_attr = &quot;op_key&quot;;</a>
<a name="ln2715">    const char *last = crm_element_value(xml_op, XML_RSC_OP_LAST_CHANGE);</a>
<a name="ln2716">    const char *node = crm_element_value(xml_op, XML_ATTR_UNAME);</a>
<a name="ln2717">    const char *call = crm_element_value(xml_op, XML_LRM_ATTR_CALLID);</a>
<a name="ln2718">    const char *exit_reason = crm_element_value(xml_op, XML_LRM_ATTR_EXIT_REASON);</a>
<a name="ln2719">    int rc = crm_parse_int(crm_element_value(xml_op, XML_LRM_ATTR_RC), &quot;0&quot;);</a>
<a name="ln2720">    int status = crm_parse_int(crm_element_value(xml_op, XML_LRM_ATTR_OPSTATUS), &quot;0&quot;);</a>
<a name="ln2721">    char *exit_reason_cleaned;</a>
<a name="ln2722"> </a>
<a name="ln2723">    /* If no op_key was given, use id instead */</a>
<a name="ln2724">    if (op_key == NULL) {</a>
<a name="ln2725">        op_key = ID(xml_op);</a>
<a name="ln2726">        op_key_attr = &quot;id&quot;;</a>
<a name="ln2727">    }</a>
<a name="ln2728"> </a>
<a name="ln2729">    /* If no exit reason was given, use &quot;none&quot; */</a>
<a name="ln2730">    if (exit_reason == NULL) {</a>
<a name="ln2731">        exit_reason = &quot;none&quot;;</a>
<a name="ln2732">    }</a>
<a name="ln2733"> </a>
<a name="ln2734">    /* Print common action information */</a>
<a name="ln2735">    switch (output_format) {</a>
<a name="ln2736">        case mon_output_plain:</a>
<a name="ln2737">        case mon_output_console:</a>
<a name="ln2738">            print_as(&quot;* %s on %s '%s' (%d): call=%s, status=%s, exitreason='%s'&quot;,</a>
<a name="ln2739">                     op_key, node, services_ocf_exitcode_str(rc), rc,</a>
<a name="ln2740">                     call, services_lrm_status_str(status), exit_reason);</a>
<a name="ln2741">            break;</a>
<a name="ln2742"> </a>
<a name="ln2743">        case mon_output_html:</a>
<a name="ln2744">        case mon_output_cgi:</a>
<a name="ln2745">            fprintf(stream, &quot;  &lt;li&gt;%s on %s '%s' (%d): call=%s, status=%s, exitreason='%s'&quot;,</a>
<a name="ln2746">                     op_key, node, services_ocf_exitcode_str(rc), rc,</a>
<a name="ln2747">                     call, services_lrm_status_str(status), exit_reason);</a>
<a name="ln2748">            break;</a>
<a name="ln2749"> </a>
<a name="ln2750">        case mon_output_xml:</a>
<a name="ln2751">            exit_reason_cleaned = crm_xml_escape(exit_reason);</a>
<a name="ln2752">            fprintf(stream, &quot;        &lt;failure %s=\&quot;%s\&quot; node=\&quot;%s\&quot;&quot;,</a>
<a name="ln2753">                    op_key_attr, op_key, node);</a>
<a name="ln2754">            fprintf(stream, &quot; exitstatus=\&quot;%s\&quot; exitreason=\&quot;%s\&quot; exitcode=\&quot;%d\&quot;&quot;,</a>
<a name="ln2755">                    services_ocf_exitcode_str(rc), exit_reason_cleaned, rc);</a>
<a name="ln2756">            fprintf(stream, &quot; call=\&quot;%s\&quot; status=\&quot;%s\&quot;&quot;,</a>
<a name="ln2757">                    call, services_lrm_status_str(status));</a>
<a name="ln2758">            free(exit_reason_cleaned);</a>
<a name="ln2759">            break;</a>
<a name="ln2760"> </a>
<a name="ln2761">        default:</a>
<a name="ln2762">            break;</a>
<a name="ln2763">    }</a>
<a name="ln2764"> </a>
<a name="ln2765">    /* If last change was given, print timing information as well */</a>
<a name="ln2766">    if (last) {</a>
<a name="ln2767">        time_t run_at = crm_parse_int(last, &quot;0&quot;);</a>
<a name="ln2768">        char *run_at_s = ctime(&amp;run_at);</a>
<a name="ln2769"> </a>
<a name="ln2770">        if (run_at_s) {</a>
<a name="ln2771">            run_at_s[24] = 0; /* Overwrite the newline */</a>
<a name="ln2772">        }</a>
<a name="ln2773"> </a>
<a name="ln2774">        switch (output_format) {</a>
<a name="ln2775">            case mon_output_plain:</a>
<a name="ln2776">            case mon_output_console:</a>
<a name="ln2777">                print_as(&quot;,\n    last-rc-change='%s', queued=%sms, exec=%sms&quot;,</a>
<a name="ln2778">                         run_at_s? run_at_s : &quot;&quot;,</a>
<a name="ln2779">                         crm_element_value(xml_op, XML_RSC_OP_T_QUEUE),</a>
<a name="ln2780">                         crm_element_value(xml_op, XML_RSC_OP_T_EXEC));</a>
<a name="ln2781">                break;</a>
<a name="ln2782"> </a>
<a name="ln2783">            case mon_output_html:</a>
<a name="ln2784">            case mon_output_cgi:</a>
<a name="ln2785">                fprintf(stream, &quot; last-rc-change='%s', queued=%sms, exec=%sms&quot;,</a>
<a name="ln2786">                        run_at_s? run_at_s : &quot;&quot;,</a>
<a name="ln2787">                        crm_element_value(xml_op, XML_RSC_OP_T_QUEUE),</a>
<a name="ln2788">                        crm_element_value(xml_op, XML_RSC_OP_T_EXEC));</a>
<a name="ln2789">                break;</a>
<a name="ln2790"> </a>
<a name="ln2791">            case mon_output_xml:</a>
<a name="ln2792">                fprintf(stream,</a>
<a name="ln2793">                        &quot; last-rc-change=\&quot;%s\&quot; queued=\&quot;%s\&quot; exec=\&quot;%s\&quot; interval=\&quot;%d\&quot; task=\&quot;%s\&quot;&quot;,</a>
<a name="ln2794">                        run_at_s? run_at_s : &quot;&quot;,</a>
<a name="ln2795">                        crm_element_value(xml_op, XML_RSC_OP_T_QUEUE),</a>
<a name="ln2796">                        crm_element_value(xml_op, XML_RSC_OP_T_EXEC),</a>
<a name="ln2797">                        crm_parse_int(crm_element_value(xml_op, XML_LRM_ATTR_INTERVAL), &quot;0&quot;),</a>
<a name="ln2798">                        crm_element_value(xml_op, XML_LRM_ATTR_TASK));</a>
<a name="ln2799">                break;</a>
<a name="ln2800"> </a>
<a name="ln2801">            default:</a>
<a name="ln2802">                break;</a>
<a name="ln2803">        }</a>
<a name="ln2804">    }</a>
<a name="ln2805"> </a>
<a name="ln2806">    /* End the action listing */</a>
<a name="ln2807">    switch (output_format) {</a>
<a name="ln2808">        case mon_output_plain:</a>
<a name="ln2809">        case mon_output_console:</a>
<a name="ln2810">            print_as(&quot;\n&quot;);</a>
<a name="ln2811">            break;</a>
<a name="ln2812"> </a>
<a name="ln2813">        case mon_output_html:</a>
<a name="ln2814">        case mon_output_cgi:</a>
<a name="ln2815">            fprintf(stream, &quot;&lt;/li&gt;\n&quot;);</a>
<a name="ln2816">            break;</a>
<a name="ln2817"> </a>
<a name="ln2818">        case mon_output_xml:</a>
<a name="ln2819">            fprintf(stream, &quot; /&gt;\n&quot;);</a>
<a name="ln2820">            break;</a>
<a name="ln2821"> </a>
<a name="ln2822">        default:</a>
<a name="ln2823">            break;</a>
<a name="ln2824">    }</a>
<a name="ln2825">}</a>
<a name="ln2826"> </a>
<a name="ln2827">/*!</a>
<a name="ln2828"> * \internal</a>
<a name="ln2829"> * \brief Print a section for failed actions</a>
<a name="ln2830"> *</a>
<a name="ln2831"> * \param[in] stream     File stream to display output to</a>
<a name="ln2832"> * \param[in] data_set   Working set of CIB state</a>
<a name="ln2833"> */</a>
<a name="ln2834">static void</a>
<a name="ln2835">print_failed_actions(FILE *stream, pe_working_set_t *data_set)</a>
<a name="ln2836">{</a>
<a name="ln2837">    xmlNode *xml_op = NULL;</a>
<a name="ln2838"> </a>
<a name="ln2839">    /* Print section heading */</a>
<a name="ln2840">    switch (output_format) {</a>
<a name="ln2841">        case mon_output_plain:</a>
<a name="ln2842">        case mon_output_console:</a>
<a name="ln2843">            print_as(&quot;\nFailed Actions:\n&quot;);</a>
<a name="ln2844">            break;</a>
<a name="ln2845"> </a>
<a name="ln2846">        case mon_output_html:</a>
<a name="ln2847">        case mon_output_cgi:</a>
<a name="ln2848">            fprintf(stream, &quot; &lt;hr /&gt;\n &lt;h2&gt;Failed Actions&lt;/h2&gt;\n &lt;ul&gt;\n&quot;);</a>
<a name="ln2849">            break;</a>
<a name="ln2850"> </a>
<a name="ln2851">        case mon_output_xml:</a>
<a name="ln2852">            fprintf(stream, &quot;    &lt;failures&gt;\n&quot;);</a>
<a name="ln2853">            break;</a>
<a name="ln2854"> </a>
<a name="ln2855">        default:</a>
<a name="ln2856">            break;</a>
<a name="ln2857">    }</a>
<a name="ln2858"> </a>
<a name="ln2859">    /* Print each failed action */</a>
<a name="ln2860">    for (xml_op = __xml_first_child(data_set-&gt;failed); xml_op != NULL;</a>
<a name="ln2861">         xml_op = __xml_next(xml_op)) {</a>
<a name="ln2862">        print_failed_action(stream, xml_op);</a>
<a name="ln2863">    }</a>
<a name="ln2864"> </a>
<a name="ln2865">    /* End section */</a>
<a name="ln2866">    switch (output_format) {</a>
<a name="ln2867">        case mon_output_plain:</a>
<a name="ln2868">        case mon_output_console:</a>
<a name="ln2869">            print_as(&quot;\n&quot;);</a>
<a name="ln2870">            break;</a>
<a name="ln2871"> </a>
<a name="ln2872">        case mon_output_html:</a>
<a name="ln2873">        case mon_output_cgi:</a>
<a name="ln2874">            fprintf(stream, &quot; &lt;/ul&gt;\n&quot;);</a>
<a name="ln2875">            break;</a>
<a name="ln2876"> </a>
<a name="ln2877">        case mon_output_xml:</a>
<a name="ln2878">            fprintf(stream, &quot;    &lt;/failures&gt;\n&quot;);</a>
<a name="ln2879">            break;</a>
<a name="ln2880"> </a>
<a name="ln2881">        default:</a>
<a name="ln2882">            break;</a>
<a name="ln2883">    }</a>
<a name="ln2884">}</a>
<a name="ln2885"> </a>
<a name="ln2886">/*!</a>
<a name="ln2887"> * \internal</a>
<a name="ln2888"> * \brief Print cluster status to screen</a>
<a name="ln2889"> *</a>
<a name="ln2890"> * This uses the global display preferences set by command-line options</a>
<a name="ln2891"> * to display cluster status in a human-friendly way.</a>
<a name="ln2892"> *</a>
<a name="ln2893"> * \param[in] data_set   Working set of CIB state</a>
<a name="ln2894"> */</a>
<a name="ln2895">static void</a>
<a name="ln2896">print_status(pe_working_set_t * data_set)</a>
<a name="ln2897">{</a>
<a name="ln2898">    GListPtr gIter = NULL;</a>
<a name="ln2899">    int print_opts = get_resource_display_options();</a>
<a name="ln2900"> </a>
<a name="ln2901">    /* space-separated lists of node names */</a>
<a name="ln2902">    char *online_nodes = NULL;</a>
<a name="ln2903">    char *online_remote_nodes = NULL;</a>
<a name="ln2904">    char *online_guest_nodes = NULL;</a>
<a name="ln2905">    char *offline_nodes = NULL;</a>
<a name="ln2906">    char *offline_remote_nodes = NULL;</a>
<a name="ln2907"> </a>
<a name="ln2908">    if (output_format == mon_output_console) {</a>
<a name="ln2909">        blank_screen();</a>
<a name="ln2910">    }</a>
<a name="ln2911">    print_cluster_summary(stdout, data_set);</a>
<a name="ln2912">    print_as(&quot;\n&quot;);</a>
<a name="ln2913"> </a>
<a name="ln2914">    /* Gather node information (and print if in bad state or grouping by node) */</a>
<a name="ln2915">    for (gIter = data_set-&gt;nodes; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2916">        node_t *node = (node_t *) gIter-&gt;data;</a>
<a name="ln2917">        const char *node_mode = NULL;</a>
<a name="ln2918">        char *node_name = get_node_display_name(node);</a>
<a name="ln2919"> </a>
<a name="ln2920">        /* Get node mode */</a>
<a name="ln2921">        if (node-&gt;details-&gt;unclean) {</a>
<a name="ln2922">            if (node-&gt;details-&gt;online) {</a>
<a name="ln2923">                node_mode = &quot;UNCLEAN (online)&quot;;</a>
<a name="ln2924"> </a>
<a name="ln2925">            } else if (node-&gt;details-&gt;pending) {</a>
<a name="ln2926">                node_mode = &quot;UNCLEAN (pending)&quot;;</a>
<a name="ln2927"> </a>
<a name="ln2928">            } else {</a>
<a name="ln2929">                node_mode = &quot;UNCLEAN (offline)&quot;;</a>
<a name="ln2930">            }</a>
<a name="ln2931"> </a>
<a name="ln2932">        } else if (node-&gt;details-&gt;pending) {</a>
<a name="ln2933">            node_mode = &quot;pending&quot;;</a>
<a name="ln2934"> </a>
<a name="ln2935">        } else if (node-&gt;details-&gt;standby_onfail &amp;&amp; node-&gt;details-&gt;online) {</a>
<a name="ln2936">            node_mode = &quot;standby (on-fail)&quot;;</a>
<a name="ln2937"> </a>
<a name="ln2938">        } else if (node-&gt;details-&gt;standby) {</a>
<a name="ln2939">            if (node-&gt;details-&gt;online) {</a>
<a name="ln2940">                node_mode = &quot;standby&quot;;</a>
<a name="ln2941">            } else {</a>
<a name="ln2942">                node_mode = &quot;OFFLINE (standby)&quot;;</a>
<a name="ln2943">            }</a>
<a name="ln2944"> </a>
<a name="ln2945">        } else if (node-&gt;details-&gt;maintenance) {</a>
<a name="ln2946">            if (node-&gt;details-&gt;online) {</a>
<a name="ln2947">                node_mode = &quot;maintenance&quot;;</a>
<a name="ln2948">            } else {</a>
<a name="ln2949">                node_mode = &quot;OFFLINE (maintenance)&quot;;</a>
<a name="ln2950">            }</a>
<a name="ln2951"> </a>
<a name="ln2952">        } else if (node-&gt;details-&gt;online) {</a>
<a name="ln2953">            node_mode = &quot;online&quot;;</a>
<a name="ln2954">            if (group_by_node == FALSE) {</a>
<a name="ln2955">                if (is_container_remote_node(node)) {</a>
<a name="ln2956">                    online_guest_nodes = add_list_element(online_guest_nodes, node_name);</a>
<a name="ln2957">                } else if (is_baremetal_remote_node(node)) {</a>
<a name="ln2958">                    online_remote_nodes = add_list_element(online_remote_nodes, node_name);</a>
<a name="ln2959">                } else {</a>
<a name="ln2960">                    online_nodes = add_list_element(online_nodes, node_name);</a>
<a name="ln2961">                }</a>
<a name="ln2962">                free(node_name);</a>
<a name="ln2963">                continue;</a>
<a name="ln2964">            }</a>
<a name="ln2965">        } else {</a>
<a name="ln2966">            node_mode = &quot;OFFLINE&quot;;</a>
<a name="ln2967">            if (group_by_node == FALSE) {</a>
<a name="ln2968">                if (is_baremetal_remote_node(node)) {</a>
<a name="ln2969">                    offline_remote_nodes = add_list_element(offline_remote_nodes, node_name);</a>
<a name="ln2970">                } else if (is_container_remote_node(node)) {</a>
<a name="ln2971">                    /* ignore offline guest nodes */</a>
<a name="ln2972">                } else {</a>
<a name="ln2973">                    offline_nodes = add_list_element(offline_nodes, node_name);</a>
<a name="ln2974">                }</a>
<a name="ln2975">                free(node_name);</a>
<a name="ln2976">                continue;</a>
<a name="ln2977">            }</a>
<a name="ln2978">        }</a>
<a name="ln2979"> </a>
<a name="ln2980">        /* If we get here, node is in bad state, or we're grouping by node */</a>
<a name="ln2981"> </a>
<a name="ln2982">        /* Print the node name and status */</a>
<a name="ln2983">        if (is_container_remote_node(node)) {</a>
<a name="ln2984">            print_as(&quot;Guest&quot;);</a>
<a name="ln2985">        } else if (is_baremetal_remote_node(node)) {</a>
<a name="ln2986">            print_as(&quot;Remote&quot;);</a>
<a name="ln2987">        }</a>
<a name="ln2988">        print_as(&quot;Node %s: %s\n&quot;, node_name, node_mode);</a>
<a name="ln2989"> </a>
<a name="ln2990">        /* If we're grouping by node, print its resources */</a>
<a name="ln2991">        if (group_by_node) {</a>
<a name="ln2992">            if (print_brief) {</a>
<a name="ln2993">                print_rscs_brief(node-&gt;details-&gt;running_rsc, &quot;\t&quot;, print_opts | pe_print_rsconly,</a>
<a name="ln2994">                                 stdout, FALSE);</a>
<a name="ln2995">            } else {</a>
<a name="ln2996">                GListPtr gIter2 = NULL;</a>
<a name="ln2997"> </a>
<a name="ln2998">                for (gIter2 = node-&gt;details-&gt;running_rsc; gIter2 != NULL; gIter2 = gIter2-&gt;next) {</a>
<a name="ln2999">                    resource_t *rsc = (resource_t *) gIter2-&gt;data;</a>
<a name="ln3000"> </a>
<a name="ln3001">                    rsc-&gt;fns-&gt;print(rsc, &quot;\t&quot;, print_opts | pe_print_rsconly, stdout);</a>
<a name="ln3002">                }</a>
<a name="ln3003">            }</a>
<a name="ln3004">        }</a>
<a name="ln3005">        free(node_name);</a>
<a name="ln3006">    }</a>
<a name="ln3007"> </a>
<a name="ln3008">    /* If we're not grouping by node, summarize nodes by status */</a>
<a name="ln3009">    if (online_nodes) {</a>
<a name="ln3010">        print_as(&quot;Online: [%s ]\n&quot;, online_nodes);</a>
<a name="ln3011">        free(online_nodes);</a>
<a name="ln3012">    }</a>
<a name="ln3013">    if (offline_nodes) {</a>
<a name="ln3014">        print_as(&quot;OFFLINE: [%s ]\n&quot;, offline_nodes);</a>
<a name="ln3015">        free(offline_nodes);</a>
<a name="ln3016">    }</a>
<a name="ln3017">    if (online_remote_nodes) {</a>
<a name="ln3018">        print_as(&quot;RemoteOnline: [%s ]\n&quot;, online_remote_nodes);</a>
<a name="ln3019">        free(online_remote_nodes);</a>
<a name="ln3020">    }</a>
<a name="ln3021">    if (offline_remote_nodes) {</a>
<a name="ln3022">        print_as(&quot;RemoteOFFLINE: [%s ]\n&quot;, offline_remote_nodes);</a>
<a name="ln3023">        free(offline_remote_nodes);</a>
<a name="ln3024">    }</a>
<a name="ln3025">    if (online_guest_nodes) {</a>
<a name="ln3026">        print_as(&quot;GuestOnline: [%s ]\n&quot;, online_guest_nodes);</a>
<a name="ln3027">        free(online_guest_nodes);</a>
<a name="ln3028">    }</a>
<a name="ln3029"> </a>
<a name="ln3030">    /* Print resources section, if needed */</a>
<a name="ln3031">    print_resources(stdout, data_set, print_opts);</a>
<a name="ln3032"> </a>
<a name="ln3033">    /* print Node Attributes section if requested */</a>
<a name="ln3034">    if (show &amp; mon_show_attributes) {</a>
<a name="ln3035">        print_node_attributes(stdout, data_set);</a>
<a name="ln3036">    }</a>
<a name="ln3037"> </a>
<a name="ln3038">    /* If requested, print resource operations (which includes failcounts)</a>
<a name="ln3039">     * or just failcounts</a>
<a name="ln3040">     */</a>
<a name="ln3041">    if (show &amp; (mon_show_operations | mon_show_failcounts)) {</a>
<a name="ln3042">        print_node_summary(stdout, data_set,</a>
<a name="ln3043">                           ((show &amp; mon_show_operations)? TRUE : FALSE));</a>
<a name="ln3044">    }</a>
<a name="ln3045"> </a>
<a name="ln3046">    /* If there were any failed actions, print them */</a>
<a name="ln3047">    if (xml_has_children(data_set-&gt;failed)) {</a>
<a name="ln3048">        print_failed_actions(stdout, data_set);</a>
<a name="ln3049">    }</a>
<a name="ln3050"> </a>
<a name="ln3051">    /* Print tickets if requested */</a>
<a name="ln3052">    if (show &amp; mon_show_tickets) {</a>
<a name="ln3053">        print_cluster_tickets(stdout, data_set);</a>
<a name="ln3054">    }</a>
<a name="ln3055"> </a>
<a name="ln3056">    /* Print negative location constraints if requested */</a>
<a name="ln3057">    if (show &amp; mon_show_bans) {</a>
<a name="ln3058">        print_neg_locations(stdout, data_set);</a>
<a name="ln3059">    }</a>
<a name="ln3060"> </a>
<a name="ln3061">#if CURSES_ENABLED</a>
<a name="ln3062">    if (output_format == mon_output_console) {</a>
<a name="ln3063">        refresh();</a>
<a name="ln3064">    }</a>
<a name="ln3065">#endif</a>
<a name="ln3066">}</a>
<a name="ln3067"> </a>
<a name="ln3068">/*!</a>
<a name="ln3069"> * \internal</a>
<a name="ln3070"> * \brief Print cluster status in XML format</a>
<a name="ln3071"> *</a>
<a name="ln3072"> * \param[in] data_set   Working set of CIB state</a>
<a name="ln3073"> */</a>
<a name="ln3074">static void</a>
<a name="ln3075">print_xml_status(pe_working_set_t * data_set)</a>
<a name="ln3076">{</a>
<a name="ln3077">    FILE *stream = stdout;</a>
<a name="ln3078">    GListPtr gIter = NULL;</a>
<a name="ln3079">    int print_opts = get_resource_display_options();</a>
<a name="ln3080"> </a>
<a name="ln3081">    fprintf(stream, &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot;);</a>
<a name="ln3082">    fprintf(stream, &quot;&lt;crm_mon version=\&quot;%s\&quot;&gt;\n&quot;, VERSION);</a>
<a name="ln3083"> </a>
<a name="ln3084">    print_cluster_summary(stream, data_set);</a>
<a name="ln3085"> </a>
<a name="ln3086">    /*** NODES ***/</a>
<a name="ln3087">    fprintf(stream, &quot;    &lt;nodes&gt;\n&quot;);</a>
<a name="ln3088">    for (gIter = data_set-&gt;nodes; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln3089">        node_t *node = (node_t *) gIter-&gt;data;</a>
<a name="ln3090">        const char *node_type = &quot;unknown&quot;;</a>
<a name="ln3091"> </a>
<a name="ln3092">        switch (node-&gt;details-&gt;type) {</a>
<a name="ln3093">            case node_member:</a>
<a name="ln3094">                node_type = &quot;member&quot;;</a>
<a name="ln3095">                break;</a>
<a name="ln3096">            case node_remote:</a>
<a name="ln3097">                node_type = &quot;remote&quot;;</a>
<a name="ln3098">                break;</a>
<a name="ln3099">            case node_ping:</a>
<a name="ln3100">                node_type = &quot;ping&quot;;</a>
<a name="ln3101">                break;</a>
<a name="ln3102">        }</a>
<a name="ln3103"> </a>
<a name="ln3104">        fprintf(stream, &quot;        &lt;node name=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;uname);</a>
<a name="ln3105">        fprintf(stream, &quot;id=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;id);</a>
<a name="ln3106">        fprintf(stream, &quot;online=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;online ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln3107">        fprintf(stream, &quot;standby=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;standby ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln3108">        fprintf(stream, &quot;standby_onfail=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;standby_onfail ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln3109">        fprintf(stream, &quot;maintenance=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;maintenance ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln3110">        fprintf(stream, &quot;pending=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;pending ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln3111">        fprintf(stream, &quot;unclean=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;unclean ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln3112">        fprintf(stream, &quot;shutdown=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;shutdown ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln3113">        fprintf(stream, &quot;expected_up=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;expected_up ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln3114">        fprintf(stream, &quot;is_dc=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;is_dc ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln3115">        fprintf(stream, &quot;resources_running=\&quot;%d\&quot; &quot;, g_list_length(node-&gt;details-&gt;running_rsc));</a>
<a name="ln3116">        fprintf(stream, &quot;type=\&quot;%s\&quot; &quot;, node_type);</a>
<a name="ln3117">        if (is_container_remote_node(node)) {</a>
<a name="ln3118">            fprintf(stream, &quot;id_as_resource=\&quot;%s\&quot; &quot;, node-&gt;details-&gt;remote_rsc-&gt;container-&gt;id);</a>
<a name="ln3119">        }</a>
<a name="ln3120"> </a>
<a name="ln3121">        if (group_by_node) {</a>
<a name="ln3122">            GListPtr lpc2 = NULL;</a>
<a name="ln3123"> </a>
<a name="ln3124">            fprintf(stream, &quot;&gt;\n&quot;);</a>
<a name="ln3125">            for (lpc2 = node-&gt;details-&gt;running_rsc; lpc2 != NULL; lpc2 = lpc2-&gt;next) {</a>
<a name="ln3126">                resource_t *rsc = (resource_t *) lpc2-&gt;data;</a>
<a name="ln3127"> </a>
<a name="ln3128">                rsc-&gt;fns-&gt;print(rsc, &quot;            &quot;, print_opts | pe_print_rsconly, stream);</a>
<a name="ln3129">            }</a>
<a name="ln3130">            fprintf(stream, &quot;        &lt;/node&gt;\n&quot;);</a>
<a name="ln3131">        } else {</a>
<a name="ln3132">            fprintf(stream, &quot;/&gt;\n&quot;);</a>
<a name="ln3133">        }</a>
<a name="ln3134">    }</a>
<a name="ln3135">    fprintf(stream, &quot;    &lt;/nodes&gt;\n&quot;);</a>
<a name="ln3136"> </a>
<a name="ln3137">    /* Print resources section, if needed */</a>
<a name="ln3138">    print_resources(stream, data_set, print_opts);</a>
<a name="ln3139"> </a>
<a name="ln3140">    /* print Node Attributes section if requested */</a>
<a name="ln3141">    if (show &amp; mon_show_attributes) {</a>
<a name="ln3142">        print_node_attributes(stream, data_set);</a>
<a name="ln3143">    }</a>
<a name="ln3144"> </a>
<a name="ln3145">    /* If requested, print resource operations (which includes failcounts)</a>
<a name="ln3146">     * or just failcounts</a>
<a name="ln3147">     */</a>
<a name="ln3148">    if (show &amp; (mon_show_operations | mon_show_failcounts)) {</a>
<a name="ln3149">        print_node_summary(stream, data_set,</a>
<a name="ln3150">                           ((show &amp; mon_show_operations)? TRUE : FALSE));</a>
<a name="ln3151">    }</a>
<a name="ln3152"> </a>
<a name="ln3153">    /* If there were any failed actions, print them */</a>
<a name="ln3154">    if (xml_has_children(data_set-&gt;failed)) {</a>
<a name="ln3155">        print_failed_actions(stream, data_set);</a>
<a name="ln3156">    }</a>
<a name="ln3157"> </a>
<a name="ln3158">    /* Print tickets if requested */</a>
<a name="ln3159">    if (show &amp; mon_show_tickets) {</a>
<a name="ln3160">        print_cluster_tickets(stream, data_set);</a>
<a name="ln3161">    }</a>
<a name="ln3162"> </a>
<a name="ln3163">    /* Print negative location constraints if requested */</a>
<a name="ln3164">    if (show &amp; mon_show_bans) {</a>
<a name="ln3165">        print_neg_locations(stream, data_set);</a>
<a name="ln3166">    }</a>
<a name="ln3167"> </a>
<a name="ln3168">    fprintf(stream, &quot;&lt;/crm_mon&gt;\n&quot;);</a>
<a name="ln3169">    fflush(stream);</a>
<a name="ln3170">    fclose(stream);</a>
<a name="ln3171">}</a>
<a name="ln3172"> </a>
<a name="ln3173">/*!</a>
<a name="ln3174"> * \internal</a>
<a name="ln3175"> * \brief Print cluster status in HTML format (with HTTP headers if CGI)</a>
<a name="ln3176"> *</a>
<a name="ln3177"> * \param[in] data_set   Working set of CIB state</a>
<a name="ln3178"> * \param[in] filename   Name of file to write HTML to (ignored if CGI)</a>
<a name="ln3179"> *</a>
<a name="ln3180"> * \return 0 on success, -1 on error</a>
<a name="ln3181"> */</a>
<a name="ln3182">static int</a>
<a name="ln3183">print_html_status(pe_working_set_t * data_set, const char *filename)</a>
<a name="ln3184">{</a>
<a name="ln3185">    FILE *stream;</a>
<a name="ln3186">    GListPtr gIter = NULL;</a>
<a name="ln3187">    char *filename_tmp = NULL;</a>
<a name="ln3188">    int print_opts = get_resource_display_options();</a>
<a name="ln3189"> </a>
<a name="ln3190">    if (output_format == mon_output_cgi) {</a>
<a name="ln3191">        stream = stdout;</a>
<a name="ln3192">        fprintf(stream, &quot;Content-type: text/html\n\n&quot;);</a>
<a name="ln3193"> </a>
<a name="ln3194">    } else {</a>
<a name="ln3195">        filename_tmp = crm_concat(filename, &quot;tmp&quot;, '.');</a>
<a name="ln3196">        stream = fopen(filename_tmp, &quot;w&quot;);</a>
<a name="ln3197">        if (stream == NULL) {</a>
<a name="ln3198">            crm_perror(LOG_ERR, &quot;Cannot open %s for writing&quot;, filename_tmp);</a>
<a name="ln3199">            free(filename_tmp);</a>
<a name="ln3200">            return -1;</a>
<a name="ln3201">        }</a>
<a name="ln3202">    }</a>
<a name="ln3203"> </a>
<a name="ln3204">    fprintf(stream, &quot;&lt;html&gt;\n&quot;);</a>
<a name="ln3205">    fprintf(stream, &quot; &lt;head&gt;\n&quot;);</a>
<a name="ln3206">    fprintf(stream, &quot;  &lt;title&gt;Cluster status&lt;/title&gt;\n&quot;);</a>
<a name="ln3207">    fprintf(stream, &quot;  &lt;meta http-equiv=\&quot;refresh\&quot; content=\&quot;%d\&quot;&gt;\n&quot;, reconnect_msec / 1000);</a>
<a name="ln3208">    fprintf(stream, &quot; &lt;/head&gt;\n&quot;);</a>
<a name="ln3209">    fprintf(stream, &quot;&lt;body&gt;\n&quot;);</a>
<a name="ln3210"> </a>
<a name="ln3211">    print_cluster_summary(stream, data_set);</a>
<a name="ln3212"> </a>
<a name="ln3213">    /*** NODE LIST ***/</a>
<a name="ln3214"> </a>
<a name="ln3215">    fprintf(stream, &quot; &lt;hr /&gt;\n &lt;h2&gt;Node List&lt;/h2&gt;\n&quot;);</a>
<a name="ln3216">    fprintf(stream, &quot;&lt;ul&gt;\n&quot;);</a>
<a name="ln3217">    for (gIter = data_set-&gt;nodes; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln3218">        node_t *node = (node_t *) gIter-&gt;data;</a>
<a name="ln3219">        char *node_name = get_node_display_name(node);</a>
<a name="ln3220"> </a>
<a name="ln3221">        fprintf(stream, &quot;&lt;li&gt;Node: %s: &quot;, node_name);</a>
<a name="ln3222">        if (node-&gt;details-&gt;standby_onfail &amp;&amp; node-&gt;details-&gt;online) {</a>
<a name="ln3223">            fprintf(stream, &quot;&lt;font color=\&quot;orange\&quot;&gt;standby (on-fail)&lt;/font&gt;\n&quot;);</a>
<a name="ln3224">        } else if (node-&gt;details-&gt;standby &amp;&amp; node-&gt;details-&gt;online) {</a>
<a name="ln3225">            fprintf(stream, &quot;&lt;font color=\&quot;orange\&quot;&gt;standby&lt;/font&gt;\n&quot;);</a>
<a name="ln3226">        } else if (node-&gt;details-&gt;standby) {</a>
<a name="ln3227">            fprintf(stream, &quot;&lt;font color=\&quot;red\&quot;&gt;OFFLINE (standby)&lt;/font&gt;\n&quot;);</a>
<a name="ln3228">        } else if (node-&gt;details-&gt;maintenance &amp;&amp; node-&gt;details-&gt;online) {</a>
<a name="ln3229">            fprintf(stream, &quot;&lt;font color=\&quot;blue\&quot;&gt;maintenance&lt;/font&gt;\n&quot;);</a>
<a name="ln3230">        } else if (node-&gt;details-&gt;maintenance) {</a>
<a name="ln3231">            fprintf(stream, &quot;&lt;font color=\&quot;red\&quot;&gt;OFFLINE (maintenance)&lt;/font&gt;\n&quot;);</a>
<a name="ln3232">        } else if (node-&gt;details-&gt;online) {</a>
<a name="ln3233">            fprintf(stream, &quot;&lt;font color=\&quot;green\&quot;&gt;online&lt;/font&gt;\n&quot;);</a>
<a name="ln3234">        } else {</a>
<a name="ln3235">            fprintf(stream, &quot;&lt;font color=\&quot;red\&quot;&gt;OFFLINE&lt;/font&gt;\n&quot;);</a>
<a name="ln3236">        }</a>
<a name="ln3237">        if (print_brief &amp;&amp; group_by_node) {</a>
<a name="ln3238">            fprintf(stream, &quot;&lt;ul&gt;\n&quot;);</a>
<a name="ln3239">            print_rscs_brief(node-&gt;details-&gt;running_rsc, NULL, print_opts | pe_print_rsconly,</a>
<a name="ln3240">                             stream, FALSE);</a>
<a name="ln3241">            fprintf(stream, &quot;&lt;/ul&gt;\n&quot;);</a>
<a name="ln3242"> </a>
<a name="ln3243">        } else if (group_by_node) {</a>
<a name="ln3244">            GListPtr lpc2 = NULL;</a>
<a name="ln3245"> </a>
<a name="ln3246">            fprintf(stream, &quot;&lt;ul&gt;\n&quot;);</a>
<a name="ln3247">            for (lpc2 = node-&gt;details-&gt;running_rsc; lpc2 != NULL; lpc2 = lpc2-&gt;next) {</a>
<a name="ln3248">                resource_t *rsc = (resource_t *) lpc2-&gt;data;</a>
<a name="ln3249"> </a>
<a name="ln3250">                fprintf(stream, &quot;&lt;li&gt;&quot;);</a>
<a name="ln3251">                rsc-&gt;fns-&gt;print(rsc, NULL, print_opts | pe_print_rsconly, stream);</a>
<a name="ln3252">                fprintf(stream, &quot;&lt;/li&gt;\n&quot;);</a>
<a name="ln3253">            }</a>
<a name="ln3254">            fprintf(stream, &quot;&lt;/ul&gt;\n&quot;);</a>
<a name="ln3255">        }</a>
<a name="ln3256">        fprintf(stream, &quot;&lt;/li&gt;\n&quot;);</a>
<a name="ln3257">        free(node_name);</a>
<a name="ln3258">    }</a>
<a name="ln3259">    fprintf(stream, &quot;&lt;/ul&gt;\n&quot;);</a>
<a name="ln3260"> </a>
<a name="ln3261">    /* Print resources section, if needed */</a>
<a name="ln3262">    print_resources(stream, data_set, print_opts);</a>
<a name="ln3263"> </a>
<a name="ln3264">    /* print Node Attributes section if requested */</a>
<a name="ln3265">    if (show &amp; mon_show_attributes) {</a>
<a name="ln3266">        print_node_attributes(stream, data_set);</a>
<a name="ln3267">    }</a>
<a name="ln3268"> </a>
<a name="ln3269">    /* If requested, print resource operations (which includes failcounts)</a>
<a name="ln3270">     * or just failcounts</a>
<a name="ln3271">     */</a>
<a name="ln3272">    if (show &amp; (mon_show_operations | mon_show_failcounts)) {</a>
<a name="ln3273">        print_node_summary(stream, data_set,</a>
<a name="ln3274">                           ((show &amp; mon_show_operations)? TRUE : FALSE));</a>
<a name="ln3275">    }</a>
<a name="ln3276"> </a>
<a name="ln3277">    /* If there were any failed actions, print them */</a>
<a name="ln3278">    if (xml_has_children(data_set-&gt;failed)) {</a>
<a name="ln3279">        print_failed_actions(stream, data_set);</a>
<a name="ln3280">    }</a>
<a name="ln3281"> </a>
<a name="ln3282">    /* Print tickets if requested */</a>
<a name="ln3283">    if (show &amp; mon_show_tickets) {</a>
<a name="ln3284">        print_cluster_tickets(stream, data_set);</a>
<a name="ln3285">    }</a>
<a name="ln3286"> </a>
<a name="ln3287">    /* Print negative location constraints if requested */</a>
<a name="ln3288">    if (show &amp; mon_show_bans) {</a>
<a name="ln3289">        print_neg_locations(stream, data_set);</a>
<a name="ln3290">    }</a>
<a name="ln3291"> </a>
<a name="ln3292">    fprintf(stream, &quot;&lt;/body&gt;\n&quot;);</a>
<a name="ln3293">    fprintf(stream, &quot;&lt;/html&gt;\n&quot;);</a>
<a name="ln3294">    fflush(stream);</a>
<a name="ln3295">    fclose(stream);</a>
<a name="ln3296"> </a>
<a name="ln3297">    if (output_format != mon_output_cgi) {</a>
<a name="ln3298">        if (rename(filename_tmp, filename) != 0) {</a>
<a name="ln3299">            crm_perror(LOG_ERR, &quot;Unable to rename %s-&gt;%s&quot;, filename_tmp, filename);</a>
<a name="ln3300">        }</a>
<a name="ln3301">        free(filename_tmp);</a>
<a name="ln3302">    }</a>
<a name="ln3303">    return 0;</a>
<a name="ln3304">}</a>
<a name="ln3305"> </a>
<a name="ln3306">#if ENABLE_SNMP</a>
<a name="ln3307">#  include &lt;net-snmp/net-snmp-config.h&gt;</a>
<a name="ln3308">#  include &lt;net-snmp/snmpv3_api.h&gt;</a>
<a name="ln3309">#  include &lt;net-snmp/agent/agent_trap.h&gt;</a>
<a name="ln3310">#  include &lt;net-snmp/library/snmp_client.h&gt;</a>
<a name="ln3311">#  include &lt;net-snmp/library/mib.h&gt;</a>
<a name="ln3312">#  include &lt;net-snmp/library/snmp_debug.h&gt;</a>
<a name="ln3313"> </a>
<a name="ln3314">#  define add_snmp_field(list, oid_string, value) do {			\</a>
<a name="ln3315">	oid name[MAX_OID_LEN];						\</a>
<a name="ln3316">        size_t name_length = MAX_OID_LEN;				\</a>
<a name="ln3317">	if (snmp_parse_oid(oid_string, name, &amp;name_length)) {		\</a>
<a name="ln3318">	    int s_rc = snmp_add_var(list, name, name_length, 's', (value)); \</a>
<a name="ln3319">	    if(s_rc != 0) {						\</a>
<a name="ln3320">		crm_err(&quot;Could not add %s=%s rc=%d&quot;, oid_string, value, s_rc); \</a>
<a name="ln3321">	    } else {							\</a>
<a name="ln3322">		crm_trace(&quot;Added %s=%s&quot;, oid_string, value);		\</a>
<a name="ln3323">	    }								\</a>
<a name="ln3324">	} else {							\</a>
<a name="ln3325">	    crm_err(&quot;Could not parse OID: %s&quot;, oid_string);		\</a>
<a name="ln3326">	}								\</a>
<a name="ln3327">    } while(0)								\</a>
<a name="ln3328"> </a>
<a name="ln3329">#  define add_snmp_field_int(list, oid_string, value) do {		\</a>
<a name="ln3330">	oid name[MAX_OID_LEN];						\</a>
<a name="ln3331">        size_t name_length = MAX_OID_LEN;				\</a>
<a name="ln3332">	if (snmp_parse_oid(oid_string, name, &amp;name_length)) {		\</a>
<a name="ln3333">	    if(NULL == snmp_pdu_add_variable(				\</a>
<a name="ln3334">		   list, name, name_length, ASN_INTEGER,		\</a>
<a name="ln3335">		   (u_char *) &amp; value, sizeof(value))) {		\</a>
<a name="ln3336">		crm_err(&quot;Could not add %s=%d&quot;, oid_string, value);	\</a>
<a name="ln3337">	    } else {							\</a>
<a name="ln3338">		crm_trace(&quot;Added %s=%d&quot;, oid_string, value);		\</a>
<a name="ln3339">	    }								\</a>
<a name="ln3340">	} else {							\</a>
<a name="ln3341">	    crm_err(&quot;Could not parse OID: %s&quot;, oid_string);		\</a>
<a name="ln3342">	}								\</a>
<a name="ln3343">    } while(0)								\</a>
<a name="ln3344"> </a>
<a name="ln3345">static int</a>
<a name="ln3346">snmp_input(int operation, netsnmp_session * session, int reqid, netsnmp_pdu * pdu, void *magic)</a>
<a name="ln3347">{</a>
<a name="ln3348">    return 1;</a>
<a name="ln3349">}</a>
<a name="ln3350"> </a>
<a name="ln3351">static netsnmp_session *</a>
<a name="ln3352">crm_snmp_init(const char *target, char *community)</a>
<a name="ln3353">{</a>
<a name="ln3354">    static netsnmp_session *session = NULL;</a>
<a name="ln3355"> </a>
<a name="ln3356">#  ifdef NETSNMPV53</a>
<a name="ln3357">    char target53[128];</a>
<a name="ln3358"> </a>
<a name="ln3359">    snprintf(target53, sizeof(target53), &quot;%s:162&quot;, target);</a>
<a name="ln3360">#  endif</a>
<a name="ln3361"> </a>
<a name="ln3362">    if (session) {</a>
<a name="ln3363">        return session;</a>
<a name="ln3364">    }</a>
<a name="ln3365"> </a>
<a name="ln3366">    if (target == NULL) {</a>
<a name="ln3367">        return NULL;</a>
<a name="ln3368">    }</a>
<a name="ln3369"> </a>
<a name="ln3370">    if (get_crm_log_level() &gt; LOG_INFO) {</a>
<a name="ln3371">        char *debug_tokens = strdup(&quot;run:shell,snmptrap,tdomain&quot;);</a>
<a name="ln3372"> </a>
<a name="ln3373">        debug_register_tokens(debug_tokens);</a>
<a name="ln3374">        snmp_set_do_debugging(1);</a>
<a name="ln3375">    }</a>
<a name="ln3376"> </a>
<a name="ln3377">    session = calloc(1, sizeof(netsnmp_session));</a>
<a name="ln3378">    snmp_sess_init(session);</a>
<a name="ln3379">    session-&gt;version = SNMP_VERSION_2c;</a>
<a name="ln3380">    session-&gt;callback = snmp_input;</a>
<a name="ln3381">    session-&gt;callback_magic = NULL;</a>
<a name="ln3382"> </a>
<a name="ln3383">    if (community) {</a>
<a name="ln3384">        session-&gt;community_len = strlen(community);</a>
<a name="ln3385">        session-&gt;community = (unsigned char *)community;</a>
<a name="ln3386">    }</a>
<a name="ln3387"> </a>
<a name="ln3388">    session = snmp_add(session,</a>
<a name="ln3389">#  ifdef NETSNMPV53</a>
<a name="ln3390">                       netsnmp_tdomain_transport(target53, 0, &quot;udp&quot;),</a>
<a name="ln3391">#  else</a>
<a name="ln3392">                       netsnmp_transport_open_client(&quot;snmptrap&quot;, target),</a>
<a name="ln3393">#  endif</a>
<a name="ln3394">                       NULL, NULL);</a>
<a name="ln3395"> </a>
<a name="ln3396">    if (session == NULL) {</a>
<a name="ln3397">        snmp_sess_perror(&quot;Could not create snmp transport&quot;, session);</a>
<a name="ln3398">    }</a>
<a name="ln3399">    return session;</a>
<a name="ln3400">}</a>
<a name="ln3401"> </a>
<a name="ln3402">#endif</a>
<a name="ln3403"> </a>
<a name="ln3404">static int</a>
<a name="ln3405">send_snmp_trap(const char *node, const char *rsc, const char *task, int target_rc, int rc,</a>
<a name="ln3406">               int status, const char *desc)</a>
<a name="ln3407">{</a>
<a name="ln3408">    int ret = 1;</a>
<a name="ln3409"> </a>
<a name="ln3410">#if ENABLE_SNMP</a>
<a name="ln3411">    static oid snmptrap_oid[] = { 1, 3, 6, 1, 6, 3, 1, 1, 4, 1, 0 };</a>
<a name="ln3412">    static oid sysuptime_oid[] = { 1, 3, 6, 1, 2, 1, 1, 3, 0 };</a>
<a name="ln3413"> </a>
<a name="ln3414">    netsnmp_pdu *trap_pdu;</a>
<a name="ln3415">    netsnmp_session *session = crm_snmp_init(snmp_target, snmp_community);</a>
<a name="ln3416"> </a>
<a name="ln3417">    trap_pdu = snmp_pdu_create(SNMP_MSG_TRAP2);</a>
<a name="ln3418">    if (!trap_pdu) {</a>
<a name="ln3419">        crm_err(&quot;Failed to create SNMP notification&quot;);</a>
<a name="ln3420">        return SNMPERR_GENERR;</a>
<a name="ln3421">    }</a>
<a name="ln3422"> </a>
<a name="ln3423">    if (1) {</a>
<a name="ln3424">        /* send uptime */</a>
<a name="ln3425">        char csysuptime[20];</a>
<a name="ln3426">        time_t now = time(NULL);</a>
<a name="ln3427"> </a>
<a name="ln3428">        sprintf(csysuptime, &quot;%lld&quot;, (long long) now);</a>
<a name="ln3429">        snmp_add_var(trap_pdu, sysuptime_oid, sizeof(sysuptime_oid) / sizeof(oid), 't', csysuptime);</a>
<a name="ln3430">    }</a>
<a name="ln3431"> </a>
<a name="ln3432">    /* Indicate what the trap is by setting snmpTrapOid.0 */</a>
<a name="ln3433">    ret =</a>
<a name="ln3434">        snmp_add_var(trap_pdu, snmptrap_oid, sizeof(snmptrap_oid) / sizeof(oid), 'o',</a>
<a name="ln3435">                     snmp_crm_trap_oid);</a>
<a name="ln3436">    if (ret != 0) {</a>
<a name="ln3437">        crm_err(&quot;Failed set snmpTrapOid.0=%s&quot;, snmp_crm_trap_oid);</a>
<a name="ln3438">        return ret;</a>
<a name="ln3439">    }</a>
<a name="ln3440"> </a>
<a name="ln3441">    /* Add extries to the trap */</a>
<a name="ln3442">    if (rsc) {</a>
<a name="ln3443">        add_snmp_field(trap_pdu, snmp_crm_oid_rsc, rsc);</a>
<a name="ln3444">    }</a>
<a name="ln3445">    add_snmp_field(trap_pdu, snmp_crm_oid_node, node);</a>
<a name="ln3446">    add_snmp_field(trap_pdu, snmp_crm_oid_task, task);</a>
<a name="ln3447">    add_snmp_field(trap_pdu, snmp_crm_oid_desc, desc);</a>
<a name="ln3448"> </a>
<a name="ln3449">    add_snmp_field_int(trap_pdu, snmp_crm_oid_rc, rc);</a>
<a name="ln3450">    add_snmp_field_int(trap_pdu, snmp_crm_oid_trc, target_rc);</a>
<a name="ln3451">    add_snmp_field_int(trap_pdu, snmp_crm_oid_status, status);</a>
<a name="ln3452"> </a>
<a name="ln3453">    /* Send and cleanup */</a>
<a name="ln3454">    ret = snmp_send(session, trap_pdu);</a>
<a name="ln3455">    if (ret == 0) {</a>
<a name="ln3456">        /* error */</a>
<a name="ln3457">        snmp_sess_perror(&quot;Could not send SNMP trap&quot;, session);</a>
<a name="ln3458">        snmp_free_pdu(trap_pdu);</a>
<a name="ln3459">        ret = SNMPERR_GENERR;</a>
<a name="ln3460">    } else {</a>
<a name="ln3461">        ret = SNMPERR_SUCCESS;</a>
<a name="ln3462">    }</a>
<a name="ln3463">#else</a>
<a name="ln3464">    crm_err(&quot;Sending SNMP traps is not supported by this installation&quot;);</a>
<a name="ln3465">#endif</a>
<a name="ln3466">    return ret;</a>
<a name="ln3467">}</a>
<a name="ln3468"> </a>
<a name="ln3469">#if ENABLE_ESMTP</a>
<a name="ln3470">#  include &lt;auth-client.h&gt;</a>
<a name="ln3471">#  include &lt;libesmtp.h&gt;</a>
<a name="ln3472"> </a>
<a name="ln3473">static void</a>
<a name="ln3474">print_recipient_status(smtp_recipient_t recipient, const char *mailbox, void *arg)</a>
<a name="ln3475">{</a>
<a name="ln3476">    const smtp_status_t *status;</a>
<a name="ln3477"> </a>
<a name="ln3478">    status = smtp_recipient_status(recipient);</a>
<a name="ln3479">    printf(&quot;%s: %d %s&quot;, mailbox, status-&gt;code, status-&gt;text);</a>
<a name="ln3480">}</a>
<a name="ln3481"> </a>
<a name="ln3482">static void</a>
<a name="ln3483">event_cb(smtp_session_t session, int event_no, void *arg, ...)</a>
<a name="ln3484">{</a>
<a name="ln3485">    int *ok;</a>
<a name="ln3486">    va_list alist;</a>
<a name="ln3487"> </a>
<a name="ln3488">    va_start(alist, arg);</a>
<a name="ln3489">    switch (event_no) {</a>
<a name="ln3490">        case SMTP_EV_CONNECT:</a>
<a name="ln3491">        case SMTP_EV_MAILSTATUS:</a>
<a name="ln3492">        case SMTP_EV_RCPTSTATUS:</a>
<a name="ln3493">        case SMTP_EV_MESSAGEDATA:</a>
<a name="ln3494">        case SMTP_EV_MESSAGESENT:</a>
<a name="ln3495">        case SMTP_EV_DISCONNECT:</a>
<a name="ln3496">            break;</a>
<a name="ln3497"> </a>
<a name="ln3498">        case SMTP_EV_WEAK_CIPHER:{</a>
<a name="ln3499">                int bits = va_arg(alist, long);</a>
<a name="ln3500">                ok = va_arg(alist, int *);</a>
<a name="ln3501"> </a>
<a name="ln3502">                crm_debug(&quot;SMTP_EV_WEAK_CIPHER, bits=%d - accepted.&quot;, bits);</a>
<a name="ln3503">                *ok = 1;</a>
<a name="ln3504">                break;</a>
<a name="ln3505">            }</a>
<a name="ln3506">        case SMTP_EV_STARTTLS_OK:</a>
<a name="ln3507">            crm_debug(&quot;SMTP_EV_STARTTLS_OK - TLS started here.&quot;);</a>
<a name="ln3508">            break;</a>
<a name="ln3509"> </a>
<a name="ln3510">        case SMTP_EV_INVALID_PEER_CERTIFICATE:{</a>
<a name="ln3511">                long vfy_result = va_arg(alist, long);</a>
<a name="ln3512">                ok = va_arg(alist, int *);</a>
<a name="ln3513"> </a>
<a name="ln3514">                /* There is a table in handle_invalid_peer_certificate() of mail-file.c */</a>
<a name="ln3515">                crm_err(&quot;SMTP_EV_INVALID_PEER_CERTIFICATE: %ld&quot;, vfy_result);</a>
<a name="ln3516">                *ok = 1;</a>
<a name="ln3517">                break;</a>
<a name="ln3518">            }</a>
<a name="ln3519">        case SMTP_EV_NO_PEER_CERTIFICATE:</a>
<a name="ln3520">            ok = va_arg(alist, int *);</a>
<a name="ln3521"> </a>
<a name="ln3522">            crm_debug(&quot;SMTP_EV_NO_PEER_CERTIFICATE - accepted.&quot;);</a>
<a name="ln3523">            *ok = 1;</a>
<a name="ln3524">            break;</a>
<a name="ln3525">        case SMTP_EV_WRONG_PEER_CERTIFICATE:</a>
<a name="ln3526">            ok = va_arg(alist, int *);</a>
<a name="ln3527"> </a>
<a name="ln3528">            crm_debug(&quot;SMTP_EV_WRONG_PEER_CERTIFICATE - accepted.&quot;);</a>
<a name="ln3529">            *ok = 1;</a>
<a name="ln3530">            break;</a>
<a name="ln3531">        case SMTP_EV_NO_CLIENT_CERTIFICATE:</a>
<a name="ln3532">            ok = va_arg(alist, int *);</a>
<a name="ln3533"> </a>
<a name="ln3534">            crm_debug(&quot;SMTP_EV_NO_CLIENT_CERTIFICATE - accepted.&quot;);</a>
<a name="ln3535">            *ok = 1;</a>
<a name="ln3536">            break;</a>
<a name="ln3537">        default:</a>
<a name="ln3538">            crm_debug(&quot;Got event: %d - ignored.&quot;, event_no);</a>
<a name="ln3539">    }</a>
<a name="ln3540">    va_end(alist);</a>
<a name="ln3541">}</a>
<a name="ln3542">#endif</a>
<a name="ln3543"> </a>
<a name="ln3544">#define BODY_MAX 2048</a>
<a name="ln3545"> </a>
<a name="ln3546">#if ENABLE_ESMTP</a>
<a name="ln3547">static void</a>
<a name="ln3548">crm_smtp_debug(const char *buf, int buflen, int writing, void *arg)</a>
<a name="ln3549">{</a>
<a name="ln3550">    char type = 0;</a>
<a name="ln3551">    int lpc = 0, last = 0, level = *(int *)arg;</a>
<a name="ln3552"> </a>
<a name="ln3553">    if (writing == SMTP_CB_HEADERS) {</a>
<a name="ln3554">        type = 'H';</a>
<a name="ln3555">    } else if (writing) {</a>
<a name="ln3556">        type = 'C';</a>
<a name="ln3557">    } else {</a>
<a name="ln3558">        type = 'S';</a>
<a name="ln3559">    }</a>
<a name="ln3560"> </a>
<a name="ln3561">    for (; lpc &lt; buflen; lpc++) {</a>
<a name="ln3562">        switch (buf[lpc]) {</a>
<a name="ln3563">            case 0:</a>
<a name="ln3564">            case '\n':</a>
<a name="ln3565">                if (last &gt; 0) {</a>
<a name="ln3566">                    do_crm_log(level, &quot;   %.*s&quot;, lpc - last, buf + last);</a>
<a name="ln3567">                } else {</a>
<a name="ln3568">                    do_crm_log(level, &quot;%c: %.*s&quot;, type, lpc - last, buf + last);</a>
<a name="ln3569">                }</a>
<a name="ln3570">                last = lpc + 1;</a>
<a name="ln3571">                break;</a>
<a name="ln3572">        }</a>
<a name="ln3573">    }</a>
<a name="ln3574">}</a>
<a name="ln3575">#endif</a>
<a name="ln3576"> </a>
<a name="ln3577">static int</a>
<a name="ln3578">send_custom_trap(const char *node, const char *rsc, const char *task, int target_rc, int rc,</a>
<a name="ln3579">                 int status, const char *desc)</a>
<a name="ln3580">{</a>
<a name="ln3581">    pid_t pid;</a>
<a name="ln3582"> </a>
<a name="ln3583">    /*setenv needs chars, these are ints */</a>
<a name="ln3584">    char *rc_s = crm_itoa(rc);</a>
<a name="ln3585">    char *status_s = crm_itoa(status);</a>
<a name="ln3586">    char *target_rc_s = crm_itoa(target_rc);</a>
<a name="ln3587"> </a>
<a name="ln3588">    crm_debug(&quot;Sending external notification to '%s' via '%s'&quot;, external_recipient, external_agent);</a>
<a name="ln3589"> </a>
<a name="ln3590">    if(rsc) {</a>
<a name="ln3591">        setenv(&quot;CRM_notify_rsc&quot;, rsc, 1);</a>
<a name="ln3592">    }</a>
<a name="ln3593">    if (external_recipient) {</a>
<a name="ln3594">        setenv(&quot;CRM_notify_recipient&quot;, external_recipient, 1);</a>
<a name="ln3595">    }</a>
<a name="ln3596">    setenv(&quot;CRM_notify_node&quot;, node, 1);</a>
<a name="ln3597">    setenv(&quot;CRM_notify_task&quot;, task, 1);</a>
<a name="ln3598">    setenv(&quot;CRM_notify_desc&quot;, desc, 1);</a>
<a name="ln3599">    setenv(&quot;CRM_notify_rc&quot;, rc_s, 1);</a>
<a name="ln3600">    setenv(&quot;CRM_notify_target_rc&quot;, target_rc_s, 1);</a>
<a name="ln3601">    setenv(&quot;CRM_notify_status&quot;, status_s, 1);</a>
<a name="ln3602"> </a>
<a name="ln3603">    pid = fork();</a>
<a name="ln3604">    if (pid == -1) {</a>
<a name="ln3605">        crm_perror(LOG_ERR, &quot;notification fork() failed.&quot;);</a>
<a name="ln3606">    }</a>
<a name="ln3607">    if (pid == 0) {</a>
<a name="ln3608">        /* crm_debug(&quot;notification: I am the child. Executing the nofitication program.&quot;); */</a>
<a name="ln3609">        execl(external_agent, external_agent, NULL);</a>
<a name="ln3610">    }</a>
<a name="ln3611"> </a>
<a name="ln3612">    crm_trace(&quot;Finished running custom notification program '%s'.&quot;, external_agent);</a>
<a name="ln3613">    free(target_rc_s);</a>
<a name="ln3614">    free(status_s);</a>
<a name="ln3615">    free(rc_s);</a>
<a name="ln3616">    return 0;</a>
<a name="ln3617">}</a>
<a name="ln3618"> </a>
<a name="ln3619">static int</a>
<a name="ln3620">send_smtp_trap(const char *node, const char *rsc, const char *task, int target_rc, int rc,</a>
<a name="ln3621">               int status, const char *desc)</a>
<a name="ln3622">{</a>
<a name="ln3623">#if ENABLE_ESMTP</a>
<a name="ln3624">    smtp_session_t session;</a>
<a name="ln3625">    smtp_message_t message;</a>
<a name="ln3626">    auth_context_t authctx;</a>
<a name="ln3627">    struct sigaction sa;</a>
<a name="ln3628"> </a>
<a name="ln3629">    int len = 25; /* Note: Check extra padding on the Subject line below */</a>
<a name="ln3630">    int noauth = 1;</a>
<a name="ln3631">    int smtp_debug = LOG_DEBUG;</a>
<a name="ln3632">    char crm_mail_body[BODY_MAX];</a>
<a name="ln3633">    char *crm_mail_subject = NULL;</a>
<a name="ln3634"> </a>
<a name="ln3635">    memset(&amp;sa, 0, sizeof(struct sigaction));</a>
<a name="ln3636"> </a>
<a name="ln3637">    if (node == NULL) {</a>
<a name="ln3638">        node = &quot;-&quot;;</a>
<a name="ln3639">    }</a>
<a name="ln3640">    if (rsc == NULL) {</a>
<a name="ln3641">        rsc = &quot;-&quot;;</a>
<a name="ln3642">    }</a>
<a name="ln3643">    if (desc == NULL) {</a>
<a name="ln3644">        desc = &quot;-&quot;;</a>
<a name="ln3645">    }</a>
<a name="ln3646"> </a>
<a name="ln3647">    if (crm_mail_to == NULL) {</a>
<a name="ln3648">        return 1;</a>
<a name="ln3649">    }</a>
<a name="ln3650"> </a>
<a name="ln3651">    if (crm_mail_host == NULL) {</a>
<a name="ln3652">        crm_mail_host = &quot;localhost:25&quot;;</a>
<a name="ln3653">    }</a>
<a name="ln3654"> </a>
<a name="ln3655">    if (crm_mail_prefix == NULL) {</a>
<a name="ln3656">        crm_mail_prefix = &quot;Cluster notification&quot;;</a>
<a name="ln3657">    }</a>
<a name="ln3658"> </a>
<a name="ln3659">    crm_debug(&quot;Sending '%s' mail to %s via %s&quot;, crm_mail_prefix, crm_mail_to, crm_mail_host);</a>
<a name="ln3660"> </a>
<a name="ln3661">    len += strlen(crm_mail_prefix);</a>
<a name="ln3662">    len += strlen(task);</a>
<a name="ln3663">    len += strlen(rsc);</a>
<a name="ln3664">    len += strlen(node);</a>
<a name="ln3665">    len += strlen(desc);</a>
<a name="ln3666">    len++;</a>
<a name="ln3667"> </a>
<a name="ln3668">    crm_mail_subject = calloc(1, len);</a>
<a name="ln3669">    /* If you edit this line, ensure you allocate enough memory for it by altering 'len' above */</a>
<a name="ln3670">    snprintf(crm_mail_subject, len, &quot;%s - %s event for %s on %s: %s\r\n&quot;, crm_mail_prefix, task,</a>
<a name="ln3671">             rsc, node, desc);</a>
<a name="ln3672"> </a>
<a name="ln3673">    len = 0;</a>
<a name="ln3674">    len += snprintf(crm_mail_body + len, BODY_MAX - len, &quot;\r\n%s\r\n&quot;, crm_mail_prefix);</a>
<a name="ln3675">    len += snprintf(crm_mail_body + len, BODY_MAX - len, &quot;====\r\n\r\n&quot;);</a>
<a name="ln3676">    if (rc == target_rc) {</a>
<a name="ln3677">        len += snprintf(crm_mail_body + len, BODY_MAX - len,</a>
<a name="ln3678">                        &quot;Completed operation %s for resource %s on %s\r\n&quot;, task, rsc, node);</a>
<a name="ln3679">    } else {</a>
<a name="ln3680">        len += snprintf(crm_mail_body + len, BODY_MAX - len,</a>
<a name="ln3681">                        &quot;Operation %s for resource %s on %s failed: %s\r\n&quot;, task, rsc, node, desc);</a>
<a name="ln3682">    }</a>
<a name="ln3683"> </a>
<a name="ln3684">    len += snprintf(crm_mail_body + len, BODY_MAX - len, &quot;\r\nDetails:\r\n&quot;);</a>
<a name="ln3685">    len += snprintf(crm_mail_body + len, BODY_MAX - len,</a>
<a name="ln3686">                    &quot;\toperation status: (%d) %s\r\n&quot;, status, services_lrm_status_str(status));</a>
<a name="ln3687">    if (status == PCMK_LRM_OP_DONE) {</a>
<a name="ln3688">        len += snprintf(crm_mail_body + len, BODY_MAX - len,</a>
<a name="ln3689">                        &quot;\tscript returned: (%d) %s\r\n&quot;, rc, services_ocf_exitcode_str(rc));</a>
<a name="ln3690">        len += snprintf(crm_mail_body + len, BODY_MAX - len,</a>
<a name="ln3691">                        &quot;\texpected return value: (%d) %s\r\n&quot;, target_rc,</a>
<a name="ln3692">                        services_ocf_exitcode_str(target_rc));</a>
<a name="ln3693">    }</a>
<a name="ln3694"> </a>
<a name="ln3695">    auth_client_init();</a>
<a name="ln3696">    session = smtp_create_session();</a>
<a name="ln3697">    message = smtp_add_message(session);</a>
<a name="ln3698"> </a>
<a name="ln3699">    smtp_starttls_enable(session, Starttls_ENABLED);</a>
<a name="ln3700"> </a>
<a name="ln3701">    sa.sa_handler = SIG_IGN;</a>
<a name="ln3702">    sigemptyset(&amp;sa.sa_mask);</a>
<a name="ln3703">    sa.sa_flags = 0;</a>
<a name="ln3704">    sigaction(SIGPIPE, &amp;sa, NULL);</a>
<a name="ln3705"> </a>
<a name="ln3706">    smtp_set_server(session, crm_mail_host);</a>
<a name="ln3707"> </a>
<a name="ln3708">    authctx = auth_create_context();</a>
<a name="ln3709">    auth_set_mechanism_flags(authctx, AUTH_PLUGIN_PLAIN, 0);</a>
<a name="ln3710"> </a>
<a name="ln3711">    smtp_set_eventcb(session, event_cb, NULL);</a>
<a name="ln3712"> </a>
<a name="ln3713">    /* Now tell libESMTP it can use the SMTP AUTH extension.</a>
<a name="ln3714">     */</a>
<a name="ln3715">    if (!noauth) {</a>
<a name="ln3716">        crm_debug(&quot;Adding authentication context&quot;);</a>
<a name="ln3717">        smtp_auth_set_context(session, authctx);</a>
<a name="ln3718">    }</a>
<a name="ln3719"> </a>
<a name="ln3720">    if (crm_mail_from == NULL) {</a>
<a name="ln3721">        struct utsname us;</a>
<a name="ln3722">        char auto_from[BODY_MAX];</a>
<a name="ln3723"> </a>
<a name="ln3724">        CRM_ASSERT(uname(&amp;us) == 0);</a>
<a name="ln3725">        snprintf(auto_from, BODY_MAX, &quot;crm_mon@%s&quot;, us.nodename);</a>
<a name="ln3726">        smtp_set_reverse_path(message, auto_from);</a>
<a name="ln3727"> </a>
<a name="ln3728">    } else {</a>
<a name="ln3729">        /* NULL is ok */</a>
<a name="ln3730">        smtp_set_reverse_path(message, crm_mail_from);</a>
<a name="ln3731">    }</a>
<a name="ln3732"> </a>
<a name="ln3733">    smtp_set_header(message, &quot;To&quot;, NULL /*phrase */ , NULL /*addr */ ); /* &quot;Phrase&quot; &lt;addr&gt; */</a>
<a name="ln3734">    smtp_add_recipient(message, crm_mail_to);</a>
<a name="ln3735"> </a>
<a name="ln3736">    /* Set the Subject: header and override any subject line in the message headers. */</a>
<a name="ln3737">    smtp_set_header(message, &quot;Subject&quot;, crm_mail_subject);</a>
<a name="ln3738">    smtp_set_header_option(message, &quot;Subject&quot;, Hdr_OVERRIDE, 1);</a>
<a name="ln3739"> </a>
<a name="ln3740">    smtp_set_message_str(message, crm_mail_body);</a>
<a name="ln3741">    smtp_set_monitorcb(session, crm_smtp_debug, &amp;smtp_debug, 1);</a>
<a name="ln3742"> </a>
<a name="ln3743">    if (smtp_start_session(session)) {</a>
<a name="ln3744">        char buf[128];</a>
<a name="ln3745">        int rc = smtp_errno();</a>
<a name="ln3746"> </a>
<a name="ln3747">        crm_err(&quot;SMTP server problem: %s (%d)&quot;, smtp_strerror(rc, buf, sizeof buf), rc);</a>
<a name="ln3748"> </a>
<a name="ln3749">    } else {</a>
<a name="ln3750">        char buf[128];</a>
<a name="ln3751">        int rc = smtp_errno();</a>
<a name="ln3752">        const smtp_status_t *smtp_status = smtp_message_transfer_status(message);</a>
<a name="ln3753"> </a>
<a name="ln3754">        if (rc != 0) {</a>
<a name="ln3755">            crm_err(&quot;SMTP server problem: %s (%d)&quot;, smtp_strerror(rc, buf, sizeof buf), rc);</a>
<a name="ln3756">        }</a>
<a name="ln3757">        crm_info(&quot;Send status: %d %s&quot;, smtp_status-&gt;code, crm_str(smtp_status-&gt;text));</a>
<a name="ln3758">        smtp_enumerate_recipients(message, print_recipient_status, NULL);</a>
<a name="ln3759">    }</a>
<a name="ln3760"> </a>
<a name="ln3761">    smtp_destroy_session(session);</a>
<a name="ln3762">    auth_destroy_context(authctx);</a>
<a name="ln3763">    auth_client_exit();</a>
<a name="ln3764">#endif</a>
<a name="ln3765">    return 0;</a>
<a name="ln3766">}</a>
<a name="ln3767"> </a>
<a name="ln3768">static void</a>
<a name="ln3769">handle_rsc_op(xmlNode * xml, const char *node_id)</a>
<a name="ln3770">{</a>
<a name="ln3771">    int rc = -1;</a>
<a name="ln3772">    int status = -1;</a>
<a name="ln3773">    int action = -1;</a>
<a name="ln3774">    int interval = 0;</a>
<a name="ln3775">    int target_rc = -1;</a>
<a name="ln3776">    int transition_num = -1;</a>
<a name="ln3777">    gboolean notify = TRUE;</a>
<a name="ln3778"> </a>
<a name="ln3779">    char *rsc = NULL;</a>
<a name="ln3780">    char *task = NULL;</a>
<a name="ln3781">    const char *desc = NULL;</a>
<a name="ln3782">    const char *magic = NULL;</a>
<a name="ln3783">    const char *id = NULL;</a>
<a name="ln3784">    char *update_te_uuid = NULL;</a>
<a name="ln3785">    const char *node = NULL;</a>
<a name="ln3786"> </a>
<a name="ln3787">    xmlNode *n = xml;</a>
<a name="ln3788">    xmlNode * rsc_op = xml;</a>
<a name="ln3789"> </a>
<a name="ln3790">    if(strcmp((const char*)xml-&gt;name, XML_LRM_TAG_RSC_OP) != 0) {</a>
<a name="ln3791">        xmlNode *cIter;</a>
<a name="ln3792"> </a>
<a name="ln3793">        for(cIter = xml-&gt;children; cIter; cIter = cIter-&gt;next) {</a>
<a name="ln3794">            handle_rsc_op(cIter, node_id);</a>
<a name="ln3795">        }</a>
<a name="ln3796"> </a>
<a name="ln3797">        return;</a>
<a name="ln3798">    }</a>
<a name="ln3799"> </a>
<a name="ln3800">    id = crm_element_value(rsc_op, XML_LRM_ATTR_TASK_KEY);</a>
<a name="ln3801">    if (id == NULL) {</a>
<a name="ln3802">        /* Compatibility with &lt;= 1.1.5 */</a>
<a name="ln3803">        id = ID(rsc_op);</a>
<a name="ln3804">    }</a>
<a name="ln3805"> </a>
<a name="ln3806">    magic = crm_element_value(rsc_op, XML_ATTR_TRANSITION_MAGIC);</a>
<a name="ln3807">    if (magic == NULL) {</a>
<a name="ln3808">        /* non-change */</a>
<a name="ln3809">        return;</a>
<a name="ln3810">    }</a>
<a name="ln3811"> </a>
<a name="ln3812">    if (FALSE == decode_transition_magic(magic, &amp;update_te_uuid, &amp;transition_num, &amp;action,</a>
<a name="ln3813">                                         &amp;status, &amp;rc, &amp;target_rc)) {</a>
<a name="ln3814">        crm_err(&quot;Invalid event %s detected for %s&quot;, magic, id);</a>
<a name="ln3815">        return;</a>
<a name="ln3816">    }</a>
<a name="ln3817"> </a>
<a name="ln3818">    if (parse_op_key(id, &amp;rsc, &amp;task, &amp;interval) == FALSE) {</a>
<a name="ln3819">        crm_err(&quot;Invalid event detected for %s&quot;, id);</a>
<a name="ln3820">        goto bail;</a>
<a name="ln3821">    }</a>
<a name="ln3822"> </a>
<a name="ln3823">    node = crm_element_value(rsc_op, XML_LRM_ATTR_TARGET);</a>
<a name="ln3824"> </a>
<a name="ln3825">    while (n != NULL &amp;&amp; safe_str_neq(XML_CIB_TAG_STATE, TYPE(n))) {</a>
<a name="ln3826">        n = n-&gt;parent;</a>
<a name="ln3827">    }</a>
<a name="ln3828"> </a>
<a name="ln3829">    if(node == NULL &amp;&amp; n) {</a>
<a name="ln3830">        node = crm_element_value(n, XML_ATTR_UNAME);</a>
<a name="ln3831">    }</a>
<a name="ln3832"> </a>
<a name="ln3833">    if (node == NULL &amp;&amp; n) {</a>
<a name="ln3834">        node = ID(n);</a>
<a name="ln3835">    }</a>
<a name="ln3836"> </a>
<a name="ln3837">    if (node == NULL) {</a>
<a name="ln3838">        node = node_id;</a>
<a name="ln3839">    }</a>
<a name="ln3840"> </a>
<a name="ln3841">    if (node == NULL) {</a>
<a name="ln3842">        crm_err(&quot;No node detected for event %s (%s)&quot;, magic, id);</a>
<a name="ln3843">        goto bail;</a>
<a name="ln3844">    }</a>
<a name="ln3845"> </a>
<a name="ln3846">    /* look up where we expected it to be? */</a>
<a name="ln3847">    desc = pcmk_strerror(pcmk_ok);</a>
<a name="ln3848">    if (status == PCMK_LRM_OP_DONE &amp;&amp; target_rc == rc) {</a>
<a name="ln3849">        crm_notice(&quot;%s of %s on %s completed: %s&quot;, task, rsc, node, desc);</a>
<a name="ln3850">        if (rc == PCMK_OCF_NOT_RUNNING) {</a>
<a name="ln3851">            notify = FALSE;</a>
<a name="ln3852">        }</a>
<a name="ln3853"> </a>
<a name="ln3854">    } else if (status == PCMK_LRM_OP_DONE) {</a>
<a name="ln3855">        desc = services_ocf_exitcode_str(rc);</a>
<a name="ln3856">        crm_warn(&quot;%s of %s on %s failed: %s&quot;, task, rsc, node, desc);</a>
<a name="ln3857"> </a>
<a name="ln3858">    } else {</a>
<a name="ln3859">        desc = services_lrm_status_str(status);</a>
<a name="ln3860">        crm_warn(&quot;%s of %s on %s failed: %s&quot;, task, rsc, node, desc);</a>
<a name="ln3861">    }</a>
<a name="ln3862"> </a>
<a name="ln3863">    if (notify &amp;&amp; snmp_target) {</a>
<a name="ln3864">        send_snmp_trap(node, rsc, task, target_rc, rc, status, desc);</a>
<a name="ln3865">    }</a>
<a name="ln3866">    if (notify &amp;&amp; crm_mail_to) {</a>
<a name="ln3867">        send_smtp_trap(node, rsc, task, target_rc, rc, status, desc);</a>
<a name="ln3868">    }</a>
<a name="ln3869">    if (notify &amp;&amp; external_agent) {</a>
<a name="ln3870">        send_custom_trap(node, rsc, task, target_rc, rc, status, desc);</a>
<a name="ln3871">    }</a>
<a name="ln3872">  bail:</a>
<a name="ln3873">    free(update_te_uuid);</a>
<a name="ln3874">    free(rsc);</a>
<a name="ln3875">    free(task);</a>
<a name="ln3876">}</a>
<a name="ln3877"> </a>
<a name="ln3878">static gboolean</a>
<a name="ln3879">mon_trigger_refresh(gpointer user_data)</a>
<a name="ln3880">{</a>
<a name="ln3881">    mainloop_set_trigger(refresh_trigger);</a>
<a name="ln3882">    return FALSE;</a>
<a name="ln3883">}</a>
<a name="ln3884"> </a>
<a name="ln3885">#define NODE_PATT &quot;/lrm[@id=&quot;</a>
<a name="ln3886">static char *get_node_from_xpath(const char *xpath) </a>
<a name="ln3887">{</a>
<a name="ln3888">    char *nodeid = NULL;</a>
<a name="ln3889">    char *tmp = strstr(xpath, NODE_PATT);</a>
<a name="ln3890"> </a>
<a name="ln3891">    if(tmp) {</a>
<a name="ln3892">        tmp += strlen(NODE_PATT);</a>
<a name="ln3893">        tmp += 1;</a>
<a name="ln3894"> </a>
<a name="ln3895">        nodeid = strdup(tmp);</a>
<a name="ln3896">        tmp = strstr(nodeid, &quot;\'&quot;);</a>
<a name="ln3897">        CRM_ASSERT(tmp);</a>
<a name="ln3898">        tmp[0] = 0;</a>
<a name="ln3899">    }</a>
<a name="ln3900">    return nodeid;</a>
<a name="ln3901">}</a>
<a name="ln3902"> </a>
<a name="ln3903">static void crm_diff_update_v2(const char *event, xmlNode * msg) </a>
<a name="ln3904">{</a>
<a name="ln3905">    xmlNode *change = NULL;</a>
<a name="ln3906">    xmlNode *diff = get_message_xml(msg, F_CIB_UPDATE_RESULT);</a>
<a name="ln3907"> </a>
<a name="ln3908">    for (change = __xml_first_child(diff); change != NULL; change = __xml_next(change)) {</a>
<a name="ln3909">        const char *name = NULL;</a>
<a name="ln3910">        const char *op = crm_element_value(change, XML_DIFF_OP);</a>
<a name="ln3911">        const char *xpath = crm_element_value(change, XML_DIFF_PATH);</a>
<a name="ln3912">        xmlNode *match = NULL;</a>
<a name="ln3913">        const char *node = NULL;</a>
<a name="ln3914"> </a>
<a name="ln3915">        if(op == NULL) {</a>
<a name="ln3916">            continue;</a>
<a name="ln3917"> </a>
<a name="ln3918">        } else if(strcmp(op, &quot;create&quot;) == 0) {</a>
<a name="ln3919">            match = change-&gt;children;</a>
<a name="ln3920"> </a>
<a name="ln3921">        } else if(strcmp(op, &quot;move&quot;) == 0) {</a>
<a name="ln3922">            continue;</a>
<a name="ln3923"> </a>
<a name="ln3924">        } else if(strcmp(op, &quot;delete&quot;) == 0) {</a>
<a name="ln3925">            continue;</a>
<a name="ln3926"> </a>
<a name="ln3927">        } else if(strcmp(op, &quot;modify&quot;) == 0) {</a>
<a name="ln3928">            match = first_named_child(change, XML_DIFF_RESULT);</a>
<a name="ln3929">            if(match) {</a>
<a name="ln3930">                match = match-&gt;children;</a>
<a name="ln3931">            }</a>
<a name="ln3932">        }</a>
<a name="ln3933"> </a>
<a name="ln3934">        if(match) {</a>
<a name="ln3935">            name = (const char *)match-&gt;name;</a>
<a name="ln3936">        }</a>
<a name="ln3937"> </a>
<a name="ln3938">        crm_trace(&quot;Handling %s operation for %s %p, %s&quot;, op, xpath, match, name);</a>
<a name="ln3939">        if(xpath == NULL) {</a>
<a name="ln3940">            /* Version field, ignore */</a>
<a name="ln3941"> </a>
<a name="ln3942">        } else if(name == NULL) {</a>
<a name="ln3943">            crm_debug(&quot;No result for %s operation to %s&quot;, op, xpath);</a>
<a name="ln3944">            CRM_ASSERT(strcmp(op, &quot;delete&quot;) == 0 || strcmp(op, &quot;move&quot;) == 0);</a>
<a name="ln3945"> </a>
<a name="ln3946">        } else if(strcmp(name, XML_TAG_CIB) == 0) {</a>
<a name="ln3947">            xmlNode *state = NULL;</a>
<a name="ln3948">            xmlNode *status = first_named_child(match, XML_CIB_TAG_STATUS);</a>
<a name="ln3949"> </a>
<a name="ln3950">            for (state = __xml_first_child(status); state != NULL; state = __xml_next(state)) {</a>
<a name="ln3951">                node = crm_element_value(state, XML_ATTR_UNAME);</a>
<a name="ln3952">                if (node == NULL) {</a>
<a name="ln3953">                    node = ID(state);</a>
<a name="ln3954">                }</a>
<a name="ln3955">                handle_rsc_op(state, node);</a>
<a name="ln3956">            }</a>
<a name="ln3957"> </a>
<a name="ln3958">        } else if(strcmp(name, XML_CIB_TAG_STATUS) == 0) {</a>
<a name="ln3959">            xmlNode *state = NULL;</a>
<a name="ln3960"> </a>
<a name="ln3961">            for (state = __xml_first_child(match); state != NULL; state = __xml_next(state)) {</a>
<a name="ln3962">                node = crm_element_value(state, XML_ATTR_UNAME);</a>
<a name="ln3963">                if (node == NULL) {</a>
<a name="ln3964">                    node = ID(state);</a>
<a name="ln3965">                }</a>
<a name="ln3966">                handle_rsc_op(state, node);</a>
<a name="ln3967">            }</a>
<a name="ln3968"> </a>
<a name="ln3969">        } else if(strcmp(name, XML_CIB_TAG_STATE) == 0) {</a>
<a name="ln3970">            node = crm_element_value(match, XML_ATTR_UNAME);</a>
<a name="ln3971">            if (node == NULL) {</a>
<a name="ln3972">                node = ID(match);</a>
<a name="ln3973">            }</a>
<a name="ln3974">            handle_rsc_op(match, node);</a>
<a name="ln3975"> </a>
<a name="ln3976">        } else if(strcmp(name, XML_CIB_TAG_LRM) == 0) {</a>
<a name="ln3977">            node = ID(match);</a>
<a name="ln3978">            handle_rsc_op(match, node);</a>
<a name="ln3979"> </a>
<a name="ln3980">        } else if(strcmp(name, XML_LRM_TAG_RESOURCES) == 0) {</a>
<a name="ln3981">            char *local_node = get_node_from_xpath(xpath);</a>
<a name="ln3982"> </a>
<a name="ln3983">            handle_rsc_op(match, local_node);</a>
<a name="ln3984">            free(local_node);</a>
<a name="ln3985"> </a>
<a name="ln3986">        } else if(strcmp(name, XML_LRM_TAG_RESOURCE) == 0) {</a>
<a name="ln3987">            char *local_node = get_node_from_xpath(xpath);</a>
<a name="ln3988"> </a>
<a name="ln3989">            handle_rsc_op(match, local_node);</a>
<a name="ln3990">            free(local_node);</a>
<a name="ln3991"> </a>
<a name="ln3992">        } else if(strcmp(name, XML_LRM_TAG_RSC_OP) == 0) {</a>
<a name="ln3993">            char *local_node = get_node_from_xpath(xpath);</a>
<a name="ln3994"> </a>
<a name="ln3995">            handle_rsc_op(match, local_node);</a>
<a name="ln3996">            free(local_node);</a>
<a name="ln3997"> </a>
<a name="ln3998">        } else {</a>
<a name="ln3999">            crm_trace(&quot;Ignoring %s operation for %s %p, %s&quot;, op, xpath, match, name);</a>
<a name="ln4000">        }</a>
<a name="ln4001">    }</a>
<a name="ln4002">}</a>
<a name="ln4003"> </a>
<a name="ln4004">static void crm_diff_update_v1(const char *event, xmlNode * msg) </a>
<a name="ln4005">{</a>
<a name="ln4006">    /* Process operation updates */</a>
<a name="ln4007">    xmlXPathObject *xpathObj = xpath_search(msg,</a>
<a name="ln4008">                                            &quot;//&quot; F_CIB_UPDATE_RESULT &quot;//&quot; XML_TAG_DIFF_ADDED</a>
<a name="ln4009">                                            &quot;//&quot; XML_LRM_TAG_RSC_OP);</a>
<a name="ln4010">    int lpc = 0, max = numXpathResults(xpathObj);</a>
<a name="ln4011"> </a>
<a name="ln4012">    for (lpc = 0; lpc &lt; max; lpc++) {</a>
<a name="ln4013">        xmlNode *rsc_op = getXpathResult(xpathObj, lpc);</a>
<a name="ln4014"> </a>
<a name="ln4015">        handle_rsc_op(rsc_op, NULL);</a>
<a name="ln4016">    }</a>
<a name="ln4017">    freeXpathObject(xpathObj);</a>
<a name="ln4018">}</a>
<a name="ln4019"> </a>
<a name="ln4020">void</a>
<a name="ln4021">crm_diff_update(const char *event, xmlNode * msg)</a>
<a name="ln4022">{</a>
<a name="ln4023">    int rc = -1;</a>
<a name="ln4024">    long now = time(NULL);</a>
<a name="ln4025">    static bool stale = FALSE;</a>
<a name="ln4026">    static int updates = 0;</a>
<a name="ln4027">    static mainloop_timer_t *refresh_timer = NULL;</a>
<a name="ln4028">    xmlNode *diff = get_message_xml(msg, F_CIB_UPDATE_RESULT);</a>
<a name="ln4029"> </a>
<a name="ln4030">    print_dot();</a>
<a name="ln4031"> </a>
<a name="ln4032">    if(refresh_timer == NULL) {</a>
<a name="ln4033">        refresh_timer = mainloop_timer_add(&quot;refresh&quot;, 2000, FALSE, mon_trigger_refresh, NULL);</a>
<a name="ln4034">    }</a>
<a name="ln4035"> </a>
<a name="ln4036">    if (current_cib != NULL) {</a>
<a name="ln4037">        rc = xml_apply_patchset(current_cib, diff, TRUE);</a>
<a name="ln4038"> </a>
<a name="ln4039">        switch (rc) {</a>
<a name="ln4040">            case -pcmk_err_diff_resync:</a>
<a name="ln4041">            case -pcmk_err_diff_failed:</a>
<a name="ln4042">                crm_notice(&quot;[%s] Patch aborted: %s (%d)&quot;, event, pcmk_strerror(rc), rc);</a>
<a name="ln4043">                free_xml(current_cib); current_cib = NULL;</a>
<a name="ln4044">                break;</a>
<a name="ln4045">            case pcmk_ok:</a>
<a name="ln4046">                updates++;</a>
<a name="ln4047">                break;</a>
<a name="ln4048">            default:</a>
<a name="ln4049">                crm_notice(&quot;[%s] ABORTED: %s (%d)&quot;, event, pcmk_strerror(rc), rc);</a>
<a name="ln4050">                free_xml(current_cib); current_cib = NULL;</a>
<a name="ln4051">        }</a>
<a name="ln4052">    }</a>
<a name="ln4053"> </a>
<a name="ln4054">    if (current_cib == NULL) {</a>
<a name="ln4055">        crm_trace(&quot;Re-requesting the full cib&quot;);</a>
<a name="ln4056">        cib-&gt;cmds-&gt;query(cib, NULL, &amp;current_cib, cib_scope_local | cib_sync_call);</a>
<a name="ln4057">    }</a>
<a name="ln4058"> </a>
<a name="ln4059">    if (crm_mail_to || snmp_target || external_agent) {</a>
<a name="ln4060">        int format = 0;</a>
<a name="ln4061">        crm_element_value_int(diff, &quot;format&quot;, &amp;format);</a>
<a name="ln4062">        switch(format) {</a>
<a name="ln4063">            case 1:</a>
<a name="ln4064">                crm_diff_update_v1(event, msg);</a>
<a name="ln4065">                break;</a>
<a name="ln4066">            case 2:</a>
<a name="ln4067">                crm_diff_update_v2(event, msg);</a>
<a name="ln4068">                break;</a>
<a name="ln4069">            default:</a>
<a name="ln4070">                crm_err(&quot;Unknown patch format: %d&quot;, format);</a>
<a name="ln4071">        }</a>
<a name="ln4072">    }</a>
<a name="ln4073"> </a>
<a name="ln4074">    if (current_cib == NULL) {</a>
<a name="ln4075">        if(!stale) {</a>
<a name="ln4076">            print_as(&quot;--- Stale data ---&quot;);</a>
<a name="ln4077">        }</a>
<a name="ln4078">        stale = TRUE;</a>
<a name="ln4079">        return;</a>
<a name="ln4080">    }</a>
<a name="ln4081"> </a>
<a name="ln4082">    stale = FALSE;</a>
<a name="ln4083">    /* Refresh</a>
<a name="ln4084">     * - immediately if the last update was more than 5s ago</a>
<a name="ln4085">     * - every 10 updates</a>
<a name="ln4086">     * - at most 2s after the last update</a>
<a name="ln4087">     */</a>
<a name="ln4088">    if ((now - last_refresh) &gt; (reconnect_msec / 1000)) {</a>
<a name="ln4089">        mainloop_set_trigger(refresh_trigger);</a>
<a name="ln4090">        mainloop_timer_stop(refresh_timer);</a>
<a name="ln4091">        updates = 0;</a>
<a name="ln4092"> </a>
<a name="ln4093">    } else if(updates &gt; 10) {</a>
<a name="ln4094">        mainloop_set_trigger(refresh_trigger);</a>
<a name="ln4095">        mainloop_timer_stop(refresh_timer);</a>
<a name="ln4096">        updates = 0;</a>
<a name="ln4097"> </a>
<a name="ln4098">    } else {</a>
<a name="ln4099">        mainloop_timer_start(refresh_timer);</a>
<a name="ln4100">    }</a>
<a name="ln4101">}</a>
<a name="ln4102"> </a>
<a name="ln4103">gboolean</a>
<a name="ln4104">mon_refresh_display(gpointer user_data)</a>
<a name="ln4105">{</a>
<a name="ln4106">    xmlNode *cib_copy = copy_xml(current_cib);</a>
<a name="ln4107">    pe_working_set_t data_set;</a>
<a name="ln4108"> </a>
<a name="ln4109">    last_refresh = time(NULL);</a>
<a name="ln4110"> </a>
<a name="ln4111">    if (cli_config_update(&amp;cib_copy, NULL, FALSE) == FALSE) {</a>
<a name="ln4112">        if (cib) {</a>
<a name="ln4113">            cib-&gt;cmds-&gt;signoff(cib);</a>
<a name="ln4114">        }</a>
<a name="ln4115">        print_as(&quot;Upgrade failed: %s&quot;, pcmk_strerror(-pcmk_err_schema_validation));</a>
<a name="ln4116">        if (output_format == mon_output_console) {</a>
<a name="ln4117">            sleep(2);</a>
<a name="ln4118">        }</a>
<a name="ln4119">        clean_up(EX_USAGE);</a>
<a name="ln4120">        return FALSE;</a>
<a name="ln4121">    }</a>
<a name="ln4122"> </a>
<a name="ln4123">    set_working_set_defaults(&amp;data_set);</a>
<a name="ln4124">    data_set.input = cib_copy;</a>
<a name="ln4125">    cluster_status(&amp;data_set);</a>
<a name="ln4126"> </a>
<a name="ln4127">    /* Unpack constraints if any section will need them</a>
<a name="ln4128">     * (tickets may be referenced in constraints but not granted yet,</a>
<a name="ln4129">     * and bans need negative location constraints) */</a>
<a name="ln4130">    if (show &amp; (mon_show_bans | mon_show_tickets)) {</a>
<a name="ln4131">        xmlNode *cib_constraints = get_object_root(XML_CIB_TAG_CONSTRAINTS, data_set.input);</a>
<a name="ln4132">        unpack_constraints(cib_constraints, &amp;data_set);</a>
<a name="ln4133">    }</a>
<a name="ln4134"> </a>
<a name="ln4135">    switch (output_format) {</a>
<a name="ln4136">        case mon_output_html:</a>
<a name="ln4137">        case mon_output_cgi:</a>
<a name="ln4138">            if (print_html_status(&amp;data_set, output_filename) != 0) {</a>
<a name="ln4139">                fprintf(stderr, &quot;Critical: Unable to output html file\n&quot;);</a>
<a name="ln4140">                clean_up(EX_USAGE);</a>
<a name="ln4141">            }</a>
<a name="ln4142">            break;</a>
<a name="ln4143"> </a>
<a name="ln4144">        case mon_output_xml:</a>
<a name="ln4145">            print_xml_status(&amp;data_set);</a>
<a name="ln4146">            break;</a>
<a name="ln4147"> </a>
<a name="ln4148">        case mon_output_monitor:</a>
<a name="ln4149">            print_simple_status(&amp;data_set);</a>
<a name="ln4150">            if (has_warnings) {</a>
<a name="ln4151">                clean_up(MON_STATUS_WARN);</a>
<a name="ln4152">            }</a>
<a name="ln4153">            break;</a>
<a name="ln4154"> </a>
<a name="ln4155">        case mon_output_plain:</a>
<a name="ln4156">        case mon_output_console:</a>
<a name="ln4157">            print_status(&amp;data_set);</a>
<a name="ln4158">            break;</a>
<a name="ln4159"> </a>
<a name="ln4160">        case mon_output_none:</a>
<a name="ln4161">            break;</a>
<a name="ln4162">    }</a>
<a name="ln4163"> </a>
<a name="ln4164">    cleanup_alloc_calculations(&amp;data_set);</a>
<a name="ln4165">    return TRUE;</a>
<a name="ln4166">}</a>
<a name="ln4167"> </a>
<a name="ln4168">void</a>
<a name="ln4169">mon_st_callback(stonith_t * st, stonith_event_t * e)</a>
<a name="ln4170">{</a>
<a name="ln4171">    char *desc = crm_strdup_printf(&quot;Operation %s requested by %s for peer %s: %s (ref=%s)&quot;,</a>
<a name="ln4172">                                 e-&gt;operation, e-&gt;origin, e-&gt;target, pcmk_strerror(e-&gt;result),</a>
<a name="ln4173">                                 e-&gt;id);</a>
<a name="ln4174"> </a>
<a name="ln4175">    if (snmp_target) {</a>
<a name="ln4176">        send_snmp_trap(e-&gt;target, NULL, e-&gt;operation, pcmk_ok, e-&gt;result, 0, desc);</a>
<a name="ln4177">    }</a>
<a name="ln4178">    if (crm_mail_to) {</a>
<a name="ln4179">        send_smtp_trap(e-&gt;target, NULL, e-&gt;operation, pcmk_ok, e-&gt;result, 0, desc);</a>
<a name="ln4180">    }</a>
<a name="ln4181">    if (external_agent) {</a>
<a name="ln4182">        send_custom_trap(e-&gt;target, NULL, e-&gt;operation, pcmk_ok, e-&gt;result, 0, desc);</a>
<a name="ln4183">    }</a>
<a name="ln4184">    free(desc);</a>
<a name="ln4185">}</a>
<a name="ln4186"> </a>
<a name="ln4187">/*</a>
<a name="ln4188"> * De-init ncurses, signoff from the CIB and deallocate memory.</a>
<a name="ln4189"> */</a>
<a name="ln4190">void</a>
<a name="ln4191">clean_up(int rc)</a>
<a name="ln4192">{</a>
<a name="ln4193">#if ENABLE_SNMP</a>
<a name="ln4194">    netsnmp_session *session = crm_snmp_init(NULL, NULL);</a>
<a name="ln4195"> </a>
<a name="ln4196">    if (session) {</a>
<a name="ln4197">        snmp_close(session);</a>
<a name="ln4198">        snmp_shutdown(&quot;snmpapp&quot;);</a>
<a name="ln4199">    }</a>
<a name="ln4200">#endif</a>
<a name="ln4201"> </a>
<a name="ln4202">#if CURSES_ENABLED</a>
<a name="ln4203">    if (output_format == mon_output_console) {</a>
<a name="ln4204">        output_format = mon_output_plain;</a>
<a name="ln4205">        echo();</a>
<a name="ln4206">        nocbreak();</a>
<a name="ln4207">        endwin();</a>
<a name="ln4208">    }</a>
<a name="ln4209">#endif</a>
<a name="ln4210"> </a>
<a name="ln4211">    if (cib != NULL) {</a>
<a name="ln4212">        cib-&gt;cmds-&gt;signoff(cib);</a>
<a name="ln4213">        cib_delete(cib);</a>
<a name="ln4214">        cib = NULL;</a>
<a name="ln4215">    }</a>
<a name="ln4216"> </a>
<a name="ln4217">    free(output_filename);</a>
<a name="ln4218">    free(xml_file);</a>
<a name="ln4219">    free(pid_file);</a>
<a name="ln4220"> </a>
<a name="ln4221">    if (rc &gt;= 0) {</a>
<a name="ln4222">        crm_exit(rc);</a>
<a name="ln4223">    }</a>
<a name="ln4224">    return;</a>
<a name="ln4225">}</a>

</code></pre>
<div class="balloon" rel="125"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'st' variable.</p></div>
<div class="balloon" rel="327"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V547/" target="_blank">V547</a> Expression 'rc == 0' is always true.</p></div>
<div class="balloon" rel="327"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V571/" target="_blank">V571</a> Recurring check. The 'rc == 0' condition was already verified in line 326.</p></div>
<div class="balloon" rel="415"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V564/" target="_blank">V564</a> The '|' operator is applied to bool type value. You've probably forgotten to include parentheses or intended to use the '||' operator.</p></div>
<div class="balloon" rel="416"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V564/" target="_blank">V564</a> The '|' operator is applied to bool type value. You've probably forgotten to include parentheses or intended to use the '||' operator.</p></div>
<div class="balloon" rel="417"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V564/" target="_blank">V564</a> The '|' operator is applied to bool type value. You've probably forgotten to include parentheses or intended to use the '||' operator.</p></div>
<div class="balloon" rel="418"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V564/" target="_blank">V564</a> The '|' operator is applied to bool type value. You've probably forgotten to include parentheses or intended to use the '||' operator.</p></div>
<div class="balloon" rel="1968"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'strcpy' function. Inspect the first argument. Check lines: 1968, 1966.</p></div>
<div class="balloon" rel="1997"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V576/" target="_blank">V576</a> Incorrect format. Consider checking the sixth actual argument of the 'fprintf' function. Under certain conditions the pointer can be null.</p></div>
<div class="balloon" rel="2656"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V547/" target="_blank">V547</a> Expression 'header_printed == 0' is always true.</p></div>
<div class="balloon" rel="2988"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'fprintf' function. Under certain conditions the pointer can be null.</p></div>
<div class="balloon" rel="3221"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'fprintf' function. Under certain conditions the pointer can be null.</p></div>
<div class="balloon" rel="3896"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'strstr' function. Inspect the first argument. Check lines: 3896, 3895.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
