
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (C) 2013 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * This program is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2 of the License, or (at your option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This software is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;crm_internal.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;sys/param.h&gt;</a>
<a name="ln26">#include &lt;stdio.h&gt;</a>
<a name="ln27">#include &lt;sys/types.h&gt;</a>
<a name="ln28">#include &lt;sys/stat.h&gt;</a>
<a name="ln29">#include &lt;unistd.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &lt;stdlib.h&gt;</a>
<a name="ln32">#include &lt;errno.h&gt;</a>
<a name="ln33">#include &lt;fcntl.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;crm/crm.h&gt;</a>
<a name="ln36">#include &lt;crm/cib/internal.h&gt;</a>
<a name="ln37">#include &lt;crm/msg_xml.h&gt;</a>
<a name="ln38">#include &lt;crm/common/ipc.h&gt;</a>
<a name="ln39">#include &lt;crm/common/ipcs.h&gt;</a>
<a name="ln40">#include &lt;crm/cluster/internal.h&gt;</a>
<a name="ln41">#include &lt;crm/cluster/election.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;crm/common/xml.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;crm/attrd.h&gt;</a>
<a name="ln46">#include &lt;internal.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">cib_t *the_cib = NULL;</a>
<a name="ln49">crm_cluster_t *attrd_cluster = NULL;</a>
<a name="ln50">election_t *writer = NULL;</a>
<a name="ln51">int attrd_error = pcmk_ok;</a>
<a name="ln52"> </a>
<a name="ln53">static void</a>
<a name="ln54">attrd_cpg_dispatch(cpg_handle_t handle,</a>
<a name="ln55">                 const struct cpg_name *groupName,</a>
<a name="ln56">                 uint32_t nodeid, uint32_t pid, void *msg, size_t msg_len)</a>
<a name="ln57">{</a>
<a name="ln58">    uint32_t kind = 0;</a>
<a name="ln59">    xmlNode *xml = NULL;</a>
<a name="ln60">    const char *from = NULL;</a>
<a name="ln61">    char *data = pcmk_message_common_cs(handle, nodeid, pid, msg, &amp;kind, &amp;from);</a>
<a name="ln62"> </a>
<a name="ln63">    if(data == NULL) {</a>
<a name="ln64">        return;</a>
<a name="ln65">    }</a>
<a name="ln66"> </a>
<a name="ln67">    if (kind == crm_class_cluster) {</a>
<a name="ln68">        xml = string2xml(data);</a>
<a name="ln69">    }</a>
<a name="ln70"> </a>
<a name="ln71">    if (xml == NULL) {</a>
<a name="ln72">        crm_err(&quot;Bad message of class %d received from %s[%u]: '%.120s'&quot;, kind, from, nodeid, data);</a>
<a name="ln73">    } else {</a>
<a name="ln74">        crm_node_t *peer = crm_get_peer(nodeid, from);</a>
<a name="ln75"> </a>
<a name="ln76">        attrd_peer_message(peer, xml);</a>
<a name="ln77">    }</a>
<a name="ln78"> </a>
<a name="ln79">    free_xml(xml);</a>
<a name="ln80">    free(data);</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">static void</a>
<a name="ln84">attrd_cpg_destroy(gpointer unused)</a>
<a name="ln85">{</a>
<a name="ln86">    if (attrd_shutting_down()) {</a>
<a name="ln87">        crm_info(&quot;Corosync disconnection complete&quot;);</a>
<a name="ln88"> </a>
<a name="ln89">    } else {</a>
<a name="ln90">        crm_crit(&quot;Lost connection to Corosync service!&quot;);</a>
<a name="ln91">        attrd_error = ECONNRESET;</a>
<a name="ln92">        attrd_shutdown(0);</a>
<a name="ln93">    }</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">static void</a>
<a name="ln97">attrd_cib_replaced_cb(const char *event, xmlNode * msg)</a>
<a name="ln98">{</a>
<a name="ln99">    crm_notice(&quot;Updating all attributes after %s event&quot;, event);</a>
<a name="ln100">    if(election_state(writer) == election_won) {</a>
<a name="ln101">        write_attributes(TRUE, FALSE);</a>
<a name="ln102">    }</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">static void</a>
<a name="ln106">attrd_cib_destroy_cb(gpointer user_data)</a>
<a name="ln107">{</a>
<a name="ln108">    cib_t *conn = user_data;</a>
<a name="ln109"> </a>
<a name="ln110">    conn-&gt;cmds-&gt;signoff(conn);  /* Ensure IPC is cleaned up */</a>
<a name="ln111"> </a>
<a name="ln112">    if (attrd_shutting_down()) {</a>
<a name="ln113">        crm_info(&quot;Connection disconnection complete&quot;);</a>
<a name="ln114"> </a>
<a name="ln115">    } else {</a>
<a name="ln116">        /* eventually this should trigger a reconnect, not a shutdown */</a>
<a name="ln117">        crm_err(&quot;Lost connection to CIB service!&quot;);</a>
<a name="ln118">        attrd_error = ECONNRESET;</a>
<a name="ln119">        attrd_shutdown(0);</a>
<a name="ln120">    }</a>
<a name="ln121"> </a>
<a name="ln122">    return;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">static cib_t *</a>
<a name="ln126">attrd_cib_connect(int max_retry)</a>
<a name="ln127">{</a>
<a name="ln128">    int rc = -ENOTCONN;</a>
<a name="ln129">    static int attempts = 0;</a>
<a name="ln130">    cib_t *connection = cib_new();</a>
<a name="ln131"> </a>
<a name="ln132">    if(connection == NULL) {</a>
<a name="ln133">        return NULL;</a>
<a name="ln134">    }</a>
<a name="ln135"> </a>
<a name="ln136">    do {</a>
<a name="ln137">        if(attempts &gt; 0) {</a>
<a name="ln138">            sleep(attempts);</a>
<a name="ln139">        }</a>
<a name="ln140"> </a>
<a name="ln141">        attempts++;</a>
<a name="ln142">        crm_debug(&quot;CIB signon attempt %d&quot;, attempts);</a>
<a name="ln143">        rc = connection-&gt;cmds-&gt;signon(connection, T_ATTRD, cib_command);</a>
<a name="ln144"> </a>
<a name="ln145">    } while(rc != pcmk_ok &amp;&amp; attempts &lt; max_retry);</a>
<a name="ln146"> </a>
<a name="ln147">    if (rc != pcmk_ok) {</a>
<a name="ln148">        crm_err(&quot;Signon to CIB failed: %s (%d)&quot;, pcmk_strerror(rc), rc);</a>
<a name="ln149">        goto cleanup;</a>
<a name="ln150">    }</a>
<a name="ln151"> </a>
<a name="ln152">    crm_info(&quot;Connected to the CIB after %d attempts&quot;, attempts);</a>
<a name="ln153"> </a>
<a name="ln154">    rc = connection-&gt;cmds-&gt;set_connection_dnotify(connection, attrd_cib_destroy_cb);</a>
<a name="ln155">    if (rc != pcmk_ok) {</a>
<a name="ln156">        crm_err(&quot;Could not set disconnection callback&quot;);</a>
<a name="ln157">        goto cleanup;</a>
<a name="ln158">    }</a>
<a name="ln159"> </a>
<a name="ln160">    rc = connection-&gt;cmds-&gt;add_notify_callback(connection, T_CIB_REPLACE_NOTIFY, attrd_cib_replaced_cb);</a>
<a name="ln161">    if(rc != pcmk_ok) {</a>
<a name="ln162">        crm_err(&quot;Could not set CIB notification callback&quot;);</a>
<a name="ln163">        goto cleanup;</a>
<a name="ln164">    }</a>
<a name="ln165"> </a>
<a name="ln166">    return connection;</a>
<a name="ln167"> </a>
<a name="ln168">  cleanup:</a>
<a name="ln169">    connection-&gt;cmds-&gt;signoff(connection);</a>
<a name="ln170">    cib_delete(connection);</a>
<a name="ln171">    return NULL;</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">static int32_t</a>
<a name="ln175">attrd_ipc_dispatch(qb_ipcs_connection_t * c, void *data, size_t size)</a>
<a name="ln176">{</a>
<a name="ln177">    uint32_t id = 0;</a>
<a name="ln178">    uint32_t flags = 0;</a>
<a name="ln179">    crm_client_t *client = crm_client_get(c);</a>
<a name="ln180">    xmlNode *xml = crm_ipcs_recv(client, data, size, &amp;id, &amp;flags);</a>
<a name="ln181">    const char *op;</a>
<a name="ln182"> </a>
<a name="ln183">    if (xml == NULL) {</a>
<a name="ln184">        crm_debug(&quot;No msg from %d (%p)&quot;, crm_ipcs_client_pid(c), c);</a>
<a name="ln185">        return 0;</a>
<a name="ln186">    }</a>
<a name="ln187">#if ENABLE_ACL</a>
<a name="ln188">    CRM_ASSERT(client-&gt;user != NULL);</a>
<a name="ln189">    crm_acl_get_set_user(xml, F_ATTRD_USER, client-&gt;user);</a>
<a name="ln190">#endif</a>
<a name="ln191"> </a>
<a name="ln192">    crm_trace(&quot;Processing msg from %d (%p)&quot;, crm_ipcs_client_pid(c), c);</a>
<a name="ln193">    crm_log_xml_trace(xml, __FUNCTION__);</a>
<a name="ln194"> </a>
<a name="ln195">    op = crm_element_value(xml, F_ATTRD_TASK);</a>
<a name="ln196"> </a>
<a name="ln197">    if (client-&gt;name == NULL) {</a>
<a name="ln198">        const char *value = crm_element_value(xml, F_ORIG);</a>
<a name="ln199">        client-&gt;name = crm_strdup_printf(&quot;%s.%d&quot;, value?value:&quot;unknown&quot;, client-&gt;pid);</a>
<a name="ln200">    }</a>
<a name="ln201"> </a>
<a name="ln202">    if (safe_str_eq(op, ATTRD_OP_PEER_REMOVE)) {</a>
<a name="ln203">        attrd_send_ack(client, id, flags);</a>
<a name="ln204">        attrd_client_peer_remove(client-&gt;name, xml);</a>
<a name="ln205"> </a>
<a name="ln206">    } else if (safe_str_eq(op, ATTRD_OP_CLEAR_FAILURE)) {</a>
<a name="ln207">        attrd_send_ack(client, id, flags);</a>
<a name="ln208">        attrd_client_clear_failure(xml);</a>
<a name="ln209"> </a>
<a name="ln210">    } else if (safe_str_eq(op, ATTRD_OP_UPDATE)) {</a>
<a name="ln211">        attrd_send_ack(client, id, flags);</a>
<a name="ln212">        attrd_client_update(xml);</a>
<a name="ln213"> </a>
<a name="ln214">    } else if (safe_str_eq(op, ATTRD_OP_UPDATE_BOTH)) {</a>
<a name="ln215">        attrd_send_ack(client, id, flags);</a>
<a name="ln216">        attrd_client_update(xml);</a>
<a name="ln217"> </a>
<a name="ln218">    } else if (safe_str_eq(op, ATTRD_OP_UPDATE_DELAY)) {</a>
<a name="ln219">        attrd_send_ack(client, id, flags);</a>
<a name="ln220">        attrd_client_update(xml);</a>
<a name="ln221">  </a>
<a name="ln222">    } else if (safe_str_eq(op, ATTRD_OP_REFRESH)) {</a>
<a name="ln223">        attrd_send_ack(client, id, flags);</a>
<a name="ln224">        attrd_client_refresh();</a>
<a name="ln225"> </a>
<a name="ln226">    } else if (safe_str_eq(op, ATTRD_OP_QUERY)) {</a>
<a name="ln227">        /* queries will get reply, so no ack is necessary */</a>
<a name="ln228">        attrd_client_query(client, id, flags, xml);</a>
<a name="ln229"> </a>
<a name="ln230">    } else {</a>
<a name="ln231">        crm_info(&quot;Ignoring request from client %s with unknown operation %s&quot;,</a>
<a name="ln232">                 client-&gt;name, op);</a>
<a name="ln233">    }</a>
<a name="ln234"> </a>
<a name="ln235">    free_xml(xml);</a>
<a name="ln236">    return 0;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">/* *INDENT-OFF* */</a>
<a name="ln240">static struct crm_option long_options[] = {</a>
<a name="ln241">    /* Top-level Options */</a>
<a name="ln242">    {&quot;help&quot;,    0, 0, '?', &quot;\tThis text&quot;},</a>
<a name="ln243">    {&quot;verbose&quot;, 0, 0, 'V', &quot;\tIncrease debug output&quot;},</a>
<a name="ln244"> </a>
<a name="ln245">    {0, 0, 0, 0}</a>
<a name="ln246">};</a>
<a name="ln247">/* *INDENT-ON* */</a>
<a name="ln248"> </a>
<a name="ln249">int</a>
<a name="ln250">main(int argc, char **argv)</a>
<a name="ln251">{</a>
<a name="ln252">    int rc = pcmk_ok;</a>
<a name="ln253">    int flag = 0;</a>
<a name="ln254">    int index = 0;</a>
<a name="ln255">    int argerr = 0;</a>
<a name="ln256">    qb_ipcs_service_t *ipcs = NULL;</a>
<a name="ln257"> </a>
<a name="ln258">    attrd_init_mainloop();</a>
<a name="ln259">    crm_log_preinit(NULL, argc, argv);</a>
<a name="ln260">    crm_set_options(NULL, &quot;[options]&quot;, long_options,</a>
<a name="ln261">                    &quot;Daemon for aggregating and atomically storing node attribute updates into the CIB&quot;);</a>
<a name="ln262"> </a>
<a name="ln263">    mainloop_add_signal(SIGTERM, attrd_shutdown);</a>
<a name="ln264"> </a>
<a name="ln265">     while (1) {</a>
<a name="ln266">        flag = crm_get_option(argc, argv, &amp;index);</a>
<a name="ln267">        if (flag == -1)</a>
<a name="ln268">            break;</a>
<a name="ln269"> </a>
<a name="ln270">        switch (flag) {</a>
<a name="ln271">            case 'V':</a>
<a name="ln272">                crm_bump_log_level(argc, argv);</a>
<a name="ln273">                break;</a>
<a name="ln274">            case 'h':          /* Help message */</a>
<a name="ln275">                crm_help(flag, EX_OK);</a>
<a name="ln276">                break;</a>
<a name="ln277">            default:</a>
<a name="ln278">                ++argerr;</a>
<a name="ln279">                break;</a>
<a name="ln280">        }</a>
<a name="ln281">    }</a>
<a name="ln282"> </a>
<a name="ln283">    if (optind &gt; argc) {</a>
<a name="ln284">        ++argerr;</a>
<a name="ln285">    }</a>
<a name="ln286"> </a>
<a name="ln287">    if (argerr) {</a>
<a name="ln288">        crm_help('?', EX_USAGE);</a>
<a name="ln289">    }</a>
<a name="ln290"> </a>
<a name="ln291">    crm_log_init(T_ATTRD, LOG_INFO, TRUE, FALSE, argc, argv, FALSE);</a>
<a name="ln292">    crm_info(&quot;Starting up&quot;);</a>
<a name="ln293">    attributes = g_hash_table_new_full(crm_str_hash, g_str_equal, NULL, free_attribute);</a>
<a name="ln294"> </a>
<a name="ln295">    attrd_cluster = malloc(sizeof(crm_cluster_t));</a>
<a name="ln296"> </a>
<a name="ln297">    attrd_cluster-&gt;destroy = attrd_cpg_destroy;</a>
<a name="ln298">    attrd_cluster-&gt;cpg.cpg_deliver_fn = attrd_cpg_dispatch;</a>
<a name="ln299">    attrd_cluster-&gt;cpg.cpg_confchg_fn = pcmk_cpg_membership;</a>
<a name="ln300"> </a>
<a name="ln301">    crm_set_status_callback(&amp;attrd_peer_change_cb);</a>
<a name="ln302"> </a>
<a name="ln303">    if (crm_cluster_connect(attrd_cluster) == FALSE) {</a>
<a name="ln304">        crm_err(&quot;Cluster connection failed&quot;);</a>
<a name="ln305">        rc = DAEMON_RESPAWN_STOP;</a>
<a name="ln306">        goto done;</a>
<a name="ln307">    }</a>
<a name="ln308">    crm_info(&quot;Cluster connection active&quot;);</a>
<a name="ln309"> </a>
<a name="ln310">    writer = election_init(T_ATTRD, attrd_cluster-&gt;uname, 120000, attrd_election_cb);</a>
<a name="ln311">    attrd_init_ipc(&amp;ipcs, attrd_ipc_dispatch);</a>
<a name="ln312">    crm_info(&quot;Accepting attribute updates&quot;);</a>
<a name="ln313"> </a>
<a name="ln314">    the_cib = attrd_cib_connect(10);</a>
<a name="ln315">    if (the_cib == NULL) {</a>
<a name="ln316">        rc = DAEMON_RESPAWN_STOP;</a>
<a name="ln317">        goto done;</a>
<a name="ln318">    }</a>
<a name="ln319"> </a>
<a name="ln320">    crm_info(&quot;CIB connection active&quot;);</a>
<a name="ln321">    attrd_run_mainloop();</a>
<a name="ln322"> </a>
<a name="ln323">  done:</a>
<a name="ln324">    crm_info(&quot;Shutting down attribute manager&quot;);</a>
<a name="ln325"> </a>
<a name="ln326">    election_fini(writer);</a>
<a name="ln327">    if (ipcs) {</a>
<a name="ln328">        crm_client_disconnect_all(ipcs);</a>
<a name="ln329">        qb_ipcs_destroy(ipcs);</a>
<a name="ln330">        g_hash_table_destroy(attributes);</a>
<a name="ln331">    }</a>
<a name="ln332"> </a>
<a name="ln333">    if (the_cib) {</a>
<a name="ln334">        the_cib-&gt;cmds-&gt;signoff(the_cib);</a>
<a name="ln335">        cib_delete(the_cib);</a>
<a name="ln336">    }</a>
<a name="ln337"> </a>
<a name="ln338">    if(attrd_error) {</a>
<a name="ln339">        return crm_exit(attrd_error);</a>
<a name="ln340">    }</a>
<a name="ln341">    return crm_exit(rc);</a>
<a name="ln342">}</a>

</code></pre>
<div class="balloon" rel="297"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'attrd_cluster'. Check lines: 297, 295.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
