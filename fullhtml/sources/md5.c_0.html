
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/* Functions to compute MD5 message digest of files or memory blocks.</a>
<a name="ln6">   according to the definition of MD5 in RFC 1321 from April 1992.</a>
<a name="ln7">   Copyright (C) 1995-1997, 1999-2001, 2005-2006, 2008-2012 Free Software</a>
<a name="ln8">   Foundation, Inc.</a>
<a name="ln9">   This file is part of the GNU C Library.</a>
<a name="ln10"> </a>
<a name="ln11">   This program is free software; you can redistribute it and/or modify it</a>
<a name="ln12">   under the terms of the GNU Lesser General Public License as published by the</a>
<a name="ln13">   Free Software Foundation; either version 2.1, or (at your option) any</a>
<a name="ln14">   later version.</a>
<a name="ln15"> </a>
<a name="ln16">   This program is distributed in the hope that it will be useful,</a>
<a name="ln17">   but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln18">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln19">   GNU Lesser General Public License for more details.</a>
<a name="ln20"> </a>
<a name="ln21">   You should have received a copy of the GNU Lesser General Public License</a>
<a name="ln22">   along with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.  */</a>
<a name="ln23"> </a>
<a name="ln24">/* Written by Ulrich Drepper &lt;drepper@gnu.ai.mit.edu&gt;, 1995.  */</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;config.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;md5.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;stdalign.h&gt;</a>
<a name="ln31">#include &lt;stdint.h&gt;</a>
<a name="ln32">#include &lt;stdlib.h&gt;</a>
<a name="ln33">#include &lt;string.h&gt;</a>
<a name="ln34">#include &lt;sys/types.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#if USE_UNLOCKED_IO</a>
<a name="ln37"># include &quot;unlocked-io.h&quot;</a>
<a name="ln38">#endif</a>
<a name="ln39"> </a>
<a name="ln40">#ifdef _LIBC</a>
<a name="ln41"># include &lt;endian.h&gt;</a>
<a name="ln42"># if __BYTE_ORDER == __BIG_ENDIAN</a>
<a name="ln43">#  define WORDS_BIGENDIAN 1</a>
<a name="ln44"># endif</a>
<a name="ln45">/* We need to keep the namespace clean so define the MD5 function</a>
<a name="ln46">   protected using leading __ .  */</a>
<a name="ln47"># define md5_init_ctx __md5_init_ctx</a>
<a name="ln48"># define md5_process_block __md5_process_block</a>
<a name="ln49"># define md5_process_bytes __md5_process_bytes</a>
<a name="ln50"># define md5_finish_ctx __md5_finish_ctx</a>
<a name="ln51"># define md5_read_ctx __md5_read_ctx</a>
<a name="ln52"># define md5_stream __md5_stream</a>
<a name="ln53"># define md5_buffer __md5_buffer</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">#ifdef WORDS_BIGENDIAN</a>
<a name="ln57"># define SWAP(n)                                                        \</a>
<a name="ln58">    (((n) &lt;&lt; 24) | (((n) &amp; 0xff00) &lt;&lt; 8) | (((n) &gt;&gt; 8) &amp; 0xff00) | ((n) &gt;&gt; 24))</a>
<a name="ln59">#else</a>
<a name="ln60"># define SWAP(n) (n)</a>
<a name="ln61">#endif</a>
<a name="ln62"> </a>
<a name="ln63">#define BLOCKSIZE 32768</a>
<a name="ln64">#if BLOCKSIZE % 64 != 0</a>
<a name="ln65"># error &quot;invalid BLOCKSIZE&quot;</a>
<a name="ln66">#endif</a>
<a name="ln67"> </a>
<a name="ln68">/* This array contains the bytes used to pad the buffer to the next</a>
<a name="ln69">   64-byte boundary.  (RFC 1321, 3.1: Step 1)  */</a>
<a name="ln70">static const unsigned char fillbuf[64] = { 0x80, 0 /* , 0, 0, ...  */ };</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">/* Initialize structure containing state of computation.</a>
<a name="ln74">   (RFC 1321, 3.3: Step 3)  */</a>
<a name="ln75">void</a>
<a name="ln76">md5_init_ctx (struct md5_ctx *ctx)</a>
<a name="ln77">{</a>
<a name="ln78">  ctx-&gt;A = 0x67452301;</a>
<a name="ln79">  ctx-&gt;B = 0xefcdab89;</a>
<a name="ln80">  ctx-&gt;C = 0x98badcfe;</a>
<a name="ln81">  ctx-&gt;D = 0x10325476;</a>
<a name="ln82"> </a>
<a name="ln83">  ctx-&gt;total[0] = ctx-&gt;total[1] = 0;</a>
<a name="ln84">  ctx-&gt;buflen = 0;</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87">/* Copy the 4 byte value from v into the memory location pointed to by *cp,</a>
<a name="ln88">   If your architecture allows unaligned access this is equivalent to</a>
<a name="ln89">   * (uint32_t *) cp = v  */</a>
<a name="ln90">static inline void</a>
<a name="ln91">set_uint32 (char *cp, uint32_t v)</a>
<a name="ln92">{</a>
<a name="ln93">  memcpy (cp, &amp;v, sizeof v);</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">/* Put result from CTX in first 16 bytes following RESBUF.  The result</a>
<a name="ln97">   must be in little endian byte order.  */</a>
<a name="ln98">void *</a>
<a name="ln99">md5_read_ctx (const struct md5_ctx *ctx, void *resbuf)</a>
<a name="ln100">{</a>
<a name="ln101">  char *r = resbuf;</a>
<a name="ln102">  set_uint32 (r + 0 * sizeof ctx-&gt;A, SWAP (ctx-&gt;A));</a>
<a name="ln103">  set_uint32 (r + 1 * sizeof ctx-&gt;B, SWAP (ctx-&gt;B));</a>
<a name="ln104">  set_uint32 (r + 2 * sizeof ctx-&gt;C, SWAP (ctx-&gt;C));</a>
<a name="ln105">  set_uint32 (r + 3 * sizeof ctx-&gt;D, SWAP (ctx-&gt;D));</a>
<a name="ln106"> </a>
<a name="ln107">  return resbuf;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">/* Process the remaining bytes in the internal buffer and the usual</a>
<a name="ln111">   prolog according to the standard and write the result to RESBUF.  */</a>
<a name="ln112">void *</a>
<a name="ln113">md5_finish_ctx (struct md5_ctx *ctx, void *resbuf)</a>
<a name="ln114">{</a>
<a name="ln115">  /* Take yet unprocessed bytes into account.  */</a>
<a name="ln116">  uint32_t bytes = ctx-&gt;buflen;</a>
<a name="ln117">  size_t size = (bytes &lt; 56) ? 64 / 4 : 64 * 2 / 4;</a>
<a name="ln118"> </a>
<a name="ln119">  /* Now count remaining bytes.  */</a>
<a name="ln120">  ctx-&gt;total[0] += bytes;</a>
<a name="ln121">  if (ctx-&gt;total[0] &lt; bytes)</a>
<a name="ln122">    ++ctx-&gt;total[1];</a>
<a name="ln123"> </a>
<a name="ln124">  /* Put the 64-bit file length in *bits* at the end of the buffer.  */</a>
<a name="ln125">  ctx-&gt;buffer[size - 2] = SWAP (ctx-&gt;total[0] &lt;&lt; 3);</a>
<a name="ln126">  ctx-&gt;buffer[size - 1] = SWAP ((ctx-&gt;total[1] &lt;&lt; 3) | (ctx-&gt;total[0] &gt;&gt; 29));</a>
<a name="ln127"> </a>
<a name="ln128">  memcpy (&amp;((char *) ctx-&gt;buffer)[bytes], fillbuf, (size - 2) * 4 - bytes);</a>
<a name="ln129"> </a>
<a name="ln130">  /* Process last bytes.  */</a>
<a name="ln131">  md5_process_block (ctx-&gt;buffer, size * 4, ctx);</a>
<a name="ln132"> </a>
<a name="ln133">  return md5_read_ctx (ctx, resbuf);</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">/* Compute MD5 message digest for bytes read from STREAM.  The</a>
<a name="ln137">   resulting message digest number will be written into the 16 bytes</a>
<a name="ln138">   beginning at RESBLOCK.  */</a>
<a name="ln139">int</a>
<a name="ln140">md5_stream (FILE *stream, void *resblock)</a>
<a name="ln141">{</a>
<a name="ln142">  struct md5_ctx ctx;</a>
<a name="ln143">  size_t sum;</a>
<a name="ln144"> </a>
<a name="ln145">  char *buffer = malloc (BLOCKSIZE + 72);</a>
<a name="ln146">  if (!buffer)</a>
<a name="ln147">    return 1;</a>
<a name="ln148"> </a>
<a name="ln149">  /* Initialize the computation context.  */</a>
<a name="ln150">  md5_init_ctx (&amp;ctx);</a>
<a name="ln151"> </a>
<a name="ln152">  /* Iterate over full file contents.  */</a>
<a name="ln153">  while (1)</a>
<a name="ln154">    {</a>
<a name="ln155">      /* We read the file in blocks of BLOCKSIZE bytes.  One call of the</a>
<a name="ln156">         computation function processes the whole buffer so that with the</a>
<a name="ln157">         next round of the loop another block can be read.  */</a>
<a name="ln158">      size_t n;</a>
<a name="ln159">      sum = 0;</a>
<a name="ln160"> </a>
<a name="ln161">      /* Read block.  Take care for partial reads.  */</a>
<a name="ln162">      while (1)</a>
<a name="ln163">        {</a>
<a name="ln164">          n = fread (buffer + sum, 1, BLOCKSIZE - sum, stream);</a>
<a name="ln165"> </a>
<a name="ln166">          sum += n;</a>
<a name="ln167"> </a>
<a name="ln168">          if (sum == BLOCKSIZE)</a>
<a name="ln169">            break;</a>
<a name="ln170"> </a>
<a name="ln171">          if (n == 0)</a>
<a name="ln172">            {</a>
<a name="ln173">              /* Check for the error flag IFF N == 0, so that we don't</a>
<a name="ln174">                 exit the loop after a partial read due to e.g., EAGAIN</a>
<a name="ln175">                 or EWOULDBLOCK.  */</a>
<a name="ln176">              if (ferror (stream))</a>
<a name="ln177">                {</a>
<a name="ln178">                  free (buffer);</a>
<a name="ln179">                  return 1;</a>
<a name="ln180">                }</a>
<a name="ln181">              goto process_partial_block;</a>
<a name="ln182">            }</a>
<a name="ln183"> </a>
<a name="ln184">          /* We've read at least one byte, so ignore errors.  But always</a>
<a name="ln185">             check for EOF, since feof may be true even though N &gt; 0.</a>
<a name="ln186">             Otherwise, we could end up calling fread after EOF.  */</a>
<a name="ln187">          if (feof (stream))</a>
<a name="ln188">            goto process_partial_block;</a>
<a name="ln189">        }</a>
<a name="ln190"> </a>
<a name="ln191">      /* Process buffer with BLOCKSIZE bytes.  Note that</a>
<a name="ln192">         BLOCKSIZE % 64 == 0</a>
<a name="ln193">       */</a>
<a name="ln194">      md5_process_block (buffer, BLOCKSIZE, &amp;ctx);</a>
<a name="ln195">    }</a>
<a name="ln196"> </a>
<a name="ln197">process_partial_block:</a>
<a name="ln198"> </a>
<a name="ln199">  /* Process any remaining bytes.  */</a>
<a name="ln200">  if (sum &gt; 0)</a>
<a name="ln201">    md5_process_bytes (buffer, sum, &amp;ctx);</a>
<a name="ln202"> </a>
<a name="ln203">  /* Construct result in desired memory.  */</a>
<a name="ln204">  md5_finish_ctx (&amp;ctx, resblock);</a>
<a name="ln205">  free (buffer);</a>
<a name="ln206">  return 0;</a>
<a name="ln207">}</a>
<a name="ln208"> </a>
<a name="ln209">/* Compute MD5 message digest for LEN bytes beginning at BUFFER.  The</a>
<a name="ln210">   result is always in little endian byte order, so that a byte-wise</a>
<a name="ln211">   output yields to the wanted ASCII representation of the message</a>
<a name="ln212">   digest.  */</a>
<a name="ln213">void *</a>
<a name="ln214">md5_buffer (const char *buffer, size_t len, void *resblock)</a>
<a name="ln215">{</a>
<a name="ln216">  struct md5_ctx ctx;</a>
<a name="ln217"> </a>
<a name="ln218">  /* Initialize the computation context.  */</a>
<a name="ln219">  md5_init_ctx (&amp;ctx);</a>
<a name="ln220"> </a>
<a name="ln221">  /* Process whole buffer but last len % 64 bytes.  */</a>
<a name="ln222">  md5_process_bytes (buffer, len, &amp;ctx);</a>
<a name="ln223"> </a>
<a name="ln224">  /* Put result in desired memory area.  */</a>
<a name="ln225">  return md5_finish_ctx (&amp;ctx, resblock);</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228"> </a>
<a name="ln229">void</a>
<a name="ln230">md5_process_bytes (const void *buffer, size_t len, struct md5_ctx *ctx)</a>
<a name="ln231">{</a>
<a name="ln232">  /* When we already have some bits in our internal buffer concatenate</a>
<a name="ln233">     both inputs first.  */</a>
<a name="ln234">  if (ctx-&gt;buflen != 0)</a>
<a name="ln235">    {</a>
<a name="ln236">      size_t left_over = ctx-&gt;buflen;</a>
<a name="ln237">      size_t add = 128 - left_over &gt; len ? len : 128 - left_over;</a>
<a name="ln238"> </a>
<a name="ln239">      memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, add);</a>
<a name="ln240">      ctx-&gt;buflen += add;</a>
<a name="ln241"> </a>
<a name="ln242">      if (ctx-&gt;buflen &gt; 64)</a>
<a name="ln243">        {</a>
<a name="ln244">          md5_process_block (ctx-&gt;buffer, ctx-&gt;buflen &amp; ~63, ctx);</a>
<a name="ln245"> </a>
<a name="ln246">          ctx-&gt;buflen &amp;= 63;</a>
<a name="ln247">          /* The regions in the following copy operation cannot overlap.  */</a>
<a name="ln248">          memcpy (ctx-&gt;buffer,</a>
<a name="ln249">                  &amp;((char *) ctx-&gt;buffer)[(left_over + add) &amp; ~63],</a>
<a name="ln250">                  ctx-&gt;buflen);</a>
<a name="ln251">        }</a>
<a name="ln252"> </a>
<a name="ln253">      buffer = (const char *) buffer + add;</a>
<a name="ln254">      len -= add;</a>
<a name="ln255">    }</a>
<a name="ln256"> </a>
<a name="ln257">  /* Process available complete blocks.  */</a>
<a name="ln258">  if (len &gt;= 64)</a>
<a name="ln259">    {</a>
<a name="ln260">#if !_STRING_ARCH_unaligned</a>
<a name="ln261"># define UNALIGNED_P(p) ((uintptr_t) (p) % alignof (uint32_t) != 0)</a>
<a name="ln262">      if (UNALIGNED_P (buffer))</a>
<a name="ln263">        while (len &gt; 64)</a>
<a name="ln264">          {</a>
<a name="ln265">            md5_process_block (memcpy (ctx-&gt;buffer, buffer, 64), 64, ctx);</a>
<a name="ln266">            buffer = (const char *) buffer + 64;</a>
<a name="ln267">            len -= 64;</a>
<a name="ln268">          }</a>
<a name="ln269">      else</a>
<a name="ln270">#endif</a>
<a name="ln271">        {</a>
<a name="ln272">          md5_process_block (buffer, len &amp; ~63, ctx);</a>
<a name="ln273">          buffer = (const char *) buffer + (len &amp; ~63);</a>
<a name="ln274">          len &amp;= 63;</a>
<a name="ln275">        }</a>
<a name="ln276">    }</a>
<a name="ln277"> </a>
<a name="ln278">  /* Move remaining bytes in internal buffer.  */</a>
<a name="ln279">  if (len &gt; 0)</a>
<a name="ln280">    {</a>
<a name="ln281">      size_t left_over = ctx-&gt;buflen;</a>
<a name="ln282"> </a>
<a name="ln283">      memcpy (&amp;((char *) ctx-&gt;buffer)[left_over], buffer, len);</a>
<a name="ln284">      left_over += len;</a>
<a name="ln285">      if (left_over &gt;= 64)</a>
<a name="ln286">        {</a>
<a name="ln287">          md5_process_block (ctx-&gt;buffer, 64, ctx);</a>
<a name="ln288">          left_over -= 64;</a>
<a name="ln289">          memcpy (ctx-&gt;buffer, &amp;ctx-&gt;buffer[16], left_over);</a>
<a name="ln290">        }</a>
<a name="ln291">      ctx-&gt;buflen = left_over;</a>
<a name="ln292">    }</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">/* These are the four functions used in the four steps of the MD5 algorithm</a>
<a name="ln297">   and defined in the RFC 1321.  The first function is a little bit optimized</a>
<a name="ln298">   (as found in Colin Plumbs public domain implementation).  */</a>
<a name="ln299">/* #define FF(b, c, d) ((b &amp; c) | (~b &amp; d)) */</a>
<a name="ln300">#define FF(b, c, d) (d ^ (b &amp; (c ^ d)))</a>
<a name="ln301">#define FG(b, c, d) FF (d, b, c)</a>
<a name="ln302">#define FH(b, c, d) (b ^ c ^ d)</a>
<a name="ln303">#define FI(b, c, d) (c ^ (b | ~d))</a>
<a name="ln304"> </a>
<a name="ln305">/* Process LEN bytes of BUFFER, accumulating context into CTX.</a>
<a name="ln306">   It is assumed that LEN % 64 == 0.  */</a>
<a name="ln307"> </a>
<a name="ln308">void</a>
<a name="ln309">md5_process_block (const void *buffer, size_t len, struct md5_ctx *ctx)</a>
<a name="ln310">{</a>
<a name="ln311">  uint32_t correct_words[16];</a>
<a name="ln312">  const uint32_t *words = buffer;</a>
<a name="ln313">  size_t nwords = len / sizeof (uint32_t);</a>
<a name="ln314">  const uint32_t *endp = words + nwords;</a>
<a name="ln315">  uint32_t A = ctx-&gt;A;</a>
<a name="ln316">  uint32_t B = ctx-&gt;B;</a>
<a name="ln317">  uint32_t C = ctx-&gt;C;</a>
<a name="ln318">  uint32_t D = ctx-&gt;D;</a>
<a name="ln319"> </a>
<a name="ln320">  /* First increment the byte count.  RFC 1321 specifies the possible</a>
<a name="ln321">     length of the file up to 2^64 bits.  Here we only compute the</a>
<a name="ln322">     number of bytes.  Do a double word increment.  */</a>
<a name="ln323">  ctx-&gt;total[0] += len;</a>
<a name="ln324">  if (ctx-&gt;total[0] &lt; len)</a>
<a name="ln325">    ++ctx-&gt;total[1];</a>
<a name="ln326"> </a>
<a name="ln327">  /* Process all bytes in the buffer with 64 bytes in each round of</a>
<a name="ln328">     the loop.  */</a>
<a name="ln329">  while (words &lt; endp)</a>
<a name="ln330">    {</a>
<a name="ln331">      uint32_t *cwp = correct_words;</a>
<a name="ln332">      uint32_t A_save = A;</a>
<a name="ln333">      uint32_t B_save = B;</a>
<a name="ln334">      uint32_t C_save = C;</a>
<a name="ln335">      uint32_t D_save = D;</a>
<a name="ln336"> </a>
<a name="ln337">      /* First round: using the given function, the context and a constant</a>
<a name="ln338">         the next context is computed.  Because the algorithms processing</a>
<a name="ln339">         unit is a 32-bit word and it is determined to work on words in</a>
<a name="ln340">         little endian byte order we perhaps have to change the byte order</a>
<a name="ln341">         before the computation.  To reduce the work for the next steps</a>
<a name="ln342">         we store the swapped words in the array CORRECT_WORDS.  */</a>
<a name="ln343"> </a>
<a name="ln344">#define OP(a, b, c, d, s, T)                                            \</a>
<a name="ln345">      do                                                                \</a>
<a name="ln346">        {                                                               \</a>
<a name="ln347">          a += FF (b, c, d) + (*cwp++ = SWAP (*words)) + T;             \</a>
<a name="ln348">          ++words;                                                      \</a>
<a name="ln349">          CYCLIC (a, s);                                                \</a>
<a name="ln350">          a += b;                                                       \</a>
<a name="ln351">        }                                                               \</a>
<a name="ln352">      while (0)</a>
<a name="ln353"> </a>
<a name="ln354">      /* It is unfortunate that C does not provide an operator for</a>
<a name="ln355">         cyclic rotation.  Hope the C compiler is smart enough.  */</a>
<a name="ln356">#define CYCLIC(w, s) (w = (w &lt;&lt; s) | (w &gt;&gt; (32 - s)))</a>
<a name="ln357"> </a>
<a name="ln358">      /* Before we start, one word to the strange constants.</a>
<a name="ln359">         They are defined in RFC 1321 as</a>
<a name="ln360"> </a>
<a name="ln361">         T[i] = (int) (4294967296.0 * fabs (sin (i))), i=1..64</a>
<a name="ln362"> </a>
<a name="ln363">         Here is an equivalent invocation using Perl:</a>
<a name="ln364"> </a>
<a name="ln365">         perl -e 'foreach(1..64){printf &quot;0x%08x\n&quot;, int (4294967296 * abs (sin $_))}'</a>
<a name="ln366">       */</a>
<a name="ln367"> </a>
<a name="ln368">      /* Round 1.  */</a>
<a name="ln369">      OP (A, B, C, D, 7, 0xd76aa478);</a>
<a name="ln370">      OP (D, A, B, C, 12, 0xe8c7b756);</a>
<a name="ln371">      OP (C, D, A, B, 17, 0x242070db);</a>
<a name="ln372">      OP (B, C, D, A, 22, 0xc1bdceee);</a>
<a name="ln373">      OP (A, B, C, D, 7, 0xf57c0faf);</a>
<a name="ln374">      OP (D, A, B, C, 12, 0x4787c62a);</a>
<a name="ln375">      OP (C, D, A, B, 17, 0xa8304613);</a>
<a name="ln376">      OP (B, C, D, A, 22, 0xfd469501);</a>
<a name="ln377">      OP (A, B, C, D, 7, 0x698098d8);</a>
<a name="ln378">      OP (D, A, B, C, 12, 0x8b44f7af);</a>
<a name="ln379">      OP (C, D, A, B, 17, 0xffff5bb1);</a>
<a name="ln380">      OP (B, C, D, A, 22, 0x895cd7be);</a>
<a name="ln381">      OP (A, B, C, D, 7, 0x6b901122);</a>
<a name="ln382">      OP (D, A, B, C, 12, 0xfd987193);</a>
<a name="ln383">      OP (C, D, A, B, 17, 0xa679438e);</a>
<a name="ln384">      OP (B, C, D, A, 22, 0x49b40821);</a>
<a name="ln385"> </a>
<a name="ln386">      /* For the second to fourth round we have the possibly swapped words</a>
<a name="ln387">         in CORRECT_WORDS.  Redefine the macro to take an additional first</a>
<a name="ln388">         argument specifying the function to use.  */</a>
<a name="ln389">#undef OP</a>
<a name="ln390">#define OP(f, a, b, c, d, k, s, T)                                      \</a>
<a name="ln391">      do                                                                \</a>
<a name="ln392">        {                                                               \</a>
<a name="ln393">          a += f (b, c, d) + correct_words[k] + T;                      \</a>
<a name="ln394">          CYCLIC (a, s);                                                \</a>
<a name="ln395">          a += b;                                                       \</a>
<a name="ln396">        }                                                               \</a>
<a name="ln397">      while (0)</a>
<a name="ln398"> </a>
<a name="ln399">      /* Round 2.  */</a>
<a name="ln400">      OP (FG, A, B, C, D, 1, 5, 0xf61e2562);</a>
<a name="ln401">      OP (FG, D, A, B, C, 6, 9, 0xc040b340);</a>
<a name="ln402">      OP (FG, C, D, A, B, 11, 14, 0x265e5a51);</a>
<a name="ln403">      OP (FG, B, C, D, A, 0, 20, 0xe9b6c7aa);</a>
<a name="ln404">      OP (FG, A, B, C, D, 5, 5, 0xd62f105d);</a>
<a name="ln405">      OP (FG, D, A, B, C, 10, 9, 0x02441453);</a>
<a name="ln406">      OP (FG, C, D, A, B, 15, 14, 0xd8a1e681);</a>
<a name="ln407">      OP (FG, B, C, D, A, 4, 20, 0xe7d3fbc8);</a>
<a name="ln408">      OP (FG, A, B, C, D, 9, 5, 0x21e1cde6);</a>
<a name="ln409">      OP (FG, D, A, B, C, 14, 9, 0xc33707d6);</a>
<a name="ln410">      OP (FG, C, D, A, B, 3, 14, 0xf4d50d87);</a>
<a name="ln411">      OP (FG, B, C, D, A, 8, 20, 0x455a14ed);</a>
<a name="ln412">      OP (FG, A, B, C, D, 13, 5, 0xa9e3e905);</a>
<a name="ln413">      OP (FG, D, A, B, C, 2, 9, 0xfcefa3f8);</a>
<a name="ln414">      OP (FG, C, D, A, B, 7, 14, 0x676f02d9);</a>
<a name="ln415">      OP (FG, B, C, D, A, 12, 20, 0x8d2a4c8a);</a>
<a name="ln416"> </a>
<a name="ln417">      /* Round 3.  */</a>
<a name="ln418">      OP (FH, A, B, C, D, 5, 4, 0xfffa3942);</a>
<a name="ln419">      OP (FH, D, A, B, C, 8, 11, 0x8771f681);</a>
<a name="ln420">      OP (FH, C, D, A, B, 11, 16, 0x6d9d6122);</a>
<a name="ln421">      OP (FH, B, C, D, A, 14, 23, 0xfde5380c);</a>
<a name="ln422">      OP (FH, A, B, C, D, 1, 4, 0xa4beea44);</a>
<a name="ln423">      OP (FH, D, A, B, C, 4, 11, 0x4bdecfa9);</a>
<a name="ln424">      OP (FH, C, D, A, B, 7, 16, 0xf6bb4b60);</a>
<a name="ln425">      OP (FH, B, C, D, A, 10, 23, 0xbebfbc70);</a>
<a name="ln426">      OP (FH, A, B, C, D, 13, 4, 0x289b7ec6);</a>
<a name="ln427">      OP (FH, D, A, B, C, 0, 11, 0xeaa127fa);</a>
<a name="ln428">      OP (FH, C, D, A, B, 3, 16, 0xd4ef3085);</a>
<a name="ln429">      OP (FH, B, C, D, A, 6, 23, 0x04881d05);</a>
<a name="ln430">      OP (FH, A, B, C, D, 9, 4, 0xd9d4d039);</a>
<a name="ln431">      OP (FH, D, A, B, C, 12, 11, 0xe6db99e5);</a>
<a name="ln432">      OP (FH, C, D, A, B, 15, 16, 0x1fa27cf8);</a>
<a name="ln433">      OP (FH, B, C, D, A, 2, 23, 0xc4ac5665);</a>
<a name="ln434"> </a>
<a name="ln435">      /* Round 4.  */</a>
<a name="ln436">      OP (FI, A, B, C, D, 0, 6, 0xf4292244);</a>
<a name="ln437">      OP (FI, D, A, B, C, 7, 10, 0x432aff97);</a>
<a name="ln438">      OP (FI, C, D, A, B, 14, 15, 0xab9423a7);</a>
<a name="ln439">      OP (FI, B, C, D, A, 5, 21, 0xfc93a039);</a>
<a name="ln440">      OP (FI, A, B, C, D, 12, 6, 0x655b59c3);</a>
<a name="ln441">      OP (FI, D, A, B, C, 3, 10, 0x8f0ccc92);</a>
<a name="ln442">      OP (FI, C, D, A, B, 10, 15, 0xffeff47d);</a>
<a name="ln443">      OP (FI, B, C, D, A, 1, 21, 0x85845dd1);</a>
<a name="ln444">      OP (FI, A, B, C, D, 8, 6, 0x6fa87e4f);</a>
<a name="ln445">      OP (FI, D, A, B, C, 15, 10, 0xfe2ce6e0);</a>
<a name="ln446">      OP (FI, C, D, A, B, 6, 15, 0xa3014314);</a>
<a name="ln447">      OP (FI, B, C, D, A, 13, 21, 0x4e0811a1);</a>
<a name="ln448">      OP (FI, A, B, C, D, 4, 6, 0xf7537e82);</a>
<a name="ln449">      OP (FI, D, A, B, C, 11, 10, 0xbd3af235);</a>
<a name="ln450">      OP (FI, C, D, A, B, 2, 15, 0x2ad7d2bb);</a>
<a name="ln451">      OP (FI, B, C, D, A, 9, 21, 0xeb86d391);</a>
<a name="ln452"> </a>
<a name="ln453">      /* Add the starting values of the context.  */</a>
<a name="ln454">      A += A_save;</a>
<a name="ln455">      B += B_save;</a>
<a name="ln456">      C += C_save;</a>
<a name="ln457">      D += D_save;</a>
<a name="ln458">    }</a>
<a name="ln459"> </a>
<a name="ln460">  /* Put checksum in context given as argument.  */</a>
<a name="ln461">  ctx-&gt;A = A;</a>
<a name="ln462">  ctx-&gt;B = B;</a>
<a name="ln463">  ctx-&gt;C = C;</a>
<a name="ln464">  ctx-&gt;D = D;</a>
<a name="ln465">}</a>

</code></pre>
<div class="balloon" rel="265"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer 'ctx->buffer'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
