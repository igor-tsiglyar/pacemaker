
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (C) 2004 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * This program is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2 of the License, or (at your option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This software is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;crm_internal.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;pengine.h&gt;</a>
<a name="ln26">#include &lt;crm/pengine/rules.h&gt;</a>
<a name="ln27">#include &lt;crm/msg_xml.h&gt;</a>
<a name="ln28">#include &lt;allocate.h&gt;</a>
<a name="ln29">#include &lt;notif.h&gt;</a>
<a name="ln30">#include &lt;utils.h&gt;</a>
<a name="ln31">#include &lt;crm/services.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">/* #define DELETE_THEN_REFRESH 1  // The crmd will remove the resource from the CIB itself, making this redundant */</a>
<a name="ln34">#define INFINITY_HACK   (INFINITY * -100)</a>
<a name="ln35"> </a>
<a name="ln36">#define VARIANT_NATIVE 1</a>
<a name="ln37">#include &lt;lib/pengine/variant.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">gboolean update_action(action_t * then);</a>
<a name="ln40">void native_rsc_colocation_rh_must(resource_t * rsc_lh, gboolean update_lh,</a>
<a name="ln41">                                   resource_t * rsc_rh, gboolean update_rh);</a>
<a name="ln42"> </a>
<a name="ln43">void native_rsc_colocation_rh_mustnot(resource_t * rsc_lh, gboolean update_lh,</a>
<a name="ln44">                                      resource_t * rsc_rh, gboolean update_rh);</a>
<a name="ln45"> </a>
<a name="ln46">void Recurring(resource_t * rsc, action_t * start, node_t * node, pe_working_set_t * data_set);</a>
<a name="ln47">void RecurringOp(resource_t * rsc, action_t * start, node_t * node,</a>
<a name="ln48">                 xmlNode * operation, pe_working_set_t * data_set);</a>
<a name="ln49">void Recurring_Stopped(resource_t * rsc, action_t * start, node_t * node,</a>
<a name="ln50">                       pe_working_set_t * data_set);</a>
<a name="ln51">void RecurringOp_Stopped(resource_t * rsc, action_t * start, node_t * node,</a>
<a name="ln52">                         xmlNode * operation, pe_working_set_t * data_set);</a>
<a name="ln53"> </a>
<a name="ln54">void ReloadRsc(resource_t * rsc, node_t *node, pe_working_set_t * data_set);</a>
<a name="ln55">gboolean DeleteRsc(resource_t * rsc, node_t * node, gboolean optional, pe_working_set_t * data_set);</a>
<a name="ln56">gboolean StopRsc(resource_t * rsc, node_t * next, gboolean optional, pe_working_set_t * data_set);</a>
<a name="ln57">gboolean StartRsc(resource_t * rsc, node_t * next, gboolean optional, pe_working_set_t * data_set);</a>
<a name="ln58">gboolean DemoteRsc(resource_t * rsc, node_t * next, gboolean optional, pe_working_set_t * data_set);</a>
<a name="ln59">gboolean PromoteRsc(resource_t * rsc, node_t * next, gboolean optional,</a>
<a name="ln60">                    pe_working_set_t * data_set);</a>
<a name="ln61">gboolean RoleError(resource_t * rsc, node_t * next, gboolean optional, pe_working_set_t * data_set);</a>
<a name="ln62">gboolean NullOp(resource_t * rsc, node_t * next, gboolean optional, pe_working_set_t * data_set);</a>
<a name="ln63"> </a>
<a name="ln64">/* *INDENT-OFF* */</a>
<a name="ln65">enum rsc_role_e rsc_state_matrix[RSC_ROLE_MAX][RSC_ROLE_MAX] = {</a>
<a name="ln66">/* Current State */</a>
<a name="ln67">/*       Next State:    Unknown 	  Stopped	     Started	        Slave	          Master */</a>
<a name="ln68">    /* Unknown */ { RSC_ROLE_UNKNOWN, RSC_ROLE_STOPPED, RSC_ROLE_STOPPED, RSC_ROLE_STOPPED, RSC_ROLE_STOPPED, },</a>
<a name="ln69">    /* Stopped */ { RSC_ROLE_STOPPED, RSC_ROLE_STOPPED, RSC_ROLE_STARTED, RSC_ROLE_SLAVE,   RSC_ROLE_SLAVE, },</a>
<a name="ln70">    /* Started */ { RSC_ROLE_STOPPED, RSC_ROLE_STOPPED, RSC_ROLE_STARTED, RSC_ROLE_SLAVE,   RSC_ROLE_MASTER, },</a>
<a name="ln71">    /* Slave */	  { RSC_ROLE_STOPPED, RSC_ROLE_STOPPED, RSC_ROLE_STOPPED, RSC_ROLE_SLAVE,   RSC_ROLE_MASTER, },</a>
<a name="ln72">    /* Master */  { RSC_ROLE_STOPPED, RSC_ROLE_SLAVE,   RSC_ROLE_SLAVE,   RSC_ROLE_SLAVE,   RSC_ROLE_MASTER, },</a>
<a name="ln73">};</a>
<a name="ln74"> </a>
<a name="ln75">gboolean (*rsc_action_matrix[RSC_ROLE_MAX][RSC_ROLE_MAX])(resource_t*,node_t*,gboolean,pe_working_set_t*) = {</a>
<a name="ln76">/* Current State */</a>
<a name="ln77">/*       Next State:       Unknown	Stopped		Started		Slave		Master */</a>
<a name="ln78">    /* Unknown */	{ RoleError,	StopRsc,	RoleError,	RoleError,	RoleError,  },</a>
<a name="ln79">    /* Stopped */	{ RoleError,	NullOp,		StartRsc,	StartRsc,	RoleError,  },</a>
<a name="ln80">    /* Started */	{ RoleError,	StopRsc,	NullOp,		NullOp,		PromoteRsc, },</a>
<a name="ln81">    /* Slave */	        { RoleError,	StopRsc,	StopRsc, 	NullOp,		PromoteRsc, },</a>
<a name="ln82">    /* Master */	{ RoleError,	DemoteRsc,	DemoteRsc,	DemoteRsc,	NullOp,     },</a>
<a name="ln83">};</a>
<a name="ln84">/* *INDENT-ON* */</a>
<a name="ln85"> </a>
<a name="ln86">static action_t * get_first_named_action(resource_t * rsc, const char *action, gboolean only_valid, node_t * current);</a>
<a name="ln87"> </a>
<a name="ln88">static gboolean</a>
<a name="ln89">native_choose_node(resource_t * rsc, node_t * prefer, pe_working_set_t * data_set)</a>
<a name="ln90">{</a>
<a name="ln91">    /*</a>
<a name="ln92">       1. Sort by weight</a>
<a name="ln93">       2. color.chosen_node = the node (of those with the highest wieght)</a>
<a name="ln94">       with the fewest resources</a>
<a name="ln95">       3. remove color.chosen_node from all other colors</a>
<a name="ln96">     */</a>
<a name="ln97">    GListPtr nodes = NULL;</a>
<a name="ln98">    node_t *chosen = NULL;</a>
<a name="ln99"> </a>
<a name="ln100">    int lpc = 0;</a>
<a name="ln101">    int multiple = 0;</a>
<a name="ln102">    int length = 0;</a>
<a name="ln103">    gboolean result = FALSE;</a>
<a name="ln104"> </a>
<a name="ln105">    process_utilization(rsc, &amp;prefer, data_set);</a>
<a name="ln106"> </a>
<a name="ln107">    length = g_hash_table_size(rsc-&gt;allowed_nodes);</a>
<a name="ln108"> </a>
<a name="ln109">    if (is_not_set(rsc-&gt;flags, pe_rsc_provisional)) {</a>
<a name="ln110">        return rsc-&gt;allocated_to ? TRUE : FALSE;</a>
<a name="ln111">    }</a>
<a name="ln112"> </a>
<a name="ln113">    if(rsc-&gt;allowed_nodes) {</a>
<a name="ln114">        nodes = g_hash_table_get_values(rsc-&gt;allowed_nodes);</a>
<a name="ln115">        nodes = g_list_sort_with_data(nodes, sort_node_weight, g_list_nth_data(rsc-&gt;running_on, 0));</a>
<a name="ln116">    }</a>
<a name="ln117">    if (prefer) {</a>
<a name="ln118">        node_t *best = g_list_nth_data(nodes, 0);</a>
<a name="ln119"> </a>
<a name="ln120">        chosen = g_hash_table_lookup(rsc-&gt;allowed_nodes, prefer-&gt;details-&gt;id);</a>
<a name="ln121">        if (chosen &amp;&amp; chosen-&gt;weight &gt;= 0</a>
<a name="ln122">            &amp;&amp; chosen-&gt;weight &gt;= best-&gt;weight /* Possible alternative: (chosen-&gt;weight &gt;= INFINITY || best-&gt;weight &lt; INFINITY) */</a>
<a name="ln123">            &amp;&amp; can_run_resources(chosen)) {</a>
<a name="ln124">            pe_rsc_trace(rsc,</a>
<a name="ln125">                         &quot;Using preferred node %s for %s instead of choosing from %d candidates&quot;,</a>
<a name="ln126">                         chosen-&gt;details-&gt;uname, rsc-&gt;id, length);</a>
<a name="ln127">        } else if (chosen &amp;&amp; chosen-&gt;weight &lt; 0) {</a>
<a name="ln128">            pe_rsc_trace(rsc, &quot;Preferred node %s for %s was unavailable&quot;, chosen-&gt;details-&gt;uname,</a>
<a name="ln129">                         rsc-&gt;id);</a>
<a name="ln130">            chosen = NULL;</a>
<a name="ln131">        } else if (chosen &amp;&amp; can_run_resources(chosen)) {</a>
<a name="ln132">            pe_rsc_trace(rsc, &quot;Preferred node %s for %s was unsuitable&quot;, chosen-&gt;details-&gt;uname,</a>
<a name="ln133">                         rsc-&gt;id);</a>
<a name="ln134">            chosen = NULL;</a>
<a name="ln135">        } else {</a>
<a name="ln136">            pe_rsc_trace(rsc, &quot;Preferred node %s for %s was unknown&quot;, prefer-&gt;details-&gt;uname,</a>
<a name="ln137">                         rsc-&gt;id);</a>
<a name="ln138">        }</a>
<a name="ln139">    }</a>
<a name="ln140"> </a>
<a name="ln141">    if (chosen == NULL &amp;&amp; rsc-&gt;allowed_nodes) {</a>
<a name="ln142"> </a>
<a name="ln143">        chosen = g_list_nth_data(nodes, 0);</a>
<a name="ln144">        pe_rsc_trace(rsc, &quot;Chose node %s for %s from %d candidates&quot;,</a>
<a name="ln145">                     chosen ? chosen-&gt;details-&gt;uname : &quot;&lt;none&gt;&quot;, rsc-&gt;id, length);</a>
<a name="ln146"> </a>
<a name="ln147">        if (chosen &amp;&amp; chosen-&gt;weight &gt; 0 &amp;&amp; can_run_resources(chosen)) {</a>
<a name="ln148">            node_t *running = g_list_nth_data(rsc-&gt;running_on, 0);</a>
<a name="ln149"> </a>
<a name="ln150">            if (running &amp;&amp; can_run_resources(running) == FALSE) {</a>
<a name="ln151">                pe_rsc_trace(rsc, &quot;Current node for %s (%s) can't run resources&quot;,</a>
<a name="ln152">                             rsc-&gt;id, running-&gt;details-&gt;uname);</a>
<a name="ln153">                running = NULL;</a>
<a name="ln154">            }</a>
<a name="ln155"> </a>
<a name="ln156">            for (lpc = 1; lpc &lt; length &amp;&amp; running; lpc++) {</a>
<a name="ln157">                node_t *tmp = g_list_nth_data(nodes, lpc);</a>
<a name="ln158"> </a>
<a name="ln159">                if (tmp-&gt;weight == chosen-&gt;weight) {</a>
<a name="ln160">                    multiple++;</a>
<a name="ln161">                    if (tmp-&gt;details == running-&gt;details) {</a>
<a name="ln162">                        /* prefer the existing node if scores are equal */</a>
<a name="ln163">                        chosen = tmp;</a>
<a name="ln164">                    }</a>
<a name="ln165">                }</a>
<a name="ln166">            }</a>
<a name="ln167">        }</a>
<a name="ln168">    }</a>
<a name="ln169"> </a>
<a name="ln170">    if (multiple &gt; 1) {</a>
<a name="ln171">        int log_level = LOG_INFO;</a>
<a name="ln172">        static char score[33];</a>
<a name="ln173"> </a>
<a name="ln174">        score2char_stack(chosen-&gt;weight, score, sizeof(score));</a>
<a name="ln175"> </a>
<a name="ln176">        if (chosen-&gt;weight &gt;= INFINITY) {</a>
<a name="ln177">            log_level = LOG_WARNING;</a>
<a name="ln178">        }</a>
<a name="ln179"> </a>
<a name="ln180">        do_crm_log(log_level, &quot;%d nodes with equal score (%s) for&quot;</a>
<a name="ln181">                   &quot; running %s resources.  Chose %s.&quot;,</a>
<a name="ln182">                   multiple, score, rsc-&gt;id, chosen-&gt;details-&gt;uname);</a>
<a name="ln183">    }</a>
<a name="ln184"> </a>
<a name="ln185">    result = native_assign_node(rsc, nodes, chosen, FALSE);</a>
<a name="ln186">    g_list_free(nodes);</a>
<a name="ln187">    return result;</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">static int</a>
<a name="ln191">node_list_attr_score(GHashTable * list, const char *attr, const char *value)</a>
<a name="ln192">{</a>
<a name="ln193">    GHashTableIter iter;</a>
<a name="ln194">    node_t *node = NULL;</a>
<a name="ln195">    int best_score = -INFINITY;</a>
<a name="ln196">    const char *best_node = NULL;</a>
<a name="ln197"> </a>
<a name="ln198">    if (attr == NULL) {</a>
<a name="ln199">        attr = &quot;#&quot; XML_ATTR_UNAME;</a>
<a name="ln200">    }</a>
<a name="ln201"> </a>
<a name="ln202">    g_hash_table_iter_init(&amp;iter, list);</a>
<a name="ln203">    while (g_hash_table_iter_next(&amp;iter, NULL, (void **)&amp;node)) {</a>
<a name="ln204">        int weight = node-&gt;weight;</a>
<a name="ln205"> </a>
<a name="ln206">        if (can_run_resources(node) == FALSE) {</a>
<a name="ln207">            weight = -INFINITY;</a>
<a name="ln208">        }</a>
<a name="ln209">        if (weight &gt; best_score || best_node == NULL) {</a>
<a name="ln210">            const char *tmp = g_hash_table_lookup(node-&gt;details-&gt;attrs, attr);</a>
<a name="ln211"> </a>
<a name="ln212">            if (safe_str_eq(value, tmp)) {</a>
<a name="ln213">                best_score = weight;</a>
<a name="ln214">                best_node = node-&gt;details-&gt;uname;</a>
<a name="ln215">            }</a>
<a name="ln216">        }</a>
<a name="ln217">    }</a>
<a name="ln218"> </a>
<a name="ln219">    if (safe_str_neq(attr, &quot;#&quot; XML_ATTR_UNAME)) {</a>
<a name="ln220">        crm_info(&quot;Best score for %s=%s was %s with %d&quot;,</a>
<a name="ln221">                 attr, value, best_node ? best_node : &quot;&lt;none&gt;&quot;, best_score);</a>
<a name="ln222">    }</a>
<a name="ln223"> </a>
<a name="ln224">    return best_score;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">static void</a>
<a name="ln228">node_hash_update(GHashTable * list1, GHashTable * list2, const char *attr, float factor,</a>
<a name="ln229">                 gboolean only_positive)</a>
<a name="ln230">{</a>
<a name="ln231">    int score = 0;</a>
<a name="ln232">    int new_score = 0;</a>
<a name="ln233">    GHashTableIter iter;</a>
<a name="ln234">    node_t *node = NULL;</a>
<a name="ln235"> </a>
<a name="ln236">    if (attr == NULL) {</a>
<a name="ln237">        attr = &quot;#&quot; XML_ATTR_UNAME;</a>
<a name="ln238">    }</a>
<a name="ln239"> </a>
<a name="ln240">    g_hash_table_iter_init(&amp;iter, list1);</a>
<a name="ln241">    while (g_hash_table_iter_next(&amp;iter, NULL, (void **)&amp;node)) {</a>
<a name="ln242">        CRM_LOG_ASSERT(node != NULL);</a>
<a name="ln243">        if(node == NULL) { continue; };</a>
<a name="ln244"> </a>
<a name="ln245">        score = node_list_attr_score(list2, attr, g_hash_table_lookup(node-&gt;details-&gt;attrs, attr));</a>
<a name="ln246">        new_score = merge_weights(factor * score, node-&gt;weight);</a>
<a name="ln247"> </a>
<a name="ln248">        if (factor &lt; 0 &amp;&amp; score &lt; 0) {</a>
<a name="ln249">            /* Negative preference for a node with a negative score</a>
<a name="ln250">             * should not become a positive preference</a>
<a name="ln251">             *</a>
<a name="ln252">             * TODO - Decide if we want to filter only if weight == -INFINITY</a>
<a name="ln253">             *</a>
<a name="ln254">             */</a>
<a name="ln255">            crm_trace(&quot;%s: Filtering %d + %f*%d (factor * score)&quot;,</a>
<a name="ln256">                      node-&gt;details-&gt;uname, node-&gt;weight, factor, score);</a>
<a name="ln257"> </a>
<a name="ln258">        } else if (node-&gt;weight == INFINITY_HACK) {</a>
<a name="ln259">            crm_trace(&quot;%s: Filtering %d + %f*%d (node &lt; 0)&quot;,</a>
<a name="ln260">                      node-&gt;details-&gt;uname, node-&gt;weight, factor, score);</a>
<a name="ln261"> </a>
<a name="ln262">        } else if (only_positive &amp;&amp; new_score &lt; 0 &amp;&amp; node-&gt;weight &gt; 0) {</a>
<a name="ln263">            node-&gt;weight = INFINITY_HACK;</a>
<a name="ln264">            crm_trace(&quot;%s: Filtering %d + %f*%d (score &gt; 0)&quot;,</a>
<a name="ln265">                      node-&gt;details-&gt;uname, node-&gt;weight, factor, score);</a>
<a name="ln266"> </a>
<a name="ln267">        } else if (only_positive &amp;&amp; new_score &lt; 0 &amp;&amp; node-&gt;weight == 0) {</a>
<a name="ln268">            crm_trace(&quot;%s: Filtering %d + %f*%d (score == 0)&quot;,</a>
<a name="ln269">                      node-&gt;details-&gt;uname, node-&gt;weight, factor, score);</a>
<a name="ln270"> </a>
<a name="ln271">        } else {</a>
<a name="ln272">            crm_trace(&quot;%s: %d + %f*%d&quot;, node-&gt;details-&gt;uname, node-&gt;weight, factor, score);</a>
<a name="ln273">            node-&gt;weight = new_score;</a>
<a name="ln274">        }</a>
<a name="ln275">    }</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">GHashTable *</a>
<a name="ln279">node_hash_dup(GHashTable * hash)</a>
<a name="ln280">{</a>
<a name="ln281">    /* Hack! */</a>
<a name="ln282">    GListPtr list = g_hash_table_get_values(hash);</a>
<a name="ln283">    GHashTable *result = node_hash_from_list(list);</a>
<a name="ln284"> </a>
<a name="ln285">    g_list_free(list);</a>
<a name="ln286">    return result;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">GHashTable *</a>
<a name="ln290">native_merge_weights(resource_t * rsc, const char *rhs, GHashTable * nodes, const char *attr,</a>
<a name="ln291">                     float factor, enum pe_weights flags)</a>
<a name="ln292">{</a>
<a name="ln293">    return rsc_merge_weights(rsc, rhs, nodes, attr, factor, flags);</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">GHashTable *</a>
<a name="ln297">rsc_merge_weights(resource_t * rsc, const char *rhs, GHashTable * nodes, const char *attr,</a>
<a name="ln298">                  float factor, enum pe_weights flags)</a>
<a name="ln299">{</a>
<a name="ln300">    GHashTable *work = NULL;</a>
<a name="ln301">    int multiplier = 1;</a>
<a name="ln302"> </a>
<a name="ln303">    if (factor &lt; 0) {</a>
<a name="ln304">        multiplier = -1;</a>
<a name="ln305">    }</a>
<a name="ln306"> </a>
<a name="ln307">    if (is_set(rsc-&gt;flags, pe_rsc_merging)) {</a>
<a name="ln308">        pe_rsc_info(rsc, &quot;%s: Breaking dependency loop at %s&quot;, rhs, rsc-&gt;id);</a>
<a name="ln309">        return nodes;</a>
<a name="ln310">    }</a>
<a name="ln311"> </a>
<a name="ln312">    set_bit(rsc-&gt;flags, pe_rsc_merging);</a>
<a name="ln313"> </a>
<a name="ln314">    if (is_set(flags, pe_weights_init)) {</a>
<a name="ln315">        if (rsc-&gt;variant == pe_group &amp;&amp; rsc-&gt;children) {</a>
<a name="ln316">            GListPtr last = rsc-&gt;children;</a>
<a name="ln317"> </a>
<a name="ln318">            while (last-&gt;next != NULL) {</a>
<a name="ln319">                last = last-&gt;next;</a>
<a name="ln320">            }</a>
<a name="ln321"> </a>
<a name="ln322">            pe_rsc_trace(rsc, &quot;Merging %s as a group %p %p&quot;, rsc-&gt;id, rsc-&gt;children, last);</a>
<a name="ln323">            work = rsc_merge_weights(last-&gt;data, rhs, NULL, attr, factor, flags);</a>
<a name="ln324"> </a>
<a name="ln325">        } else {</a>
<a name="ln326">            work = node_hash_dup(rsc-&gt;allowed_nodes);</a>
<a name="ln327">        }</a>
<a name="ln328">        clear_bit(flags, pe_weights_init);</a>
<a name="ln329"> </a>
<a name="ln330">    } else if (rsc-&gt;variant == pe_group &amp;&amp; rsc-&gt;children) {</a>
<a name="ln331">        GListPtr iter = rsc-&gt;children;</a>
<a name="ln332"> </a>
<a name="ln333">        pe_rsc_trace(rsc, &quot;%s: Combining scores from %d children of %s&quot;, rhs, g_list_length(iter), rsc-&gt;id);</a>
<a name="ln334">        work = node_hash_dup(nodes);</a>
<a name="ln335">        for(iter = rsc-&gt;children; iter-&gt;next != NULL; iter = iter-&gt;next) {</a>
<a name="ln336">            work = rsc_merge_weights(iter-&gt;data, rhs, work, attr, factor, flags);</a>
<a name="ln337">        }</a>
<a name="ln338"> </a>
<a name="ln339">    } else {</a>
<a name="ln340">        pe_rsc_trace(rsc, &quot;%s: Combining scores from %s&quot;, rhs, rsc-&gt;id);</a>
<a name="ln341">        work = node_hash_dup(nodes);</a>
<a name="ln342">        node_hash_update(work, rsc-&gt;allowed_nodes, attr, factor,</a>
<a name="ln343">                         is_set(flags, pe_weights_positive));</a>
<a name="ln344">    }</a>
<a name="ln345"> </a>
<a name="ln346">    if (is_set(flags, pe_weights_rollback) &amp;&amp; can_run_any(work) == FALSE) {</a>
<a name="ln347">        pe_rsc_info(rsc, &quot;%s: Rolling back scores from %s&quot;, rhs, rsc-&gt;id);</a>
<a name="ln348">        g_hash_table_destroy(work);</a>
<a name="ln349">        clear_bit(rsc-&gt;flags, pe_rsc_merging);</a>
<a name="ln350">        return nodes;</a>
<a name="ln351">    }</a>
<a name="ln352"> </a>
<a name="ln353">    if (can_run_any(work)) {</a>
<a name="ln354">        GListPtr gIter = NULL;</a>
<a name="ln355"> </a>
<a name="ln356">        if (is_set(flags, pe_weights_forward)) {</a>
<a name="ln357">            gIter = rsc-&gt;rsc_cons;</a>
<a name="ln358">            crm_trace(&quot;Checking %d additional colocation constraints&quot;, g_list_length(gIter));</a>
<a name="ln359"> </a>
<a name="ln360">        } else if(rsc-&gt;variant == pe_group &amp;&amp; rsc-&gt;children) {</a>
<a name="ln361">            GListPtr last = rsc-&gt;children;</a>
<a name="ln362"> </a>
<a name="ln363">            while (last-&gt;next != NULL) {</a>
<a name="ln364">                last = last-&gt;next;</a>
<a name="ln365">            }</a>
<a name="ln366"> </a>
<a name="ln367">            gIter = ((resource_t*)last-&gt;data)-&gt;rsc_cons_lhs;</a>
<a name="ln368">            crm_trace(&quot;Checking %d additional optional group colocation constraints from %s&quot;,</a>
<a name="ln369">                      g_list_length(gIter), ((resource_t*)last-&gt;data)-&gt;id);</a>
<a name="ln370"> </a>
<a name="ln371">        } else {</a>
<a name="ln372">            gIter = rsc-&gt;rsc_cons_lhs;</a>
<a name="ln373">            crm_trace(&quot;Checking %d additional optional colocation constraints %s&quot;, g_list_length(gIter), rsc-&gt;id);</a>
<a name="ln374">        }</a>
<a name="ln375"> </a>
<a name="ln376">        for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln377">            resource_t *other = NULL;</a>
<a name="ln378">            rsc_colocation_t *constraint = (rsc_colocation_t *) gIter-&gt;data;</a>
<a name="ln379"> </a>
<a name="ln380">            if (is_set(flags, pe_weights_forward)) {</a>
<a name="ln381">                other = constraint-&gt;rsc_rh;</a>
<a name="ln382">            } else {</a>
<a name="ln383">                other = constraint-&gt;rsc_lh;</a>
<a name="ln384">            }</a>
<a name="ln385"> </a>
<a name="ln386">            pe_rsc_trace(rsc, &quot;Applying %s (%s)&quot;, constraint-&gt;id, other-&gt;id);</a>
<a name="ln387">            work = rsc_merge_weights(other, rhs, work, constraint-&gt;node_attribute,</a>
<a name="ln388">                                     multiplier * (float)constraint-&gt;score / INFINITY, flags|pe_weights_rollback);</a>
<a name="ln389">            dump_node_scores(LOG_TRACE, NULL, rhs, work);</a>
<a name="ln390">        }</a>
<a name="ln391"> </a>
<a name="ln392">    }</a>
<a name="ln393"> </a>
<a name="ln394">    if (is_set(flags, pe_weights_positive)) {</a>
<a name="ln395">        node_t *node = NULL;</a>
<a name="ln396">        GHashTableIter iter;</a>
<a name="ln397"> </a>
<a name="ln398">        g_hash_table_iter_init(&amp;iter, work);</a>
<a name="ln399">        while (g_hash_table_iter_next(&amp;iter, NULL, (void **)&amp;node)) {</a>
<a name="ln400">            if (node-&gt;weight == INFINITY_HACK) {</a>
<a name="ln401">                node-&gt;weight = 1;</a>
<a name="ln402">            }</a>
<a name="ln403">        }</a>
<a name="ln404">    }</a>
<a name="ln405"> </a>
<a name="ln406">    if (nodes) {</a>
<a name="ln407">        g_hash_table_destroy(nodes);</a>
<a name="ln408">    }</a>
<a name="ln409"> </a>
<a name="ln410">    clear_bit(rsc-&gt;flags, pe_rsc_merging);</a>
<a name="ln411">    return work;</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">node_t *</a>
<a name="ln415">native_color(resource_t * rsc, node_t * prefer, pe_working_set_t * data_set)</a>
<a name="ln416">{</a>
<a name="ln417">    GListPtr gIter = NULL;</a>
<a name="ln418">    int alloc_details = scores_log_level + 1;</a>
<a name="ln419"> </a>
<a name="ln420">    if (rsc-&gt;parent &amp;&amp; is_not_set(rsc-&gt;parent-&gt;flags, pe_rsc_allocating)) {</a>
<a name="ln421">        /* never allocate children on their own */</a>
<a name="ln422">        pe_rsc_debug(rsc, &quot;Escalating allocation of %s to its parent: %s&quot;, rsc-&gt;id,</a>
<a name="ln423">                     rsc-&gt;parent-&gt;id);</a>
<a name="ln424">        rsc-&gt;parent-&gt;cmds-&gt;allocate(rsc-&gt;parent, prefer, data_set);</a>
<a name="ln425">    }</a>
<a name="ln426"> </a>
<a name="ln427">    if (is_not_set(rsc-&gt;flags, pe_rsc_provisional)) {</a>
<a name="ln428">        return rsc-&gt;allocated_to;</a>
<a name="ln429">    }</a>
<a name="ln430"> </a>
<a name="ln431">    if (is_set(rsc-&gt;flags, pe_rsc_allocating)) {</a>
<a name="ln432">        pe_rsc_debug(rsc, &quot;Dependency loop detected involving %s&quot;, rsc-&gt;id);</a>
<a name="ln433">        return NULL;</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">    set_bit(rsc-&gt;flags, pe_rsc_allocating);</a>
<a name="ln437">    print_resource(alloc_details, &quot;Allocating: &quot;, rsc, FALSE);</a>
<a name="ln438">    dump_node_scores(alloc_details, rsc, &quot;Pre-alloc&quot;, rsc-&gt;allowed_nodes);</a>
<a name="ln439"> </a>
<a name="ln440">    for (gIter = rsc-&gt;rsc_cons; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln441">        rsc_colocation_t *constraint = (rsc_colocation_t *) gIter-&gt;data;</a>
<a name="ln442"> </a>
<a name="ln443">        GHashTable *archive = NULL;</a>
<a name="ln444">        resource_t *rsc_rh = constraint-&gt;rsc_rh;</a>
<a name="ln445"> </a>
<a name="ln446">        pe_rsc_trace(rsc, &quot;%s: Pre-Processing %s (%s, %d, %s)&quot;,</a>
<a name="ln447">                     rsc-&gt;id, constraint-&gt;id, rsc_rh-&gt;id,</a>
<a name="ln448">                     constraint-&gt;score, role2text(constraint-&gt;role_lh));</a>
<a name="ln449">        if (constraint-&gt;role_lh &gt;= RSC_ROLE_MASTER</a>
<a name="ln450">            || (constraint-&gt;score &lt; 0 &amp;&amp; constraint-&gt;score &gt; -INFINITY)) {</a>
<a name="ln451">            archive = node_hash_dup(rsc-&gt;allowed_nodes);</a>
<a name="ln452">        }</a>
<a name="ln453">        rsc_rh-&gt;cmds-&gt;allocate(rsc_rh, NULL, data_set);</a>
<a name="ln454">        rsc-&gt;cmds-&gt;rsc_colocation_lh(rsc, rsc_rh, constraint);</a>
<a name="ln455">        if (archive &amp;&amp; can_run_any(rsc-&gt;allowed_nodes) == FALSE) {</a>
<a name="ln456">            pe_rsc_info(rsc, &quot;%s: Rolling back scores from %s&quot;, rsc-&gt;id, rsc_rh-&gt;id);</a>
<a name="ln457">            g_hash_table_destroy(rsc-&gt;allowed_nodes);</a>
<a name="ln458">            rsc-&gt;allowed_nodes = archive;</a>
<a name="ln459">            archive = NULL;</a>
<a name="ln460">        }</a>
<a name="ln461">        if (archive) {</a>
<a name="ln462">            g_hash_table_destroy(archive);</a>
<a name="ln463">        }</a>
<a name="ln464">    }</a>
<a name="ln465"> </a>
<a name="ln466">    dump_node_scores(alloc_details, rsc, &quot;Post-coloc&quot;, rsc-&gt;allowed_nodes);</a>
<a name="ln467"> </a>
<a name="ln468">    for (gIter = rsc-&gt;rsc_cons_lhs; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln469">        rsc_colocation_t *constraint = (rsc_colocation_t *) gIter-&gt;data;</a>
<a name="ln470"> </a>
<a name="ln471">        rsc-&gt;allowed_nodes =</a>
<a name="ln472">            constraint-&gt;rsc_lh-&gt;cmds-&gt;merge_weights(constraint-&gt;rsc_lh, rsc-&gt;id, rsc-&gt;allowed_nodes,</a>
<a name="ln473">                                                    constraint-&gt;node_attribute,</a>
<a name="ln474">                                                    (float)constraint-&gt;score / INFINITY,</a>
<a name="ln475">                                                    pe_weights_rollback);</a>
<a name="ln476">    }</a>
<a name="ln477"> </a>
<a name="ln478">    print_resource(LOG_DEBUG_2, &quot;Allocating: &quot;, rsc, FALSE);</a>
<a name="ln479">    if (rsc-&gt;next_role == RSC_ROLE_STOPPED) {</a>
<a name="ln480">        pe_rsc_trace(rsc, &quot;Making sure %s doesn't get allocated&quot;, rsc-&gt;id);</a>
<a name="ln481">        /* make sure it doesn't come up again */</a>
<a name="ln482">        resource_location(rsc, NULL, -INFINITY, XML_RSC_ATTR_TARGET_ROLE, data_set);</a>
<a name="ln483"> </a>
<a name="ln484">    } else if(rsc-&gt;next_role &gt; rsc-&gt;role</a>
<a name="ln485">              &amp;&amp; is_set(data_set-&gt;flags, pe_flag_have_quorum) == FALSE</a>
<a name="ln486">              &amp;&amp; data_set-&gt;no_quorum_policy == no_quorum_freeze) {</a>
<a name="ln487">        crm_notice(&quot;Resource %s cannot be elevated from %s to %s: no-quorum-policy=freeze&quot;,</a>
<a name="ln488">                   rsc-&gt;id, role2text(rsc-&gt;role), role2text(rsc-&gt;next_role));</a>
<a name="ln489">        rsc-&gt;next_role = rsc-&gt;role;</a>
<a name="ln490">    }</a>
<a name="ln491"> </a>
<a name="ln492">    dump_node_scores(show_scores ? 0 : scores_log_level, rsc, __FUNCTION__,</a>
<a name="ln493">                     rsc-&gt;allowed_nodes);</a>
<a name="ln494">    if (is_set(data_set-&gt;flags, pe_flag_stonith_enabled)</a>
<a name="ln495">        &amp;&amp; is_set(data_set-&gt;flags, pe_flag_have_stonith_resource) == FALSE) {</a>
<a name="ln496">        clear_bit(rsc-&gt;flags, pe_rsc_managed);</a>
<a name="ln497">    }</a>
<a name="ln498"> </a>
<a name="ln499">    if (is_not_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln500">        const char *reason = NULL;</a>
<a name="ln501">        node_t *assign_to = NULL;</a>
<a name="ln502"> </a>
<a name="ln503">        rsc-&gt;next_role = rsc-&gt;role;</a>
<a name="ln504">        if (rsc-&gt;running_on == NULL) {</a>
<a name="ln505">            reason = &quot;inactive&quot;;</a>
<a name="ln506">        } else if (rsc-&gt;role == RSC_ROLE_MASTER) {</a>
<a name="ln507">            assign_to = rsc-&gt;running_on-&gt;data;</a>
<a name="ln508">            reason = &quot;master&quot;;</a>
<a name="ln509">        } else if (is_set(rsc-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln510">            assign_to = rsc-&gt;running_on-&gt;data;</a>
<a name="ln511">            reason = &quot;failed&quot;;</a>
<a name="ln512">        } else {</a>
<a name="ln513">            assign_to = rsc-&gt;running_on-&gt;data;</a>
<a name="ln514">            reason = &quot;active&quot;;</a>
<a name="ln515">        }</a>
<a name="ln516">        pe_rsc_info(rsc, &quot;Unmanaged resource %s allocated to %s: %s&quot;, rsc-&gt;id,</a>
<a name="ln517">                    assign_to ? assign_to-&gt;details-&gt;uname : &quot;'nowhere'&quot;, reason);</a>
<a name="ln518">        native_assign_node(rsc, NULL, assign_to, TRUE);</a>
<a name="ln519"> </a>
<a name="ln520">    } else if (is_set(data_set-&gt;flags, pe_flag_stop_everything)) {</a>
<a name="ln521">        pe_rsc_debug(rsc, &quot;Forcing %s to stop&quot;, rsc-&gt;id);</a>
<a name="ln522">        native_assign_node(rsc, NULL, NULL, TRUE);</a>
<a name="ln523"> </a>
<a name="ln524">    } else if (is_set(rsc-&gt;flags, pe_rsc_provisional)</a>
<a name="ln525">               &amp;&amp; native_choose_node(rsc, prefer, data_set)) {</a>
<a name="ln526">        pe_rsc_trace(rsc, &quot;Allocated resource %s to %s&quot;, rsc-&gt;id,</a>
<a name="ln527">                     rsc-&gt;allocated_to-&gt;details-&gt;uname);</a>
<a name="ln528"> </a>
<a name="ln529">    } else if (rsc-&gt;allocated_to == NULL) {</a>
<a name="ln530">        if (is_not_set(rsc-&gt;flags, pe_rsc_orphan)) {</a>
<a name="ln531">            pe_rsc_info(rsc, &quot;Resource %s cannot run anywhere&quot;, rsc-&gt;id);</a>
<a name="ln532">        } else if (rsc-&gt;running_on != NULL) {</a>
<a name="ln533">            pe_rsc_info(rsc, &quot;Stopping orphan resource %s&quot;, rsc-&gt;id);</a>
<a name="ln534">        }</a>
<a name="ln535"> </a>
<a name="ln536">    } else {</a>
<a name="ln537">        pe_rsc_debug(rsc, &quot;Pre-Allocated resource %s to %s&quot;, rsc-&gt;id,</a>
<a name="ln538">                     rsc-&gt;allocated_to-&gt;details-&gt;uname);</a>
<a name="ln539">    }</a>
<a name="ln540"> </a>
<a name="ln541">    clear_bit(rsc-&gt;flags, pe_rsc_allocating);</a>
<a name="ln542">    print_resource(LOG_DEBUG_3, &quot;Allocated &quot;, rsc, TRUE);</a>
<a name="ln543"> </a>
<a name="ln544">    if (rsc-&gt;is_remote_node) {</a>
<a name="ln545">        node_t *remote_node = pe_find_node(data_set-&gt;nodes, rsc-&gt;id);</a>
<a name="ln546"> </a>
<a name="ln547">        CRM_ASSERT(remote_node != NULL);</a>
<a name="ln548">        if (rsc-&gt;allocated_to &amp;&amp; rsc-&gt;next_role != RSC_ROLE_STOPPED) {</a>
<a name="ln549">            crm_trace(&quot;Setting remote node %s to ONLINE&quot;, remote_node-&gt;details-&gt;id);</a>
<a name="ln550">            remote_node-&gt;details-&gt;online = TRUE;</a>
<a name="ln551">            /* We shouldn't consider an unseen remote-node unclean if we are going</a>
<a name="ln552">             * to try and connect to it. Otherwise we get an unnecessary fence */</a>
<a name="ln553">            if (remote_node-&gt;details-&gt;unseen == TRUE) {</a>
<a name="ln554">                remote_node-&gt;details-&gt;unclean = FALSE;</a>
<a name="ln555">            }</a>
<a name="ln556"> </a>
<a name="ln557">        } else {</a>
<a name="ln558">            crm_trace(&quot;Setting remote node %s to SHUTDOWN.  next role = %s, allocated=%s&quot;,</a>
<a name="ln559">                remote_node-&gt;details-&gt;id, role2text(rsc-&gt;next_role), rsc-&gt;allocated_to ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln560">            remote_node-&gt;details-&gt;shutdown = TRUE;</a>
<a name="ln561">        }</a>
<a name="ln562">    }</a>
<a name="ln563"> </a>
<a name="ln564">    return rsc-&gt;allocated_to;</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">static gboolean</a>
<a name="ln568">is_op_dup(resource_t * rsc, const char *name, const char *interval)</a>
<a name="ln569">{</a>
<a name="ln570">    gboolean dup = FALSE;</a>
<a name="ln571">    const char *id = NULL;</a>
<a name="ln572">    const char *value = NULL;</a>
<a name="ln573">    xmlNode *operation = NULL;</a>
<a name="ln574"> </a>
<a name="ln575">    CRM_ASSERT(rsc);</a>
<a name="ln576">    for (operation = __xml_first_child(rsc-&gt;ops_xml); operation != NULL;</a>
<a name="ln577">         operation = __xml_next_element(operation)) {</a>
<a name="ln578">        if (crm_str_eq((const char *)operation-&gt;name, &quot;op&quot;, TRUE)) {</a>
<a name="ln579">            value = crm_element_value(operation, &quot;name&quot;);</a>
<a name="ln580">            if (safe_str_neq(value, name)) {</a>
<a name="ln581">                continue;</a>
<a name="ln582">            }</a>
<a name="ln583"> </a>
<a name="ln584">            value = crm_element_value(operation, XML_LRM_ATTR_INTERVAL);</a>
<a name="ln585">            if (value == NULL) {</a>
<a name="ln586">                value = &quot;0&quot;;</a>
<a name="ln587">            }</a>
<a name="ln588"> </a>
<a name="ln589">            if (safe_str_neq(value, interval)) {</a>
<a name="ln590">                continue;</a>
<a name="ln591">            }</a>
<a name="ln592"> </a>
<a name="ln593">            if (id == NULL) {</a>
<a name="ln594">                id = ID(operation);</a>
<a name="ln595"> </a>
<a name="ln596">            } else {</a>
<a name="ln597">                crm_config_err(&quot;Operation %s is a duplicate of %s&quot;, ID(operation), id);</a>
<a name="ln598">                crm_config_err</a>
<a name="ln599">                    (&quot;Do not use the same (name, interval) combination more than once per resource&quot;);</a>
<a name="ln600">                dup = TRUE;</a>
<a name="ln601">            }</a>
<a name="ln602">        }</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">    return dup;</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">void</a>
<a name="ln609">RecurringOp(resource_t * rsc, action_t * start, node_t * node,</a>
<a name="ln610">            xmlNode * operation, pe_working_set_t * data_set)</a>
<a name="ln611">{</a>
<a name="ln612">    char *key = NULL;</a>
<a name="ln613">    const char *name = NULL;</a>
<a name="ln614">    const char *value = NULL;</a>
<a name="ln615">    const char *interval = NULL;</a>
<a name="ln616">    const char *node_uname = NULL;</a>
<a name="ln617"> </a>
<a name="ln618">    unsigned long long interval_ms = 0;</a>
<a name="ln619">    action_t *mon = NULL;</a>
<a name="ln620">    gboolean is_optional = TRUE;</a>
<a name="ln621">    GListPtr possible_matches = NULL;</a>
<a name="ln622"> </a>
<a name="ln623">    /* Only process for the operations without role=&quot;Stopped&quot; */</a>
<a name="ln624">    value = crm_element_value(operation, &quot;role&quot;);</a>
<a name="ln625">    if (value &amp;&amp; text2role(value) == RSC_ROLE_STOPPED) {</a>
<a name="ln626">        return;</a>
<a name="ln627">    }</a>
<a name="ln628"> </a>
<a name="ln629">    CRM_ASSERT(rsc);</a>
<a name="ln630">    pe_rsc_trace(rsc, &quot;Creating recurring action %s for %s in role %s on %s&quot;,</a>
<a name="ln631">                 ID(operation), rsc-&gt;id, role2text(rsc-&gt;next_role),</a>
<a name="ln632">                 node ? node-&gt;details-&gt;uname : &quot;n/a&quot;);</a>
<a name="ln633"> </a>
<a name="ln634">    if (node != NULL) {</a>
<a name="ln635">        node_uname = node-&gt;details-&gt;uname;</a>
<a name="ln636">    }</a>
<a name="ln637"> </a>
<a name="ln638">    interval = crm_element_value(operation, XML_LRM_ATTR_INTERVAL);</a>
<a name="ln639">    interval_ms = crm_get_interval(interval);</a>
<a name="ln640"> </a>
<a name="ln641">    if (interval_ms == 0) {</a>
<a name="ln642">        return;</a>
<a name="ln643">    }</a>
<a name="ln644"> </a>
<a name="ln645">    name = crm_element_value(operation, &quot;name&quot;);</a>
<a name="ln646">    if (is_op_dup(rsc, name, interval)) {</a>
<a name="ln647">        return;</a>
<a name="ln648">    }</a>
<a name="ln649"> </a>
<a name="ln650">    if (safe_str_eq(name, RSC_STOP)</a>
<a name="ln651">        || safe_str_eq(name, RSC_START)</a>
<a name="ln652">        || safe_str_eq(name, RSC_DEMOTE)</a>
<a name="ln653">        || safe_str_eq(name, RSC_PROMOTE)</a>
<a name="ln654">        ) {</a>
<a name="ln655">        crm_config_err(&quot;Invalid recurring action %s wth name: '%s'&quot;, ID(operation), name);</a>
<a name="ln656">        return;</a>
<a name="ln657">    }</a>
<a name="ln658"> </a>
<a name="ln659">    key = generate_op_key(rsc-&gt;id, name, interval_ms);</a>
<a name="ln660">    if (find_rsc_op_entry(rsc, key) == NULL) {</a>
<a name="ln661">        /* disabled */</a>
<a name="ln662">        free(key);</a>
<a name="ln663">        return;</a>
<a name="ln664">    }</a>
<a name="ln665"> </a>
<a name="ln666">    if (start != NULL) {</a>
<a name="ln667">        pe_rsc_trace(rsc, &quot;Marking %s %s due to %s&quot;,</a>
<a name="ln668">                     key, is_set(start-&gt;flags, pe_action_optional) ? &quot;optional&quot; : &quot;mandatory&quot;,</a>
<a name="ln669">                     start-&gt;uuid);</a>
<a name="ln670">        is_optional = (rsc-&gt;cmds-&gt;action_flags(start, NULL) &amp; pe_action_optional);</a>
<a name="ln671">    } else {</a>
<a name="ln672">        pe_rsc_trace(rsc, &quot;Marking %s optional&quot;, key);</a>
<a name="ln673">        is_optional = TRUE;</a>
<a name="ln674">    }</a>
<a name="ln675"> </a>
<a name="ln676">    /* start a monitor for an already active resource */</a>
<a name="ln677">    possible_matches = find_actions_exact(rsc-&gt;actions, key, node);</a>
<a name="ln678">    if (possible_matches == NULL) {</a>
<a name="ln679">        is_optional = FALSE;</a>
<a name="ln680">        pe_rsc_trace(rsc, &quot;Marking %s mandatory: not active&quot;, key);</a>
<a name="ln681"> </a>
<a name="ln682">    } else {</a>
<a name="ln683">        GListPtr gIter = NULL;</a>
<a name="ln684"> </a>
<a name="ln685">        for (gIter = possible_matches; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln686">            action_t *op = (action_t *) gIter-&gt;data;</a>
<a name="ln687"> </a>
<a name="ln688">            if (is_set(op-&gt;flags, pe_action_reschedule)) {</a>
<a name="ln689">                is_optional = FALSE;</a>
<a name="ln690">                break;</a>
<a name="ln691">            }</a>
<a name="ln692">        }</a>
<a name="ln693">        g_list_free(possible_matches);</a>
<a name="ln694">    }</a>
<a name="ln695"> </a>
<a name="ln696">    if ((rsc-&gt;next_role == RSC_ROLE_MASTER &amp;&amp; value == NULL)</a>
<a name="ln697">        || (value != NULL &amp;&amp; text2role(value) != rsc-&gt;next_role)) {</a>
<a name="ln698">        int log_level = LOG_DEBUG_2;</a>
<a name="ln699">        const char *result = &quot;Ignoring&quot;;</a>
<a name="ln700"> </a>
<a name="ln701">        if (is_optional) {</a>
<a name="ln702">            char *local_key = strdup(key);</a>
<a name="ln703"> </a>
<a name="ln704">            log_level = LOG_INFO;</a>
<a name="ln705">            result = &quot;Cancelling&quot;;</a>
<a name="ln706">            /* it's running : cancel it */</a>
<a name="ln707"> </a>
<a name="ln708">            mon = custom_action(rsc, local_key, RSC_CANCEL, node, FALSE, TRUE, data_set);</a>
<a name="ln709"> </a>
<a name="ln710">            free(mon-&gt;task);</a>
<a name="ln711">            free(mon-&gt;cancel_task);</a>
<a name="ln712">            mon-&gt;task = strdup(RSC_CANCEL);</a>
<a name="ln713">            mon-&gt;cancel_task = strdup(name);</a>
<a name="ln714">            add_hash_param(mon-&gt;meta, XML_LRM_ATTR_INTERVAL, interval);</a>
<a name="ln715">            add_hash_param(mon-&gt;meta, XML_LRM_ATTR_TASK, name);</a>
<a name="ln716"> </a>
<a name="ln717">            local_key = NULL;</a>
<a name="ln718"> </a>
<a name="ln719">            switch (rsc-&gt;role) {</a>
<a name="ln720">                case RSC_ROLE_SLAVE:</a>
<a name="ln721">                case RSC_ROLE_STARTED:</a>
<a name="ln722">                    if (rsc-&gt;next_role == RSC_ROLE_MASTER) {</a>
<a name="ln723">                        local_key = promote_key(rsc);</a>
<a name="ln724"> </a>
<a name="ln725">                    } else if (rsc-&gt;next_role == RSC_ROLE_STOPPED) {</a>
<a name="ln726">                        local_key = stop_key(rsc);</a>
<a name="ln727">                    }</a>
<a name="ln728"> </a>
<a name="ln729">                    break;</a>
<a name="ln730">                case RSC_ROLE_MASTER:</a>
<a name="ln731">                    local_key = demote_key(rsc);</a>
<a name="ln732">                    break;</a>
<a name="ln733">                default:</a>
<a name="ln734">                    break;</a>
<a name="ln735">            }</a>
<a name="ln736"> </a>
<a name="ln737">            if (local_key) {</a>
<a name="ln738">                custom_action_order(rsc, NULL, mon, rsc, local_key, NULL,</a>
<a name="ln739">                                    pe_order_runnable_left, data_set);</a>
<a name="ln740">            }</a>
<a name="ln741"> </a>
<a name="ln742">            mon = NULL;</a>
<a name="ln743">        }</a>
<a name="ln744"> </a>
<a name="ln745">        do_crm_log(log_level, &quot;%s action %s (%s vs. %s)&quot;,</a>
<a name="ln746">                   result, key, value ? value : role2text(RSC_ROLE_SLAVE),</a>
<a name="ln747">                   role2text(rsc-&gt;next_role));</a>
<a name="ln748"> </a>
<a name="ln749">        free(key);</a>
<a name="ln750">        return;</a>
<a name="ln751">    }</a>
<a name="ln752"> </a>
<a name="ln753">    mon = custom_action(rsc, key, name, node, is_optional, TRUE, data_set);</a>
<a name="ln754">    key = mon-&gt;uuid;</a>
<a name="ln755">    if (is_optional) {</a>
<a name="ln756">        pe_rsc_trace(rsc, &quot;%s\t   %s (optional)&quot;, crm_str(node_uname), mon-&gt;uuid);</a>
<a name="ln757">    }</a>
<a name="ln758"> </a>
<a name="ln759">    if (start == NULL || is_set(start-&gt;flags, pe_action_runnable) == FALSE) {</a>
<a name="ln760">        pe_rsc_debug(rsc, &quot;%s\t   %s (cancelled : start un-runnable)&quot;, crm_str(node_uname),</a>
<a name="ln761">                     mon-&gt;uuid);</a>
<a name="ln762">        update_action_flags(mon, pe_action_runnable | pe_action_clear, __FUNCTION__, __LINE__);</a>
<a name="ln763"> </a>
<a name="ln764">    } else if (node == NULL || node-&gt;details-&gt;online == FALSE || node-&gt;details-&gt;unclean) {</a>
<a name="ln765">        pe_rsc_debug(rsc, &quot;%s\t   %s (cancelled : no node available)&quot;, crm_str(node_uname),</a>
<a name="ln766">                     mon-&gt;uuid);</a>
<a name="ln767">        update_action_flags(mon, pe_action_runnable | pe_action_clear, __FUNCTION__, __LINE__);</a>
<a name="ln768"> </a>
<a name="ln769">    } else if (is_set(mon-&gt;flags, pe_action_optional) == FALSE) {</a>
<a name="ln770">        pe_rsc_info(rsc, &quot; Start recurring %s (%llus) for %s on %s&quot;, mon-&gt;task, interval_ms / 1000,</a>
<a name="ln771">                    rsc-&gt;id, crm_str(node_uname));</a>
<a name="ln772">    }</a>
<a name="ln773"> </a>
<a name="ln774">    if (rsc-&gt;next_role == RSC_ROLE_MASTER) {</a>
<a name="ln775">        char *running_master = crm_itoa(PCMK_OCF_RUNNING_MASTER);</a>
<a name="ln776"> </a>
<a name="ln777">        add_hash_param(mon-&gt;meta, XML_ATTR_TE_TARGET_RC, running_master);</a>
<a name="ln778">        free(running_master);</a>
<a name="ln779">    }</a>
<a name="ln780"> </a>
<a name="ln781">    if (node == NULL || is_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln782">        custom_action_order(rsc, start_key(rsc), NULL,</a>
<a name="ln783">                            NULL, strdup(key), mon,</a>
<a name="ln784">                            pe_order_implies_then | pe_order_runnable_left, data_set);</a>
<a name="ln785"> </a>
<a name="ln786">        custom_action_order(rsc, reload_key(rsc), NULL,</a>
<a name="ln787">                            NULL, strdup(key), mon,</a>
<a name="ln788">                            pe_order_implies_then | pe_order_runnable_left, data_set);</a>
<a name="ln789"> </a>
<a name="ln790">        if (rsc-&gt;next_role == RSC_ROLE_MASTER) {</a>
<a name="ln791">            custom_action_order(rsc, promote_key(rsc), NULL,</a>
<a name="ln792">                                rsc, NULL, mon,</a>
<a name="ln793">                                pe_order_optional | pe_order_runnable_left, data_set);</a>
<a name="ln794"> </a>
<a name="ln795">        } else if (rsc-&gt;role == RSC_ROLE_MASTER) {</a>
<a name="ln796">            custom_action_order(rsc, demote_key(rsc), NULL,</a>
<a name="ln797">                                rsc, NULL, mon,</a>
<a name="ln798">                                pe_order_optional | pe_order_runnable_left, data_set);</a>
<a name="ln799">        }</a>
<a name="ln800">    }</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">void</a>
<a name="ln804">Recurring(resource_t * rsc, action_t * start, node_t * node, pe_working_set_t * data_set)</a>
<a name="ln805">{</a>
<a name="ln806">    if (is_not_set(rsc-&gt;flags, pe_rsc_maintenance) &amp;&amp;</a>
<a name="ln807">        (node == NULL || node-&gt;details-&gt;maintenance == FALSE)) {</a>
<a name="ln808">        xmlNode *operation = NULL;</a>
<a name="ln809"> </a>
<a name="ln810">        for (operation = __xml_first_child(rsc-&gt;ops_xml); operation != NULL;</a>
<a name="ln811">             operation = __xml_next_element(operation)) {</a>
<a name="ln812">            if (crm_str_eq((const char *)operation-&gt;name, &quot;op&quot;, TRUE)) {</a>
<a name="ln813">                RecurringOp(rsc, start, node, operation, data_set);</a>
<a name="ln814">            }</a>
<a name="ln815">        }</a>
<a name="ln816">    }</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">void</a>
<a name="ln820">RecurringOp_Stopped(resource_t * rsc, action_t * start, node_t * node,</a>
<a name="ln821">                    xmlNode * operation, pe_working_set_t * data_set)</a>
<a name="ln822">{</a>
<a name="ln823">    char *key = NULL;</a>
<a name="ln824">    const char *name = NULL;</a>
<a name="ln825">    const char *role = NULL;</a>
<a name="ln826">    const char *interval = NULL;</a>
<a name="ln827">    const char *node_uname = NULL;</a>
<a name="ln828"> </a>
<a name="ln829">    unsigned long long interval_ms = 0;</a>
<a name="ln830">    GListPtr possible_matches = NULL;</a>
<a name="ln831">    GListPtr gIter = NULL;</a>
<a name="ln832"> </a>
<a name="ln833">    /* TODO: Support of non-unique clone */</a>
<a name="ln834">    if (is_set(rsc-&gt;flags, pe_rsc_unique) == FALSE) {</a>
<a name="ln835">        return;</a>
<a name="ln836">    }</a>
<a name="ln837"> </a>
<a name="ln838">    /* Only process for the operations with role=&quot;Stopped&quot; */</a>
<a name="ln839">    role = crm_element_value(operation, &quot;role&quot;);</a>
<a name="ln840">    if (role == NULL || text2role(role) != RSC_ROLE_STOPPED) {</a>
<a name="ln841">        return;</a>
<a name="ln842">    }</a>
<a name="ln843"> </a>
<a name="ln844">    pe_rsc_trace(rsc,</a>
<a name="ln845">                 &quot;Creating recurring actions %s for %s in role %s on nodes where it'll not be running&quot;,</a>
<a name="ln846">                 ID(operation), rsc-&gt;id, role2text(rsc-&gt;next_role));</a>
<a name="ln847"> </a>
<a name="ln848">    if (node != NULL) {</a>
<a name="ln849">        node_uname = node-&gt;details-&gt;uname;</a>
<a name="ln850">    }</a>
<a name="ln851"> </a>
<a name="ln852">    interval = crm_element_value(operation, XML_LRM_ATTR_INTERVAL);</a>
<a name="ln853">    interval_ms = crm_get_interval(interval);</a>
<a name="ln854"> </a>
<a name="ln855">    if (interval_ms == 0) {</a>
<a name="ln856">        return;</a>
<a name="ln857">    }</a>
<a name="ln858"> </a>
<a name="ln859">    name = crm_element_value(operation, &quot;name&quot;);</a>
<a name="ln860">    if (is_op_dup(rsc, name, interval)) {</a>
<a name="ln861">        return;</a>
<a name="ln862">    }</a>
<a name="ln863"> </a>
<a name="ln864">    if (safe_str_eq(name, RSC_STOP)</a>
<a name="ln865">        || safe_str_eq(name, RSC_START)</a>
<a name="ln866">        || safe_str_eq(name, RSC_DEMOTE)</a>
<a name="ln867">        || safe_str_eq(name, RSC_PROMOTE)</a>
<a name="ln868">        ) {</a>
<a name="ln869">        crm_config_err(&quot;Invalid recurring action %s wth name: '%s'&quot;, ID(operation), name);</a>
<a name="ln870">        return;</a>
<a name="ln871">    }</a>
<a name="ln872"> </a>
<a name="ln873">    key = generate_op_key(rsc-&gt;id, name, interval_ms);</a>
<a name="ln874">    if (find_rsc_op_entry(rsc, key) == NULL) {</a>
<a name="ln875">        /* disabled */</a>
<a name="ln876">        free(key);</a>
<a name="ln877">        return;</a>
<a name="ln878">    }</a>
<a name="ln879"> </a>
<a name="ln880">    /* if the monitor exists on the node where the resource will be running, cancel it */</a>
<a name="ln881">    if (node != NULL) {</a>
<a name="ln882">        possible_matches = find_actions_exact(rsc-&gt;actions, key, node);</a>
<a name="ln883">        if (possible_matches) {</a>
<a name="ln884">            action_t *cancel_op = NULL;</a>
<a name="ln885">            char *local_key = strdup(key);</a>
<a name="ln886"> </a>
<a name="ln887">            g_list_free(possible_matches);</a>
<a name="ln888"> </a>
<a name="ln889">            cancel_op = custom_action(rsc, local_key, RSC_CANCEL, node, FALSE, TRUE, data_set);</a>
<a name="ln890"> </a>
<a name="ln891">            free(cancel_op-&gt;task);</a>
<a name="ln892">            free(cancel_op-&gt;cancel_task);</a>
<a name="ln893">            cancel_op-&gt;task = strdup(RSC_CANCEL);</a>
<a name="ln894">            cancel_op-&gt;cancel_task = strdup(name);</a>
<a name="ln895">            add_hash_param(cancel_op-&gt;meta, XML_LRM_ATTR_INTERVAL, interval);</a>
<a name="ln896">            add_hash_param(cancel_op-&gt;meta, XML_LRM_ATTR_TASK, name);</a>
<a name="ln897"> </a>
<a name="ln898">            local_key = NULL;</a>
<a name="ln899"> </a>
<a name="ln900">            if (rsc-&gt;next_role == RSC_ROLE_STARTED || rsc-&gt;next_role == RSC_ROLE_SLAVE) {</a>
<a name="ln901">                /* rsc-&gt;role == RSC_ROLE_STOPPED: cancel the monitor before start */</a>
<a name="ln902">                /* rsc-&gt;role == RSC_ROLE_STARTED: for a migration, cancel the monitor on the target node before start */</a>
<a name="ln903">                custom_action_order(rsc, NULL, cancel_op, rsc, start_key(rsc), NULL,</a>
<a name="ln904">                                    pe_order_runnable_left, data_set);</a>
<a name="ln905">            }</a>
<a name="ln906"> </a>
<a name="ln907">            pe_rsc_info(rsc, &quot;Cancel action %s (%s vs. %s) on %s&quot;,</a>
<a name="ln908">                        key, role, role2text(rsc-&gt;next_role), crm_str(node_uname));</a>
<a name="ln909">        }</a>
<a name="ln910">    }</a>
<a name="ln911"> </a>
<a name="ln912">    for (gIter = data_set-&gt;nodes; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln913">        node_t *stop_node = (node_t *) gIter-&gt;data;</a>
<a name="ln914">        const char *stop_node_uname = stop_node-&gt;details-&gt;uname;</a>
<a name="ln915">        gboolean is_optional = TRUE;</a>
<a name="ln916">        gboolean probe_is_optional = TRUE;</a>
<a name="ln917">        gboolean stop_is_optional = TRUE;</a>
<a name="ln918">        action_t *stopped_mon = NULL;</a>
<a name="ln919">        char *rc_inactive = NULL;</a>
<a name="ln920">        GListPtr probe_complete_ops = NULL;</a>
<a name="ln921">        GListPtr stop_ops = NULL;</a>
<a name="ln922">        GListPtr local_gIter = NULL;</a>
<a name="ln923">        char *stop_op_key = NULL;</a>
<a name="ln924"> </a>
<a name="ln925">        if (node_uname &amp;&amp; safe_str_eq(stop_node_uname, node_uname)) {</a>
<a name="ln926">            continue;</a>
<a name="ln927">        }</a>
<a name="ln928"> </a>
<a name="ln929">        pe_rsc_trace(rsc, &quot;Creating recurring action %s for %s on %s&quot;,</a>
<a name="ln930">                     ID(operation), rsc-&gt;id, crm_str(stop_node_uname));</a>
<a name="ln931"> </a>
<a name="ln932">        /* start a monitor for an already stopped resource */</a>
<a name="ln933">        possible_matches = find_actions_exact(rsc-&gt;actions, key, stop_node);</a>
<a name="ln934">        if (possible_matches == NULL) {</a>
<a name="ln935">            pe_rsc_trace(rsc, &quot;Marking %s mandatory on %s: not active&quot;, key,</a>
<a name="ln936">                         crm_str(stop_node_uname));</a>
<a name="ln937">            is_optional = FALSE;</a>
<a name="ln938">        } else {</a>
<a name="ln939">            pe_rsc_trace(rsc, &quot;Marking %s optional on %s: already active&quot;, key,</a>
<a name="ln940">                         crm_str(stop_node_uname));</a>
<a name="ln941">            is_optional = TRUE;</a>
<a name="ln942">            g_list_free(possible_matches);</a>
<a name="ln943">        }</a>
<a name="ln944"> </a>
<a name="ln945">        stopped_mon = custom_action(rsc, strdup(key), name, stop_node, is_optional, TRUE, data_set);</a>
<a name="ln946"> </a>
<a name="ln947">        rc_inactive = crm_itoa(PCMK_OCF_NOT_RUNNING);</a>
<a name="ln948">        add_hash_param(stopped_mon-&gt;meta, XML_ATTR_TE_TARGET_RC, rc_inactive);</a>
<a name="ln949">        free(rc_inactive);</a>
<a name="ln950"> </a>
<a name="ln951">        if (is_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln952">            char *probe_key = generate_op_key(rsc-&gt;id, CRMD_ACTION_STATUS, 0);</a>
<a name="ln953">            GListPtr probes = find_actions(rsc-&gt;actions, probe_key, stop_node);</a>
<a name="ln954">            GListPtr pIter = NULL;</a>
<a name="ln955"> </a>
<a name="ln956">            for (pIter = probes; pIter != NULL; pIter = pIter-&gt;next) {</a>
<a name="ln957">                action_t *probe = (action_t *) pIter-&gt;data;</a>
<a name="ln958"> </a>
<a name="ln959">                order_actions(probe, stopped_mon, pe_order_runnable_left);</a>
<a name="ln960">                crm_trace(&quot;%s then %s on %s&quot;, probe-&gt;uuid, stopped_mon-&gt;uuid, stop_node-&gt;details-&gt;uname);</a>
<a name="ln961">            }</a>
<a name="ln962"> </a>
<a name="ln963">            g_list_free(probes);</a>
<a name="ln964">            free(probe_key);</a>
<a name="ln965">        }</a>
<a name="ln966"> </a>
<a name="ln967">        if (probe_complete_ops) {</a>
<a name="ln968">            g_list_free(probe_complete_ops);</a>
<a name="ln969">        }</a>
<a name="ln970"> </a>
<a name="ln971">        stop_op_key = stop_key(rsc);</a>
<a name="ln972">        stop_ops = find_actions_exact(rsc-&gt;actions, stop_op_key, stop_node);</a>
<a name="ln973"> </a>
<a name="ln974">        for (local_gIter = stop_ops; local_gIter != NULL; local_gIter = local_gIter-&gt;next) {</a>
<a name="ln975">            action_t *stop = (action_t *) local_gIter-&gt;data;</a>
<a name="ln976"> </a>
<a name="ln977">            if (is_set(stop-&gt;flags, pe_action_optional) == FALSE) {</a>
<a name="ln978">                stop_is_optional = FALSE;</a>
<a name="ln979">            }</a>
<a name="ln980"> </a>
<a name="ln981">            if (is_set(stop-&gt;flags, pe_action_runnable) == FALSE) {</a>
<a name="ln982">                crm_debug(&quot;%s\t   %s (cancelled : stop un-runnable)&quot;,</a>
<a name="ln983">                          crm_str(stop_node_uname), stopped_mon-&gt;uuid);</a>
<a name="ln984">                update_action_flags(stopped_mon, pe_action_runnable | pe_action_clear, __FUNCTION__, __LINE__);</a>
<a name="ln985">            }</a>
<a name="ln986"> </a>
<a name="ln987">            if (is_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln988">                custom_action_order(rsc, strdup(stop_op_key), stop,</a>
<a name="ln989">                                    NULL, strdup(key), stopped_mon,</a>
<a name="ln990">                                    pe_order_implies_then | pe_order_runnable_left, data_set);</a>
<a name="ln991">            }</a>
<a name="ln992"> </a>
<a name="ln993">        }</a>
<a name="ln994"> </a>
<a name="ln995">        if (stop_ops) {</a>
<a name="ln996">            g_list_free(stop_ops);</a>
<a name="ln997">        }</a>
<a name="ln998">        free(stop_op_key);</a>
<a name="ln999"> </a>
<a name="ln1000">        if (is_optional == FALSE &amp;&amp; probe_is_optional &amp;&amp; stop_is_optional</a>
<a name="ln1001">            &amp;&amp; is_set(rsc-&gt;flags, pe_rsc_managed) == FALSE) {</a>
<a name="ln1002">            pe_rsc_trace(rsc, &quot;Marking %s optional on %s due to unmanaged&quot;,</a>
<a name="ln1003">                         key, crm_str(stop_node_uname));</a>
<a name="ln1004">            update_action_flags(stopped_mon, pe_action_optional, __FUNCTION__, __LINE__);</a>
<a name="ln1005">        }</a>
<a name="ln1006"> </a>
<a name="ln1007">        if (is_set(stopped_mon-&gt;flags, pe_action_optional)) {</a>
<a name="ln1008">            pe_rsc_trace(rsc, &quot;%s\t   %s (optional)&quot;, crm_str(stop_node_uname), stopped_mon-&gt;uuid);</a>
<a name="ln1009">        }</a>
<a name="ln1010"> </a>
<a name="ln1011">        if (stop_node-&gt;details-&gt;online == FALSE || stop_node-&gt;details-&gt;unclean) {</a>
<a name="ln1012">            pe_rsc_debug(rsc, &quot;%s\t   %s (cancelled : no node available)&quot;,</a>
<a name="ln1013">                         crm_str(stop_node_uname), stopped_mon-&gt;uuid);</a>
<a name="ln1014">            update_action_flags(stopped_mon, pe_action_runnable | pe_action_clear, __FUNCTION__, __LINE__);</a>
<a name="ln1015">        }</a>
<a name="ln1016"> </a>
<a name="ln1017">        if (is_set(stopped_mon-&gt;flags, pe_action_runnable)</a>
<a name="ln1018">            &amp;&amp; is_set(stopped_mon-&gt;flags, pe_action_optional) == FALSE) {</a>
<a name="ln1019">            crm_notice(&quot; Start recurring %s (%llus) for %s on %s&quot;, stopped_mon-&gt;task,</a>
<a name="ln1020">                       interval_ms / 1000, rsc-&gt;id, crm_str(stop_node_uname));</a>
<a name="ln1021">        }</a>
<a name="ln1022">    }</a>
<a name="ln1023"> </a>
<a name="ln1024">    free(key);</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">void</a>
<a name="ln1028">Recurring_Stopped(resource_t * rsc, action_t * start, node_t * node, pe_working_set_t * data_set)</a>
<a name="ln1029">{</a>
<a name="ln1030">    if (is_not_set(rsc-&gt;flags, pe_rsc_maintenance) &amp;&amp; </a>
<a name="ln1031">        (node == NULL || node-&gt;details-&gt;maintenance == FALSE)) {</a>
<a name="ln1032">        xmlNode *operation = NULL;</a>
<a name="ln1033"> </a>
<a name="ln1034">        for (operation = __xml_first_child(rsc-&gt;ops_xml); operation != NULL;</a>
<a name="ln1035">             operation = __xml_next_element(operation)) {</a>
<a name="ln1036">            if (crm_str_eq((const char *)operation-&gt;name, &quot;op&quot;, TRUE)) {</a>
<a name="ln1037">                RecurringOp_Stopped(rsc, start, node, operation, data_set);</a>
<a name="ln1038">            }</a>
<a name="ln1039">        }</a>
<a name="ln1040">    }</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">static void</a>
<a name="ln1044">handle_migration_actions(resource_t * rsc, node_t *current, node_t *chosen, pe_working_set_t * data_set)</a>
<a name="ln1045">{</a>
<a name="ln1046">    action_t *migrate_to = NULL;</a>
<a name="ln1047">    action_t *migrate_from = NULL;</a>
<a name="ln1048">    action_t *start = NULL;</a>
<a name="ln1049">    action_t *stop = NULL;</a>
<a name="ln1050">    gboolean partial = rsc-&gt;partial_migration_target ? TRUE : FALSE;</a>
<a name="ln1051"> </a>
<a name="ln1052">    pe_rsc_trace(rsc, &quot;Processing migration actions %s moving from %s to %s . partial migration = %s&quot;,</a>
<a name="ln1053">    rsc-&gt;id, current-&gt;details-&gt;id, chosen-&gt;details-&gt;id, partial ? &quot;TRUE&quot; : &quot;FALSE&quot;);</a>
<a name="ln1054">    start = start_action(rsc, chosen, TRUE);</a>
<a name="ln1055">    stop = stop_action(rsc, current, TRUE);</a>
<a name="ln1056"> </a>
<a name="ln1057">    if (partial == FALSE) {</a>
<a name="ln1058">        migrate_to = custom_action(rsc, generate_op_key(rsc-&gt;id, RSC_MIGRATE, 0), RSC_MIGRATE, current, TRUE, TRUE, data_set);</a>
<a name="ln1059">    }</a>
<a name="ln1060"> </a>
<a name="ln1061">    migrate_from = custom_action(rsc, generate_op_key(rsc-&gt;id, RSC_MIGRATED, 0), RSC_MIGRATED, chosen, TRUE, TRUE, data_set);</a>
<a name="ln1062"> </a>
<a name="ln1063">    if ((migrate_to &amp;&amp; migrate_from) || (migrate_from &amp;&amp; partial)) {</a>
<a name="ln1064"> </a>
<a name="ln1065">        set_bit(start-&gt;flags, pe_action_migrate_runnable);</a>
<a name="ln1066">        set_bit(stop-&gt;flags, pe_action_migrate_runnable);</a>
<a name="ln1067"> </a>
<a name="ln1068">        update_action_flags(start, pe_action_pseudo, __FUNCTION__, __LINE__);       /* easier than trying to delete it from the graph */</a>
<a name="ln1069"> </a>
<a name="ln1070">        /* order probes before migrations */</a>
<a name="ln1071">        if (partial) {</a>
<a name="ln1072">            set_bit(migrate_from-&gt;flags, pe_action_migrate_runnable);</a>
<a name="ln1073">            migrate_from-&gt;needs = start-&gt;needs;</a>
<a name="ln1074"> </a>
<a name="ln1075">            custom_action_order(rsc, generate_op_key(rsc-&gt;id, RSC_STATUS, 0), NULL,</a>
<a name="ln1076">                                rsc, generate_op_key(rsc-&gt;id, RSC_MIGRATED, 0), NULL, pe_order_optional, data_set);</a>
<a name="ln1077"> </a>
<a name="ln1078">        } else {</a>
<a name="ln1079">            set_bit(migrate_from-&gt;flags, pe_action_migrate_runnable);</a>
<a name="ln1080">            set_bit(migrate_to-&gt;flags, pe_action_migrate_runnable);</a>
<a name="ln1081">            migrate_to-&gt;needs = start-&gt;needs;</a>
<a name="ln1082"> </a>
<a name="ln1083">            custom_action_order(rsc, generate_op_key(rsc-&gt;id, RSC_STATUS, 0), NULL,</a>
<a name="ln1084">                                rsc, generate_op_key(rsc-&gt;id, RSC_MIGRATE, 0), NULL, pe_order_optional, data_set);</a>
<a name="ln1085">            custom_action_order(rsc, generate_op_key(rsc-&gt;id, RSC_MIGRATE, 0), NULL,</a>
<a name="ln1086">                                rsc, generate_op_key(rsc-&gt;id, RSC_MIGRATED, 0), NULL, pe_order_optional | pe_order_implies_first_migratable, data_set);</a>
<a name="ln1087">        }</a>
<a name="ln1088"> </a>
<a name="ln1089">        custom_action_order(rsc, generate_op_key(rsc-&gt;id, RSC_MIGRATED, 0), NULL,</a>
<a name="ln1090">                            rsc, generate_op_key(rsc-&gt;id, RSC_STOP, 0), NULL, pe_order_optional | pe_order_implies_first_migratable, data_set);</a>
<a name="ln1091">        custom_action_order(rsc, generate_op_key(rsc-&gt;id, RSC_MIGRATED, 0), NULL,</a>
<a name="ln1092">                            rsc, generate_op_key(rsc-&gt;id, RSC_START, 0), NULL, pe_order_optional | pe_order_implies_first_migratable | pe_order_pseudo_left, data_set);</a>
<a name="ln1093"> </a>
<a name="ln1094">    }</a>
<a name="ln1095"> </a>
<a name="ln1096">    if (migrate_to) {</a>
<a name="ln1097">        add_hash_param(migrate_to-&gt;meta, XML_LRM_ATTR_MIGRATE_SOURCE, current-&gt;details-&gt;uname);</a>
<a name="ln1098">        add_hash_param(migrate_to-&gt;meta, XML_LRM_ATTR_MIGRATE_TARGET, chosen-&gt;details-&gt;uname);</a>
<a name="ln1099"> </a>
<a name="ln1100">        /* pcmk remote connections don't require pending to be recorded in cib.</a>
<a name="ln1101">         * We can optimize cib writes by only setting PENDING for non pcmk remote</a>
<a name="ln1102">         * connection resources */</a>
<a name="ln1103">        if (rsc-&gt;is_remote_node == FALSE) {</a>
<a name="ln1104">            /* migrate_to takes place on the source node, but can </a>
<a name="ln1105">             * have an effect on the target node depending on how</a>
<a name="ln1106">             * the agent is written. Because of this, we have to maintain</a>
<a name="ln1107">             * a record that the migrate_to occurred incase the source node </a>
<a name="ln1108">             * loses membership while the migrate_to action is still in-flight. */</a>
<a name="ln1109">            add_hash_param(migrate_to-&gt;meta, XML_OP_ATTR_PENDING, &quot;true&quot;);</a>
<a name="ln1110">        }</a>
<a name="ln1111">    }</a>
<a name="ln1112"> </a>
<a name="ln1113">    if (migrate_from) {</a>
<a name="ln1114">        add_hash_param(migrate_from-&gt;meta, XML_LRM_ATTR_MIGRATE_SOURCE, current-&gt;details-&gt;uname);</a>
<a name="ln1115">        add_hash_param(migrate_from-&gt;meta, XML_LRM_ATTR_MIGRATE_TARGET, chosen-&gt;details-&gt;uname);</a>
<a name="ln1116">    }</a>
<a name="ln1117">}</a>
<a name="ln1118"> </a>
<a name="ln1119">void</a>
<a name="ln1120">native_create_actions(resource_t * rsc, pe_working_set_t * data_set)</a>
<a name="ln1121">{</a>
<a name="ln1122">    action_t *start = NULL;</a>
<a name="ln1123">    node_t *chosen = NULL;</a>
<a name="ln1124">    node_t *current = NULL;</a>
<a name="ln1125">    gboolean need_stop = FALSE;</a>
<a name="ln1126">    gboolean is_moving = FALSE;</a>
<a name="ln1127">    gboolean allow_migrate = is_set(rsc-&gt;flags, pe_rsc_allow_migrate) ? TRUE : FALSE;</a>
<a name="ln1128"> </a>
<a name="ln1129">    GListPtr gIter = NULL;</a>
<a name="ln1130">    int num_active_nodes = 0;</a>
<a name="ln1131">    enum rsc_role_e role = RSC_ROLE_UNKNOWN;</a>
<a name="ln1132">    enum rsc_role_e next_role = RSC_ROLE_UNKNOWN;</a>
<a name="ln1133"> </a>
<a name="ln1134">    CRM_ASSERT(rsc);</a>
<a name="ln1135">    chosen = rsc-&gt;allocated_to;</a>
<a name="ln1136">    if (chosen != NULL &amp;&amp; rsc-&gt;next_role == RSC_ROLE_UNKNOWN) {</a>
<a name="ln1137">        rsc-&gt;next_role = RSC_ROLE_STARTED;</a>
<a name="ln1138">        pe_rsc_trace(rsc, &quot;Fixed next_role: unknown -&gt; %s&quot;, role2text(rsc-&gt;next_role));</a>
<a name="ln1139"> </a>
<a name="ln1140">    } else if (rsc-&gt;next_role == RSC_ROLE_UNKNOWN) {</a>
<a name="ln1141">        rsc-&gt;next_role = RSC_ROLE_STOPPED;</a>
<a name="ln1142">        pe_rsc_trace(rsc, &quot;Fixed next_role: unknown -&gt; %s&quot;, role2text(rsc-&gt;next_role));</a>
<a name="ln1143">    }</a>
<a name="ln1144"> </a>
<a name="ln1145">    pe_rsc_trace(rsc, &quot;Processing state transition for %s %p: %s-&gt;%s&quot;, rsc-&gt;id, rsc,</a>
<a name="ln1146">                 role2text(rsc-&gt;role), role2text(rsc-&gt;next_role));</a>
<a name="ln1147"> </a>
<a name="ln1148">    if (rsc-&gt;running_on) {</a>
<a name="ln1149">        current = rsc-&gt;running_on-&gt;data;</a>
<a name="ln1150">    }</a>
<a name="ln1151"> </a>
<a name="ln1152">    for (gIter = rsc-&gt;running_on; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln1153">        node_t *n = (node_t *) gIter-&gt;data;</a>
<a name="ln1154">        if (rsc-&gt;partial_migration_source &amp;&amp;</a>
<a name="ln1155">            (n-&gt;details == rsc-&gt;partial_migration_source-&gt;details)) {</a>
<a name="ln1156">            current = rsc-&gt;partial_migration_source;</a>
<a name="ln1157">        }</a>
<a name="ln1158">        num_active_nodes++;</a>
<a name="ln1159">    }</a>
<a name="ln1160"> </a>
<a name="ln1161">    for (gIter = rsc-&gt;dangling_migrations; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln1162">        node_t *current = (node_t *) gIter-&gt;data;</a>
<a name="ln1163"> </a>
<a name="ln1164">        action_t *stop = stop_action(rsc, current, FALSE);</a>
<a name="ln1165"> </a>
<a name="ln1166">        set_bit(stop-&gt;flags, pe_action_dangle);</a>
<a name="ln1167">        pe_rsc_trace(rsc, &quot;Forcing a cleanup of %s on %s&quot;, rsc-&gt;id, current-&gt;details-&gt;uname);</a>
<a name="ln1168"> </a>
<a name="ln1169">        if (is_set(data_set-&gt;flags, pe_flag_remove_after_stop)) {</a>
<a name="ln1170">            DeleteRsc(rsc, current, FALSE, data_set);</a>
<a name="ln1171">        }</a>
<a name="ln1172">    }</a>
<a name="ln1173"> </a>
<a name="ln1174">    if (num_active_nodes &gt; 1) {</a>
<a name="ln1175"> </a>
<a name="ln1176">        if (num_active_nodes == 2</a>
<a name="ln1177">            &amp;&amp; chosen</a>
<a name="ln1178">            &amp;&amp; rsc-&gt;partial_migration_target</a>
<a name="ln1179">            &amp;&amp; rsc-&gt;partial_migration_source</a>
<a name="ln1180">            &amp;&amp; (current-&gt;details == rsc-&gt;partial_migration_source-&gt;details)</a>
<a name="ln1181">            &amp;&amp; (chosen-&gt;details == rsc-&gt;partial_migration_target-&gt;details)) {</a>
<a name="ln1182">            /* Here the chosen node is still the migration target from a partial</a>
<a name="ln1183">             * migration. Attempt to continue the migration instead of recovering</a>
<a name="ln1184">             * by stopping the resource everywhere and starting it on a single node. */</a>
<a name="ln1185">            pe_rsc_trace(rsc,</a>
<a name="ln1186">                         &quot;Will attempt to continue with a partial migration to target %s from %s&quot;,</a>
<a name="ln1187">                         rsc-&gt;partial_migration_target-&gt;details-&gt;id,</a>
<a name="ln1188">                         rsc-&gt;partial_migration_source-&gt;details-&gt;id);</a>
<a name="ln1189">        } else {</a>
<a name="ln1190">            const char *type = crm_element_value(rsc-&gt;xml, XML_ATTR_TYPE);</a>
<a name="ln1191">            const char *class = crm_element_value(rsc-&gt;xml, XML_AGENT_ATTR_CLASS);</a>
<a name="ln1192"> </a>
<a name="ln1193">            if(rsc-&gt;partial_migration_target &amp;&amp; rsc-&gt;partial_migration_source) {</a>
<a name="ln1194">                crm_notice(&quot;Resource %s can no longer migrate to %s. Stopping on %s too&quot;, rsc-&gt;id,</a>
<a name="ln1195">                           rsc-&gt;partial_migration_target-&gt;details-&gt;uname,</a>
<a name="ln1196">                           rsc-&gt;partial_migration_source-&gt;details-&gt;uname);</a>
<a name="ln1197"> </a>
<a name="ln1198">            } else {</a>
<a name="ln1199">                pe_proc_err(&quot;Resource %s (%s::%s) is active on %d nodes %s&quot;,</a>
<a name="ln1200">                            rsc-&gt;id, class, type, num_active_nodes, recovery2text(rsc-&gt;recovery_type));</a>
<a name="ln1201">                crm_warn(&quot;See %s for more information.&quot;,</a>
<a name="ln1202">                         &quot;http://clusterlabs.org/wiki/FAQ#Resource_is_Too_Active&quot;);</a>
<a name="ln1203">            }</a>
<a name="ln1204"> </a>
<a name="ln1205">            if (rsc-&gt;recovery_type == recovery_stop_start) {</a>
<a name="ln1206">                need_stop = TRUE;</a>
<a name="ln1207">            }</a>
<a name="ln1208"> </a>
<a name="ln1209">            /* If by chance a partial migration is in process,</a>
<a name="ln1210">             * but the migration target is not chosen still, clear all</a>
<a name="ln1211">             * partial migration data.  */</a>
<a name="ln1212">            rsc-&gt;partial_migration_source = rsc-&gt;partial_migration_target = NULL;</a>
<a name="ln1213">            allow_migrate = FALSE;</a>
<a name="ln1214">        }</a>
<a name="ln1215">    }</a>
<a name="ln1216"> </a>
<a name="ln1217">    if (is_set(rsc-&gt;flags, pe_rsc_start_pending)) {</a>
<a name="ln1218">        start = start_action(rsc, chosen, TRUE);</a>
<a name="ln1219">        set_bit(start-&gt;flags, pe_action_print_always);</a>
<a name="ln1220">    }</a>
<a name="ln1221"> </a>
<a name="ln1222">    if (current &amp;&amp; chosen &amp;&amp; current-&gt;details != chosen-&gt;details) {</a>
<a name="ln1223">        pe_rsc_trace(rsc, &quot;Moving %s&quot;, rsc-&gt;id);</a>
<a name="ln1224">        is_moving = TRUE;</a>
<a name="ln1225">        need_stop = TRUE;</a>
<a name="ln1226"> </a>
<a name="ln1227">    } else if (is_set(rsc-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln1228">        pe_rsc_trace(rsc, &quot;Recovering %s&quot;, rsc-&gt;id);</a>
<a name="ln1229">        need_stop = TRUE;</a>
<a name="ln1230"> </a>
<a name="ln1231">    } else if (is_set(rsc-&gt;flags, pe_rsc_block)) {</a>
<a name="ln1232">        pe_rsc_trace(rsc, &quot;Block %s&quot;, rsc-&gt;id);</a>
<a name="ln1233">        need_stop = TRUE;</a>
<a name="ln1234"> </a>
<a name="ln1235">    } else if (rsc-&gt;role &gt; RSC_ROLE_STARTED &amp;&amp; current != NULL &amp;&amp; chosen != NULL) {</a>
<a name="ln1236">        /* Recovery of a promoted resource */</a>
<a name="ln1237">        start = start_action(rsc, chosen, TRUE);</a>
<a name="ln1238">        if (is_set(start-&gt;flags, pe_action_optional) == FALSE) {</a>
<a name="ln1239">            pe_rsc_trace(rsc, &quot;Forced start %s&quot;, rsc-&gt;id);</a>
<a name="ln1240">            need_stop = TRUE;</a>
<a name="ln1241">        }</a>
<a name="ln1242">    }</a>
<a name="ln1243"> </a>
<a name="ln1244">    pe_rsc_trace(rsc, &quot;Creating actions for %s: %s-&gt;%s&quot;, rsc-&gt;id,</a>
<a name="ln1245">                 role2text(rsc-&gt;role), role2text(rsc-&gt;next_role));</a>
<a name="ln1246"> </a>
<a name="ln1247">    /* Create any additional actions required when bringing resource down and</a>
<a name="ln1248">     * back up to same level.</a>
<a name="ln1249">     */</a>
<a name="ln1250">    role = rsc-&gt;role;</a>
<a name="ln1251">    while (role != RSC_ROLE_STOPPED) {</a>
<a name="ln1252">        next_role = rsc_state_matrix[role][RSC_ROLE_STOPPED];</a>
<a name="ln1253">        pe_rsc_trace(rsc, &quot;Down: Executing: %s-&gt;%s (%s)%s&quot;, role2text(role), role2text(next_role),</a>
<a name="ln1254">                     rsc-&gt;id, need_stop ? &quot; required&quot; : &quot;&quot;);</a>
<a name="ln1255">        if (rsc_action_matrix[role][next_role] (rsc, current, !need_stop, data_set) == FALSE) {</a>
<a name="ln1256">            break;</a>
<a name="ln1257">        }</a>
<a name="ln1258">        role = next_role;</a>
<a name="ln1259">    }</a>
<a name="ln1260"> </a>
<a name="ln1261"> </a>
<a name="ln1262">    while (rsc-&gt;role &lt;= rsc-&gt;next_role &amp;&amp; role != rsc-&gt;role &amp;&amp; is_not_set(rsc-&gt;flags, pe_rsc_block)) {</a>
<a name="ln1263">        next_role = rsc_state_matrix[role][rsc-&gt;role];</a>
<a name="ln1264">        pe_rsc_trace(rsc, &quot;Up:   Executing: %s-&gt;%s (%s)%s&quot;, role2text(role), role2text(next_role),</a>
<a name="ln1265">                     rsc-&gt;id, need_stop ? &quot; required&quot; : &quot;&quot;);</a>
<a name="ln1266">        if (rsc_action_matrix[role][next_role] (rsc, chosen, !need_stop, data_set) == FALSE) {</a>
<a name="ln1267">            break;</a>
<a name="ln1268">        }</a>
<a name="ln1269">        role = next_role;</a>
<a name="ln1270">    }</a>
<a name="ln1271">    role = rsc-&gt;role;</a>
<a name="ln1272"> </a>
<a name="ln1273">    /* Required steps from this role to the next */</a>
<a name="ln1274">    while (role != rsc-&gt;next_role) {</a>
<a name="ln1275">        next_role = rsc_state_matrix[role][rsc-&gt;next_role];</a>
<a name="ln1276">        pe_rsc_trace(rsc, &quot;Role: Executing: %s-&gt;%s = (%s on %s)&quot;, role2text(role), role2text(next_role), rsc-&gt;id, chosen?chosen-&gt;details-&gt;uname:&quot;NA&quot;);</a>
<a name="ln1277">        if (rsc_action_matrix[role][next_role] (rsc, chosen, FALSE, data_set) == FALSE) {</a>
<a name="ln1278">            break;</a>
<a name="ln1279">        }</a>
<a name="ln1280">        role = next_role;</a>
<a name="ln1281">    }</a>
<a name="ln1282"> </a>
<a name="ln1283">    if(is_set(rsc-&gt;flags, pe_rsc_block)) {</a>
<a name="ln1284">        pe_rsc_trace(rsc, &quot;No monitor additional ops for blocked resource&quot;);</a>
<a name="ln1285"> </a>
<a name="ln1286">    } else if (rsc-&gt;next_role != RSC_ROLE_STOPPED || is_set(rsc-&gt;flags, pe_rsc_managed) == FALSE) {</a>
<a name="ln1287">        pe_rsc_trace(rsc, &quot;Monitor ops for active resource&quot;);</a>
<a name="ln1288">        start = start_action(rsc, chosen, TRUE);</a>
<a name="ln1289">        Recurring(rsc, start, chosen, data_set);</a>
<a name="ln1290">        Recurring_Stopped(rsc, start, chosen, data_set);</a>
<a name="ln1291">    } else {</a>
<a name="ln1292">        pe_rsc_trace(rsc, &quot;Monitor ops for in-active resource&quot;);</a>
<a name="ln1293">        Recurring_Stopped(rsc, NULL, NULL, data_set);</a>
<a name="ln1294">    }</a>
<a name="ln1295"> </a>
<a name="ln1296">    /* if we are stuck in a partial migration, where the target</a>
<a name="ln1297">     * of the partial migration no longer matches the chosen target.</a>
<a name="ln1298">     * A full stop/start is required */</a>
<a name="ln1299">    if (rsc-&gt;partial_migration_target &amp;&amp; (chosen == NULL || rsc-&gt;partial_migration_target-&gt;details != chosen-&gt;details)) {</a>
<a name="ln1300">        pe_rsc_trace(rsc, &quot;Not allowing partial migration to continue. %s&quot;, rsc-&gt;id);</a>
<a name="ln1301">        allow_migrate = FALSE;</a>
<a name="ln1302"> </a>
<a name="ln1303">    } else if (is_moving == FALSE ||</a>
<a name="ln1304">               is_not_set(rsc-&gt;flags, pe_rsc_managed) ||</a>
<a name="ln1305">               is_set(rsc-&gt;flags, pe_rsc_failed) ||</a>
<a name="ln1306">               is_set(rsc-&gt;flags, pe_rsc_start_pending) ||</a>
<a name="ln1307">               (current-&gt;details-&gt;unclean == TRUE) ||</a>
<a name="ln1308">               rsc-&gt;next_role &lt; RSC_ROLE_STARTED) {</a>
<a name="ln1309"> </a>
<a name="ln1310">        allow_migrate = FALSE;</a>
<a name="ln1311">    }</a>
<a name="ln1312"> </a>
<a name="ln1313">    if (allow_migrate) {</a>
<a name="ln1314">        handle_migration_actions(rsc, current, chosen, data_set);</a>
<a name="ln1315">    }</a>
<a name="ln1316">}</a>
<a name="ln1317"> </a>
<a name="ln1318">static void</a>
<a name="ln1319">rsc_avoids_remote_nodes(resource_t *rsc)</a>
<a name="ln1320">{</a>
<a name="ln1321">    GHashTableIter iter;</a>
<a name="ln1322">    node_t *node = NULL;</a>
<a name="ln1323">    g_hash_table_iter_init(&amp;iter, rsc-&gt;allowed_nodes);</a>
<a name="ln1324">    while (g_hash_table_iter_next(&amp;iter, NULL, (void **)&amp;node)) {</a>
<a name="ln1325">        if (node-&gt;details-&gt;remote_rsc) {</a>
<a name="ln1326">            node-&gt;weight = -INFINITY;</a>
<a name="ln1327">        }</a>
<a name="ln1328">    }</a>
<a name="ln1329">}</a>
<a name="ln1330"> </a>
<a name="ln1331">void</a>
<a name="ln1332">native_internal_constraints(resource_t * rsc, pe_working_set_t * data_set)</a>
<a name="ln1333">{</a>
<a name="ln1334">    /* This function is on the critical path and worth optimizing as much as possible */</a>
<a name="ln1335"> </a>
<a name="ln1336">    resource_t *top = uber_parent(rsc);</a>
<a name="ln1337">    int type = pe_order_optional | pe_order_implies_then | pe_order_restart;</a>
<a name="ln1338">    gboolean is_stonith = is_set(rsc-&gt;flags, pe_rsc_fence_device);</a>
<a name="ln1339"> </a>
<a name="ln1340">    custom_action_order(rsc, generate_op_key(rsc-&gt;id, RSC_STOP, 0), NULL,</a>
<a name="ln1341">                        rsc, generate_op_key(rsc-&gt;id, RSC_START, 0), NULL, type, data_set);</a>
<a name="ln1342"> </a>
<a name="ln1343">    if (top-&gt;variant == pe_master || rsc-&gt;role &gt; RSC_ROLE_SLAVE) {</a>
<a name="ln1344">        custom_action_order(rsc, generate_op_key(rsc-&gt;id, RSC_DEMOTE, 0), NULL,</a>
<a name="ln1345">                            rsc, generate_op_key(rsc-&gt;id, RSC_STOP, 0), NULL,</a>
<a name="ln1346">                            pe_order_implies_first_master, data_set);</a>
<a name="ln1347"> </a>
<a name="ln1348">        custom_action_order(rsc, generate_op_key(rsc-&gt;id, RSC_START, 0), NULL,</a>
<a name="ln1349">                            rsc, generate_op_key(rsc-&gt;id, RSC_PROMOTE, 0), NULL,</a>
<a name="ln1350">                            pe_order_runnable_left, data_set);</a>
<a name="ln1351">    }</a>
<a name="ln1352"> </a>
<a name="ln1353">    if (is_stonith == FALSE</a>
<a name="ln1354">        &amp;&amp; is_set(data_set-&gt;flags, pe_flag_enable_unfencing)</a>
<a name="ln1355">        &amp;&amp; is_set(rsc-&gt;flags, pe_rsc_needs_unfencing)) {</a>
<a name="ln1356">        /* Check if the node needs to be unfenced first */</a>
<a name="ln1357">        node_t *node = NULL;</a>
<a name="ln1358">        GHashTableIter iter;</a>
<a name="ln1359"> </a>
<a name="ln1360">        g_hash_table_iter_init(&amp;iter, rsc-&gt;allowed_nodes);</a>
<a name="ln1361">        while (g_hash_table_iter_next(&amp;iter, NULL, (void **)&amp;node)) {</a>
<a name="ln1362">            action_t *unfence = pe_fence_op(node, &quot;on&quot;, TRUE, data_set);</a>
<a name="ln1363"> </a>
<a name="ln1364">            crm_debug(&quot;Ordering any stops of %s before %s, and any starts after&quot;,</a>
<a name="ln1365">                      rsc-&gt;id, unfence-&gt;uuid);</a>
<a name="ln1366"> </a>
<a name="ln1367">            /*</a>
<a name="ln1368">             * It would be more efficient to order clone resources once,</a>
<a name="ln1369">             * rather than order each instance, but ordering the instance</a>
<a name="ln1370">             * allows us to avoid unnecessary dependencies that might conflict</a>
<a name="ln1371">             * with user constraints.</a>
<a name="ln1372">             *</a>
<a name="ln1373">             * @TODO: This constraint can still produce a transition loop if the</a>
<a name="ln1374">             * resource has a stop scheduled on the node being unfenced, and</a>
<a name="ln1375">             * there is a user ordering constraint to start some other resource</a>
<a name="ln1376">             * (which will be ordered after the unfence) before stopping this</a>
<a name="ln1377">             * resource. An example is &quot;start some slow-starting cloned service</a>
<a name="ln1378">             * before stopping an associated virtual IP that may be moving to</a>
<a name="ln1379">             * it&quot;:</a>
<a name="ln1380">             *       stop this -&gt; unfencing -&gt; start that -&gt; stop this</a>
<a name="ln1381">             */</a>
<a name="ln1382">            custom_action_order(rsc, stop_key(rsc), NULL,</a>
<a name="ln1383">                                NULL, strdup(unfence-&gt;uuid), unfence,</a>
<a name="ln1384">                                pe_order_optional|pe_order_same_node, data_set);</a>
<a name="ln1385"> </a>
<a name="ln1386">            custom_action_order(NULL, strdup(unfence-&gt;uuid), unfence,</a>
<a name="ln1387">                                rsc, start_key(rsc), NULL,</a>
<a name="ln1388">                                pe_order_implies_then_on_node|pe_order_same_node,</a>
<a name="ln1389">                                data_set);</a>
<a name="ln1390">        }</a>
<a name="ln1391">    }</a>
<a name="ln1392"> </a>
<a name="ln1393">    if (is_not_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln1394">        pe_rsc_trace(rsc, &quot;Skipping fencing constraints for unmanaged resource: %s&quot;, rsc-&gt;id);</a>
<a name="ln1395">        return;</a>
<a name="ln1396">    }</a>
<a name="ln1397"> </a>
<a name="ln1398">    {</a>
<a name="ln1399">        action_t *all_stopped = get_pseudo_op(ALL_STOPPED, data_set);</a>
<a name="ln1400"> </a>
<a name="ln1401">        custom_action_order(rsc, stop_key(rsc), NULL,</a>
<a name="ln1402">                            NULL, strdup(all_stopped-&gt;task), all_stopped,</a>
<a name="ln1403">                            pe_order_implies_then | pe_order_runnable_left, data_set);</a>
<a name="ln1404">    }</a>
<a name="ln1405"> </a>
<a name="ln1406">    if (g_hash_table_size(rsc-&gt;utilization) &gt; 0</a>
<a name="ln1407">        &amp;&amp; safe_str_neq(data_set-&gt;placement_strategy, &quot;default&quot;)) {</a>
<a name="ln1408">        GHashTableIter iter;</a>
<a name="ln1409">        node_t *next = NULL;</a>
<a name="ln1410">        GListPtr gIter = NULL;</a>
<a name="ln1411"> </a>
<a name="ln1412">        pe_rsc_trace(rsc, &quot;Creating utilization constraints for %s - strategy: %s&quot;,</a>
<a name="ln1413">                     rsc-&gt;id, data_set-&gt;placement_strategy);</a>
<a name="ln1414"> </a>
<a name="ln1415">        for (gIter = rsc-&gt;running_on; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln1416">            node_t *current = (node_t *) gIter-&gt;data;</a>
<a name="ln1417"> </a>
<a name="ln1418">            char *load_stopped_task = crm_concat(LOAD_STOPPED, current-&gt;details-&gt;uname, '_');</a>
<a name="ln1419">            action_t *load_stopped = get_pseudo_op(load_stopped_task, data_set);</a>
<a name="ln1420"> </a>
<a name="ln1421">            if (load_stopped-&gt;node == NULL) {</a>
<a name="ln1422">                load_stopped-&gt;node = node_copy(current);</a>
<a name="ln1423">                update_action_flags(load_stopped, pe_action_optional | pe_action_clear, __FUNCTION__, __LINE__);</a>
<a name="ln1424">            }</a>
<a name="ln1425"> </a>
<a name="ln1426">            custom_action_order(rsc, stop_key(rsc), NULL,</a>
<a name="ln1427">                                NULL, load_stopped_task, load_stopped, pe_order_load, data_set);</a>
<a name="ln1428">        }</a>
<a name="ln1429"> </a>
<a name="ln1430">        g_hash_table_iter_init(&amp;iter, rsc-&gt;allowed_nodes);</a>
<a name="ln1431">        while (g_hash_table_iter_next(&amp;iter, NULL, (void **)&amp;next)) {</a>
<a name="ln1432">            char *load_stopped_task = crm_concat(LOAD_STOPPED, next-&gt;details-&gt;uname, '_');</a>
<a name="ln1433">            action_t *load_stopped = get_pseudo_op(load_stopped_task, data_set);</a>
<a name="ln1434"> </a>
<a name="ln1435">            if (load_stopped-&gt;node == NULL) {</a>
<a name="ln1436">                load_stopped-&gt;node = node_copy(next);</a>
<a name="ln1437">                update_action_flags(load_stopped, pe_action_optional | pe_action_clear, __FUNCTION__, __LINE__);</a>
<a name="ln1438">            }</a>
<a name="ln1439"> </a>
<a name="ln1440">            custom_action_order(NULL, strdup(load_stopped_task), load_stopped,</a>
<a name="ln1441">                                rsc, start_key(rsc), NULL, pe_order_load, data_set);</a>
<a name="ln1442"> </a>
<a name="ln1443">            custom_action_order(NULL, strdup(load_stopped_task), load_stopped,</a>
<a name="ln1444">                                rsc, generate_op_key(rsc-&gt;id, RSC_MIGRATE, 0), NULL,</a>
<a name="ln1445">                                pe_order_load, data_set);</a>
<a name="ln1446"> </a>
<a name="ln1447">            free(load_stopped_task);</a>
<a name="ln1448">        }</a>
<a name="ln1449">    }</a>
<a name="ln1450"> </a>
<a name="ln1451">    if (rsc-&gt;container) {</a>
<a name="ln1452">        resource_t *remote_rsc = NULL;</a>
<a name="ln1453"> </a>
<a name="ln1454">        /* find out if the container is associated with remote node connection resource */</a>
<a name="ln1455">        if (rsc-&gt;container-&gt;is_remote_node) {</a>
<a name="ln1456">            remote_rsc = rsc-&gt;container;</a>
<a name="ln1457">        } else if (rsc-&gt;is_remote_node == FALSE) {</a>
<a name="ln1458">            remote_rsc = rsc_contains_remote_node(data_set, rsc-&gt;container);</a>
<a name="ln1459">        }</a>
<a name="ln1460"> </a>
<a name="ln1461">        /* if the container is a remote-node, force the resource within the container</a>
<a name="ln1462">         * instead of colocating the resource with the container. */</a>
<a name="ln1463">        if (remote_rsc) {</a>
<a name="ln1464">            GHashTableIter iter;</a>
<a name="ln1465">            node_t *node = NULL;</a>
<a name="ln1466">            g_hash_table_iter_init(&amp;iter, rsc-&gt;allowed_nodes);</a>
<a name="ln1467">            while (g_hash_table_iter_next(&amp;iter, NULL, (void **)&amp;node)) {</a>
<a name="ln1468">                if (node-&gt;details-&gt;remote_rsc != remote_rsc) {</a>
<a name="ln1469">                    node-&gt;weight = -INFINITY;</a>
<a name="ln1470">                }</a>
<a name="ln1471">            }</a>
<a name="ln1472">        } else {</a>
<a name="ln1473">            int score = 10000; /* Highly preferred but not essential */</a>
<a name="ln1474">            crm_trace(&quot;Generating order and colocation rules for rsc %s with container %s&quot;, rsc-&gt;id, rsc-&gt;container-&gt;id);</a>
<a name="ln1475">            custom_action_order(rsc-&gt;container, generate_op_key(rsc-&gt;container-&gt;id, RSC_START, 0), NULL,</a>
<a name="ln1476">                                rsc, generate_op_key(rsc-&gt;id, RSC_START, 0), NULL,</a>
<a name="ln1477">                                pe_order_implies_then | pe_order_runnable_left, data_set);</a>
<a name="ln1478"> </a>
<a name="ln1479">            custom_action_order(rsc, generate_op_key(rsc-&gt;id, RSC_STOP, 0), NULL,</a>
<a name="ln1480">                                rsc-&gt;container, generate_op_key(rsc-&gt;container-&gt;id, RSC_STOP, 0), NULL,</a>
<a name="ln1481">                                pe_order_implies_first, data_set);</a>
<a name="ln1482"> </a>
<a name="ln1483">            if(is_not_set(rsc-&gt;flags, pe_rsc_allow_remote_remotes)) {</a>
<a name="ln1484">                score = INFINITY; /* Force them to run on the same host */ </a>
<a name="ln1485">            }</a>
<a name="ln1486">            rsc_colocation_new(&quot;resource-with-container&quot;, NULL, score, rsc, rsc-&gt;container, NULL,</a>
<a name="ln1487">                               NULL, data_set);</a>
<a name="ln1488">        }</a>
<a name="ln1489">    }</a>
<a name="ln1490"> </a>
<a name="ln1491">    if (rsc-&gt;is_remote_node || is_stonith) {</a>
<a name="ln1492">        /* don't allow remote nodes to run stonith devices</a>
<a name="ln1493">         * or remote connection resources.*/</a>
<a name="ln1494">        rsc_avoids_remote_nodes(rsc);</a>
<a name="ln1495">    }</a>
<a name="ln1496"> </a>
<a name="ln1497">    /* If this rsc is a remote connection resource associated</a>
<a name="ln1498">     * with a container ( which will most likely be a virtual guest )</a>
<a name="ln1499">     * do not allow the container to live on any remote-nodes.</a>
<a name="ln1500">     * remote-nodes managing nested remote-nodes should not be allowed. */</a>
<a name="ln1501">    if (rsc-&gt;is_remote_node &amp;&amp; rsc-&gt;container) {</a>
<a name="ln1502">        rsc_avoids_remote_nodes(rsc-&gt;container);</a>
<a name="ln1503">    }</a>
<a name="ln1504">}</a>
<a name="ln1505"> </a>
<a name="ln1506">void</a>
<a name="ln1507">native_rsc_colocation_lh(resource_t * rsc_lh, resource_t * rsc_rh, rsc_colocation_t * constraint)</a>
<a name="ln1508">{</a>
<a name="ln1509">    if (rsc_lh == NULL) {</a>
<a name="ln1510">        pe_err(&quot;rsc_lh was NULL for %s&quot;, constraint-&gt;id);</a>
<a name="ln1511">        return;</a>
<a name="ln1512"> </a>
<a name="ln1513">    } else if (constraint-&gt;rsc_rh == NULL) {</a>
<a name="ln1514">        pe_err(&quot;rsc_rh was NULL for %s&quot;, constraint-&gt;id);</a>
<a name="ln1515">        return;</a>
<a name="ln1516">    }</a>
<a name="ln1517"> </a>
<a name="ln1518">    pe_rsc_trace(rsc_lh, &quot;Processing colocation constraint between %s and %s&quot;, rsc_lh-&gt;id,</a>
<a name="ln1519">                 rsc_rh-&gt;id);</a>
<a name="ln1520"> </a>
<a name="ln1521">    rsc_rh-&gt;cmds-&gt;rsc_colocation_rh(rsc_lh, rsc_rh, constraint);</a>
<a name="ln1522">}</a>
<a name="ln1523"> </a>
<a name="ln1524">enum filter_colocation_res</a>
<a name="ln1525">filter_colocation_constraint(resource_t * rsc_lh, resource_t * rsc_rh,</a>
<a name="ln1526">                             rsc_colocation_t * constraint, gboolean preview)</a>
<a name="ln1527">{</a>
<a name="ln1528">    if (constraint-&gt;score == 0) {</a>
<a name="ln1529">        return influence_nothing;</a>
<a name="ln1530">    }</a>
<a name="ln1531"> </a>
<a name="ln1532">    /* rh side must be allocated before we can process constraint */</a>
<a name="ln1533">    if (preview == FALSE &amp;&amp; is_set(rsc_rh-&gt;flags, pe_rsc_provisional)) {</a>
<a name="ln1534">        return influence_nothing;</a>
<a name="ln1535">    }</a>
<a name="ln1536"> </a>
<a name="ln1537">    if ((constraint-&gt;role_lh &gt;= RSC_ROLE_SLAVE) &amp;&amp;</a>
<a name="ln1538">        rsc_lh-&gt;parent &amp;&amp;</a>
<a name="ln1539">        rsc_lh-&gt;parent-&gt;variant == pe_master &amp;&amp; is_not_set(rsc_lh-&gt;flags, pe_rsc_provisional)) {</a>
<a name="ln1540"> </a>
<a name="ln1541">        /* LH and RH resources have already been allocated, place the correct</a>
<a name="ln1542">         * priority oh LH rsc for the given multistate resource role */</a>
<a name="ln1543">        return influence_rsc_priority;</a>
<a name="ln1544">    }</a>
<a name="ln1545"> </a>
<a name="ln1546">    if (preview == FALSE &amp;&amp; is_not_set(rsc_lh-&gt;flags, pe_rsc_provisional)) {</a>
<a name="ln1547">        /* error check */</a>
<a name="ln1548">        struct node_shared_s *details_lh;</a>
<a name="ln1549">        struct node_shared_s *details_rh;</a>
<a name="ln1550"> </a>
<a name="ln1551">        if ((constraint-&gt;score &gt; -INFINITY) &amp;&amp; (constraint-&gt;score &lt; INFINITY)) {</a>
<a name="ln1552">            return influence_nothing;</a>
<a name="ln1553">        }</a>
<a name="ln1554"> </a>
<a name="ln1555">        details_rh = rsc_rh-&gt;allocated_to ? rsc_rh-&gt;allocated_to-&gt;details : NULL;</a>
<a name="ln1556">        details_lh = rsc_lh-&gt;allocated_to ? rsc_lh-&gt;allocated_to-&gt;details : NULL;</a>
<a name="ln1557"> </a>
<a name="ln1558">        if (constraint-&gt;score == INFINITY &amp;&amp; details_lh != details_rh) {</a>
<a name="ln1559">            crm_err(&quot;%s and %s are both allocated&quot;</a>
<a name="ln1560">                    &quot; but to different nodes: %s vs. %s&quot;,</a>
<a name="ln1561">                    rsc_lh-&gt;id, rsc_rh-&gt;id,</a>
<a name="ln1562">                    details_lh ? details_lh-&gt;uname : &quot;n/a&quot;, details_rh ? details_rh-&gt;uname : &quot;n/a&quot;);</a>
<a name="ln1563"> </a>
<a name="ln1564">        } else if (constraint-&gt;score == -INFINITY &amp;&amp; details_lh == details_rh) {</a>
<a name="ln1565">            crm_err(&quot;%s and %s are both allocated&quot;</a>
<a name="ln1566">                    &quot; but to the SAME node: %s&quot;,</a>
<a name="ln1567">                    rsc_lh-&gt;id, rsc_rh-&gt;id, details_rh ? details_rh-&gt;uname : &quot;n/a&quot;);</a>
<a name="ln1568">        }</a>
<a name="ln1569"> </a>
<a name="ln1570">        return influence_nothing;</a>
<a name="ln1571">    }</a>
<a name="ln1572"> </a>
<a name="ln1573">    if (constraint-&gt;score &gt; 0</a>
<a name="ln1574">        &amp;&amp; constraint-&gt;role_lh != RSC_ROLE_UNKNOWN &amp;&amp; constraint-&gt;role_lh != rsc_lh-&gt;next_role) {</a>
<a name="ln1575">        crm_trace(&quot;LH: Skipping constraint: \&quot;%s\&quot; state filter nextrole is %s&quot;,</a>
<a name="ln1576">                  role2text(constraint-&gt;role_lh), role2text(rsc_lh-&gt;next_role));</a>
<a name="ln1577">        return influence_nothing;</a>
<a name="ln1578">    }</a>
<a name="ln1579"> </a>
<a name="ln1580">    if (constraint-&gt;score &gt; 0</a>
<a name="ln1581">        &amp;&amp; constraint-&gt;role_rh != RSC_ROLE_UNKNOWN &amp;&amp; constraint-&gt;role_rh != rsc_rh-&gt;next_role) {</a>
<a name="ln1582">        crm_trace(&quot;RH: Skipping constraint: \&quot;%s\&quot; state filter&quot;, role2text(constraint-&gt;role_rh));</a>
<a name="ln1583">        return FALSE;</a>
<a name="ln1584">    }</a>
<a name="ln1585"> </a>
<a name="ln1586">    if (constraint-&gt;score &lt; 0</a>
<a name="ln1587">        &amp;&amp; constraint-&gt;role_lh != RSC_ROLE_UNKNOWN &amp;&amp; constraint-&gt;role_lh == rsc_lh-&gt;next_role) {</a>
<a name="ln1588">        crm_trace(&quot;LH: Skipping -ve constraint: \&quot;%s\&quot; state filter&quot;,</a>
<a name="ln1589">                  role2text(constraint-&gt;role_lh));</a>
<a name="ln1590">        return influence_nothing;</a>
<a name="ln1591">    }</a>
<a name="ln1592"> </a>
<a name="ln1593">    if (constraint-&gt;score &lt; 0</a>
<a name="ln1594">        &amp;&amp; constraint-&gt;role_rh != RSC_ROLE_UNKNOWN &amp;&amp; constraint-&gt;role_rh == rsc_rh-&gt;next_role) {</a>
<a name="ln1595">        crm_trace(&quot;RH: Skipping -ve constraint: \&quot;%s\&quot; state filter&quot;,</a>
<a name="ln1596">                  role2text(constraint-&gt;role_rh));</a>
<a name="ln1597">        return influence_nothing;</a>
<a name="ln1598">    }</a>
<a name="ln1599"> </a>
<a name="ln1600">    return influence_rsc_location;</a>
<a name="ln1601">}</a>
<a name="ln1602"> </a>
<a name="ln1603">static void</a>
<a name="ln1604">influence_priority(resource_t * rsc_lh, resource_t * rsc_rh, rsc_colocation_t * constraint)</a>
<a name="ln1605">{</a>
<a name="ln1606">    const char *rh_value = NULL;</a>
<a name="ln1607">    const char *lh_value = NULL;</a>
<a name="ln1608">    const char *attribute = &quot;#id&quot;;</a>
<a name="ln1609">    int score_multiplier = 1;</a>
<a name="ln1610"> </a>
<a name="ln1611">    if (constraint-&gt;node_attribute != NULL) {</a>
<a name="ln1612">        attribute = constraint-&gt;node_attribute;</a>
<a name="ln1613">    }</a>
<a name="ln1614"> </a>
<a name="ln1615">    if (!rsc_rh-&gt;allocated_to || !rsc_lh-&gt;allocated_to) {</a>
<a name="ln1616">        return;</a>
<a name="ln1617">    }</a>
<a name="ln1618"> </a>
<a name="ln1619">    lh_value = g_hash_table_lookup(rsc_lh-&gt;allocated_to-&gt;details-&gt;attrs, attribute);</a>
<a name="ln1620">    rh_value = g_hash_table_lookup(rsc_rh-&gt;allocated_to-&gt;details-&gt;attrs, attribute);</a>
<a name="ln1621"> </a>
<a name="ln1622">    if (!safe_str_eq(lh_value, rh_value)) {</a>
<a name="ln1623">        if(constraint-&gt;score == INFINITY &amp;&amp; constraint-&gt;role_lh == RSC_ROLE_MASTER) {</a>
<a name="ln1624">            rsc_lh-&gt;priority = -INFINITY;</a>
<a name="ln1625">        }</a>
<a name="ln1626">        return;</a>
<a name="ln1627">    }</a>
<a name="ln1628"> </a>
<a name="ln1629">    if (constraint-&gt;role_rh &amp;&amp; (constraint-&gt;role_rh != rsc_rh-&gt;next_role)) {</a>
<a name="ln1630">        return;</a>
<a name="ln1631">    }</a>
<a name="ln1632"> </a>
<a name="ln1633">    if (constraint-&gt;role_lh == RSC_ROLE_SLAVE) {</a>
<a name="ln1634">        score_multiplier = -1;</a>
<a name="ln1635">    }</a>
<a name="ln1636"> </a>
<a name="ln1637">    rsc_lh-&gt;priority = merge_weights(score_multiplier * constraint-&gt;score, rsc_lh-&gt;priority);</a>
<a name="ln1638">}</a>
<a name="ln1639"> </a>
<a name="ln1640">static void</a>
<a name="ln1641">colocation_match(resource_t * rsc_lh, resource_t * rsc_rh, rsc_colocation_t * constraint)</a>
<a name="ln1642">{</a>
<a name="ln1643">    const char *tmp = NULL;</a>
<a name="ln1644">    const char *value = NULL;</a>
<a name="ln1645">    const char *attribute = &quot;#id&quot;;</a>
<a name="ln1646"> </a>
<a name="ln1647">    GHashTable *work = NULL;</a>
<a name="ln1648">    gboolean do_check = FALSE;</a>
<a name="ln1649"> </a>
<a name="ln1650">    GHashTableIter iter;</a>
<a name="ln1651">    node_t *node = NULL;</a>
<a name="ln1652"> </a>
<a name="ln1653">    if (constraint-&gt;node_attribute != NULL) {</a>
<a name="ln1654">        attribute = constraint-&gt;node_attribute;</a>
<a name="ln1655">    }</a>
<a name="ln1656"> </a>
<a name="ln1657">    if (rsc_rh-&gt;allocated_to) {</a>
<a name="ln1658">        value = g_hash_table_lookup(rsc_rh-&gt;allocated_to-&gt;details-&gt;attrs, attribute);</a>
<a name="ln1659">        do_check = TRUE;</a>
<a name="ln1660"> </a>
<a name="ln1661">    } else if (constraint-&gt;score &lt; 0) {</a>
<a name="ln1662">        /* nothing to do:</a>
<a name="ln1663">         *   anti-colocation with something that is not running</a>
<a name="ln1664">         */</a>
<a name="ln1665">        return;</a>
<a name="ln1666">    }</a>
<a name="ln1667"> </a>
<a name="ln1668">    work = node_hash_dup(rsc_lh-&gt;allowed_nodes);</a>
<a name="ln1669"> </a>
<a name="ln1670">    g_hash_table_iter_init(&amp;iter, work);</a>
<a name="ln1671">    while (g_hash_table_iter_next(&amp;iter, NULL, (void **)&amp;node)) {</a>
<a name="ln1672">        tmp = g_hash_table_lookup(node-&gt;details-&gt;attrs, attribute);</a>
<a name="ln1673">        if (do_check &amp;&amp; safe_str_eq(tmp, value)) {</a>
<a name="ln1674">            if (constraint-&gt;score &lt; INFINITY) {</a>
<a name="ln1675">                pe_rsc_trace(rsc_lh, &quot;%s: %s.%s += %d&quot;, constraint-&gt;id, rsc_lh-&gt;id,</a>
<a name="ln1676">                             node-&gt;details-&gt;uname, constraint-&gt;score);</a>
<a name="ln1677">                node-&gt;weight = merge_weights(constraint-&gt;score, node-&gt;weight);</a>
<a name="ln1678">            }</a>
<a name="ln1679"> </a>
<a name="ln1680">        } else if (do_check == FALSE || constraint-&gt;score &gt;= INFINITY) {</a>
<a name="ln1681">            pe_rsc_trace(rsc_lh, &quot;%s: %s.%s -= %d (%s)&quot;, constraint-&gt;id, rsc_lh-&gt;id,</a>
<a name="ln1682">                         node-&gt;details-&gt;uname, constraint-&gt;score,</a>
<a name="ln1683">                         do_check ? &quot;failed&quot; : &quot;unallocated&quot;);</a>
<a name="ln1684">            node-&gt;weight = merge_weights(-constraint-&gt;score, node-&gt;weight);</a>
<a name="ln1685">        }</a>
<a name="ln1686">    }</a>
<a name="ln1687"> </a>
<a name="ln1688">    if (can_run_any(work)</a>
<a name="ln1689">        || constraint-&gt;score &lt;= -INFINITY || constraint-&gt;score &gt;= INFINITY) {</a>
<a name="ln1690">        g_hash_table_destroy(rsc_lh-&gt;allowed_nodes);</a>
<a name="ln1691">        rsc_lh-&gt;allowed_nodes = work;</a>
<a name="ln1692">        work = NULL;</a>
<a name="ln1693"> </a>
<a name="ln1694">    } else {</a>
<a name="ln1695">        static char score[33];</a>
<a name="ln1696"> </a>
<a name="ln1697">        score2char_stack(constraint-&gt;score, score, sizeof(score));</a>
<a name="ln1698"> </a>
<a name="ln1699">        pe_rsc_info(rsc_lh, &quot;%s: Rolling back scores from %s (%d, %s)&quot;,</a>
<a name="ln1700">                    rsc_lh-&gt;id, rsc_rh-&gt;id, do_check, score);</a>
<a name="ln1701">    }</a>
<a name="ln1702"> </a>
<a name="ln1703">    if (work) {</a>
<a name="ln1704">        g_hash_table_destroy(work);</a>
<a name="ln1705">    }</a>
<a name="ln1706">}</a>
<a name="ln1707"> </a>
<a name="ln1708">void</a>
<a name="ln1709">native_rsc_colocation_rh(resource_t * rsc_lh, resource_t * rsc_rh, rsc_colocation_t * constraint)</a>
<a name="ln1710">{</a>
<a name="ln1711">    enum filter_colocation_res filter_results;</a>
<a name="ln1712"> </a>
<a name="ln1713">    CRM_ASSERT(rsc_lh);</a>
<a name="ln1714">    CRM_ASSERT(rsc_rh);</a>
<a name="ln1715">    filter_results = filter_colocation_constraint(rsc_lh, rsc_rh, constraint, FALSE);</a>
<a name="ln1716">    pe_rsc_trace(rsc_lh, &quot;%sColocating %s with %s (%s, weight=%d, filter=%d)&quot;,</a>
<a name="ln1717">                 constraint-&gt;score &gt;= 0 ? &quot;&quot; : &quot;Anti-&quot;,</a>
<a name="ln1718">                 rsc_lh-&gt;id, rsc_rh-&gt;id, constraint-&gt;id, constraint-&gt;score, filter_results);</a>
<a name="ln1719"> </a>
<a name="ln1720">    switch (filter_results) {</a>
<a name="ln1721">        case influence_rsc_priority:</a>
<a name="ln1722">            influence_priority(rsc_lh, rsc_rh, constraint);</a>
<a name="ln1723">            break;</a>
<a name="ln1724">        case influence_rsc_location:</a>
<a name="ln1725">            pe_rsc_trace(rsc_lh, &quot;%sColocating %s with %s (%s, weight=%d)&quot;,</a>
<a name="ln1726">                         constraint-&gt;score &gt;= 0 ? &quot;&quot; : &quot;Anti-&quot;,</a>
<a name="ln1727">                         rsc_lh-&gt;id, rsc_rh-&gt;id, constraint-&gt;id, constraint-&gt;score);</a>
<a name="ln1728">            colocation_match(rsc_lh, rsc_rh, constraint);</a>
<a name="ln1729">            break;</a>
<a name="ln1730">        case influence_nothing:</a>
<a name="ln1731">        default:</a>
<a name="ln1732">            return;</a>
<a name="ln1733">    }</a>
<a name="ln1734">}</a>
<a name="ln1735"> </a>
<a name="ln1736">static gboolean</a>
<a name="ln1737">filter_rsc_ticket(resource_t * rsc_lh, rsc_ticket_t * rsc_ticket)</a>
<a name="ln1738">{</a>
<a name="ln1739">    if (rsc_ticket-&gt;role_lh != RSC_ROLE_UNKNOWN &amp;&amp; rsc_ticket-&gt;role_lh != rsc_lh-&gt;role) {</a>
<a name="ln1740">        pe_rsc_trace(rsc_lh, &quot;LH: Skipping constraint: \&quot;%s\&quot; state filter&quot;,</a>
<a name="ln1741">                     role2text(rsc_ticket-&gt;role_lh));</a>
<a name="ln1742">        return FALSE;</a>
<a name="ln1743">    }</a>
<a name="ln1744"> </a>
<a name="ln1745">    return TRUE;</a>
<a name="ln1746">}</a>
<a name="ln1747"> </a>
<a name="ln1748">void</a>
<a name="ln1749">rsc_ticket_constraint(resource_t * rsc_lh, rsc_ticket_t * rsc_ticket, pe_working_set_t * data_set)</a>
<a name="ln1750">{</a>
<a name="ln1751">    if (rsc_ticket == NULL) {</a>
<a name="ln1752">        pe_err(&quot;rsc_ticket was NULL&quot;);</a>
<a name="ln1753">        return;</a>
<a name="ln1754">    }</a>
<a name="ln1755"> </a>
<a name="ln1756">    if (rsc_lh == NULL) {</a>
<a name="ln1757">        pe_err(&quot;rsc_lh was NULL for %s&quot;, rsc_ticket-&gt;id);</a>
<a name="ln1758">        return;</a>
<a name="ln1759">    }</a>
<a name="ln1760"> </a>
<a name="ln1761">    if (rsc_ticket-&gt;ticket-&gt;granted &amp;&amp; rsc_ticket-&gt;ticket-&gt;standby == FALSE) {</a>
<a name="ln1762">        return;</a>
<a name="ln1763">    }</a>
<a name="ln1764"> </a>
<a name="ln1765">    if (rsc_lh-&gt;children) {</a>
<a name="ln1766">        GListPtr gIter = rsc_lh-&gt;children;</a>
<a name="ln1767"> </a>
<a name="ln1768">        pe_rsc_trace(rsc_lh, &quot;Processing ticket dependencies from %s&quot;, rsc_lh-&gt;id);</a>
<a name="ln1769"> </a>
<a name="ln1770">        for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln1771">            resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln1772"> </a>
<a name="ln1773">            rsc_ticket_constraint(child_rsc, rsc_ticket, data_set);</a>
<a name="ln1774">        }</a>
<a name="ln1775">        return;</a>
<a name="ln1776">    }</a>
<a name="ln1777"> </a>
<a name="ln1778">    pe_rsc_trace(rsc_lh, &quot;%s: Processing ticket dependency on %s (%s, %s)&quot;,</a>
<a name="ln1779">                 rsc_lh-&gt;id, rsc_ticket-&gt;ticket-&gt;id, rsc_ticket-&gt;id,</a>
<a name="ln1780">                 role2text(rsc_ticket-&gt;role_lh));</a>
<a name="ln1781"> </a>
<a name="ln1782">    if (rsc_ticket-&gt;ticket-&gt;granted == FALSE &amp;&amp; g_list_length(rsc_lh-&gt;running_on) &gt; 0) {</a>
<a name="ln1783">        GListPtr gIter = NULL;</a>
<a name="ln1784"> </a>
<a name="ln1785">        switch (rsc_ticket-&gt;loss_policy) {</a>
<a name="ln1786">            case loss_ticket_stop:</a>
<a name="ln1787">                resource_location(rsc_lh, NULL, -INFINITY, &quot;__loss_of_ticket__&quot;, data_set);</a>
<a name="ln1788">                break;</a>
<a name="ln1789"> </a>
<a name="ln1790">            case loss_ticket_demote:</a>
<a name="ln1791">                /*Promotion score will be set to -INFINITY in master_promotion_order() */</a>
<a name="ln1792">                if (rsc_ticket-&gt;role_lh != RSC_ROLE_MASTER) {</a>
<a name="ln1793">                    resource_location(rsc_lh, NULL, -INFINITY, &quot;__loss_of_ticket__&quot;, data_set);</a>
<a name="ln1794">                }</a>
<a name="ln1795">                break;</a>
<a name="ln1796"> </a>
<a name="ln1797">            case loss_ticket_fence:</a>
<a name="ln1798">                if (filter_rsc_ticket(rsc_lh, rsc_ticket) == FALSE) {</a>
<a name="ln1799">                    return;</a>
<a name="ln1800">                }</a>
<a name="ln1801"> </a>
<a name="ln1802">                resource_location(rsc_lh, NULL, -INFINITY, &quot;__loss_of_ticket__&quot;, data_set);</a>
<a name="ln1803"> </a>
<a name="ln1804">                for (gIter = rsc_lh-&gt;running_on; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln1805">                    node_t *node = (node_t *) gIter-&gt;data;</a>
<a name="ln1806"> </a>
<a name="ln1807">                    pe_fence_node(data_set, node, &quot;because deadman ticket was lost&quot;);</a>
<a name="ln1808">                }</a>
<a name="ln1809">                break;</a>
<a name="ln1810"> </a>
<a name="ln1811">            case loss_ticket_freeze:</a>
<a name="ln1812">                if (filter_rsc_ticket(rsc_lh, rsc_ticket) == FALSE) {</a>
<a name="ln1813">                    return;</a>
<a name="ln1814">                }</a>
<a name="ln1815">                if (g_list_length(rsc_lh-&gt;running_on) &gt; 0) {</a>
<a name="ln1816">                    clear_bit(rsc_lh-&gt;flags, pe_rsc_managed);</a>
<a name="ln1817">                    set_bit(rsc_lh-&gt;flags, pe_rsc_block);</a>
<a name="ln1818">                }</a>
<a name="ln1819">                break;</a>
<a name="ln1820">        }</a>
<a name="ln1821"> </a>
<a name="ln1822">    } else if (rsc_ticket-&gt;ticket-&gt;granted == FALSE) {</a>
<a name="ln1823"> </a>
<a name="ln1824">        if (rsc_ticket-&gt;role_lh != RSC_ROLE_MASTER || rsc_ticket-&gt;loss_policy == loss_ticket_stop) {</a>
<a name="ln1825">            resource_location(rsc_lh, NULL, -INFINITY, &quot;__no_ticket__&quot;, data_set);</a>
<a name="ln1826">        }</a>
<a name="ln1827"> </a>
<a name="ln1828">    } else if (rsc_ticket-&gt;ticket-&gt;standby) {</a>
<a name="ln1829"> </a>
<a name="ln1830">        if (rsc_ticket-&gt;role_lh != RSC_ROLE_MASTER || rsc_ticket-&gt;loss_policy == loss_ticket_stop) {</a>
<a name="ln1831">            resource_location(rsc_lh, NULL, -INFINITY, &quot;__ticket_standby__&quot;, data_set);</a>
<a name="ln1832">        }</a>
<a name="ln1833">    }</a>
<a name="ln1834">}</a>
<a name="ln1835"> </a>
<a name="ln1836">enum pe_action_flags</a>
<a name="ln1837">native_action_flags(action_t * action, node_t * node)</a>
<a name="ln1838">{</a>
<a name="ln1839">    return action-&gt;flags;</a>
<a name="ln1840">}</a>
<a name="ln1841"> </a>
<a name="ln1842">enum pe_graph_flags</a>
<a name="ln1843">native_update_actions(action_t * first, action_t * then, node_t * node, enum pe_action_flags flags,</a>
<a name="ln1844">                      enum pe_action_flags filter, enum pe_ordering type)</a>
<a name="ln1845">{</a>
<a name="ln1846">    /* flags == get_action_flags(first, then_node) called from update_action() */</a>
<a name="ln1847">    enum pe_graph_flags changed = pe_graph_none;</a>
<a name="ln1848">    enum pe_action_flags then_flags = then-&gt;flags;</a>
<a name="ln1849">    enum pe_action_flags first_flags = first-&gt;flags;</a>
<a name="ln1850"> </a>
<a name="ln1851">    crm_trace(   &quot;Testing %s on %s (0x%.6x) with %s 0x%.6x&quot;,</a>
<a name="ln1852">                 first-&gt;uuid, first-&gt;node ? first-&gt;node-&gt;details-&gt;uname : &quot;[none]&quot;,</a>
<a name="ln1853">                 first-&gt;flags, then-&gt;uuid, then-&gt;flags);</a>
<a name="ln1854"> </a>
<a name="ln1855">    if (type &amp; pe_order_asymmetrical) {</a>
<a name="ln1856">        resource_t *then_rsc = then-&gt;rsc;</a>
<a name="ln1857">        enum rsc_role_e then_rsc_role = then_rsc ? then_rsc-&gt;fns-&gt;state(then_rsc, TRUE) : 0;</a>
<a name="ln1858"> </a>
<a name="ln1859">        if (!then_rsc) {</a>
<a name="ln1860">            /* ignore */</a>
<a name="ln1861">        } else if ((then_rsc_role == RSC_ROLE_STOPPED) &amp;&amp; safe_str_eq(then-&gt;task, RSC_STOP)) {</a>
<a name="ln1862">            /* ignore... if 'then' is supposed to be stopped after 'first', but</a>
<a name="ln1863">             * then is already stopped, there is nothing to be done when non-symmetrical.  */</a>
<a name="ln1864">        } else if ((then_rsc_role &gt;= RSC_ROLE_STARTED)</a>
<a name="ln1865">                   &amp;&amp; safe_str_eq(then-&gt;task, RSC_START)</a>
<a name="ln1866">                   &amp;&amp; then-&gt;node</a>
<a name="ln1867">                   &amp;&amp; then_rsc-&gt;running_on</a>
<a name="ln1868">                   &amp;&amp; g_list_length(then_rsc-&gt;running_on) == 1</a>
<a name="ln1869">                   &amp;&amp; then-&gt;node-&gt;details == ((node_t *) then_rsc-&gt;running_on-&gt;data)-&gt;details) {</a>
<a name="ln1870">            /* ignore... if 'then' is supposed to be started after 'first', but</a>
<a name="ln1871">             * then is already started, there is nothing to be done when non-symmetrical.  */</a>
<a name="ln1872">        } else if (!(first-&gt;flags &amp; pe_action_runnable)) {</a>
<a name="ln1873">            /* prevent 'then' action from happening if 'first' is not runnable and</a>
<a name="ln1874">             * 'then' has not yet occurred. */</a>
<a name="ln1875">            pe_clear_action_bit(then, pe_action_runnable);</a>
<a name="ln1876">            pe_clear_action_bit(then, pe_action_optional);</a>
<a name="ln1877">            pe_rsc_trace(then-&gt;rsc, &quot;Unset optional and runnable on %s&quot;, then-&gt;uuid);</a>
<a name="ln1878">        } else {</a>
<a name="ln1879">            /* ignore... then is allowed to start/stop if it wants to. */</a>
<a name="ln1880">        }</a>
<a name="ln1881">    }</a>
<a name="ln1882"> </a>
<a name="ln1883">    if (type &amp; pe_order_implies_first) {</a>
<a name="ln1884">        if ((filter &amp; pe_action_optional) &amp;&amp; (flags &amp; pe_action_optional) == 0) {</a>
<a name="ln1885">            pe_rsc_trace(first-&gt;rsc, &quot;Unset optional on %s because of %s&quot;, first-&gt;uuid, then-&gt;uuid);</a>
<a name="ln1886"> </a>
<a name="ln1887">            pe_clear_action_bit(first, pe_action_optional);</a>
<a name="ln1888">        }</a>
<a name="ln1889"> </a>
<a name="ln1890">        if (is_set(flags, pe_action_migrate_runnable) &amp;&amp;</a>
<a name="ln1891">            is_set(then-&gt;flags, pe_action_migrate_runnable) == FALSE &amp;&amp;</a>
<a name="ln1892">            is_set(then-&gt;flags, pe_action_optional) == FALSE) {</a>
<a name="ln1893"> </a>
<a name="ln1894">            pe_rsc_trace(first-&gt;rsc, &quot;Unset migrate runnable on %s because of %s&quot;,</a>
<a name="ln1895">                         first-&gt;uuid, then-&gt;uuid);</a>
<a name="ln1896">            pe_clear_action_bit(first, pe_action_migrate_runnable);</a>
<a name="ln1897">        }</a>
<a name="ln1898">    }</a>
<a name="ln1899"> </a>
<a name="ln1900">    if (type &amp; pe_order_implies_first_master) {</a>
<a name="ln1901">        if ((filter &amp; pe_action_optional) &amp;&amp;</a>
<a name="ln1902">            ((then-&gt;flags &amp; pe_action_optional) == FALSE) &amp;&amp;</a>
<a name="ln1903">            then-&gt;rsc &amp;&amp; (then-&gt;rsc-&gt;role == RSC_ROLE_MASTER)) {</a>
<a name="ln1904">            pe_clear_action_bit(first, pe_action_optional);</a>
<a name="ln1905"> </a>
<a name="ln1906">            if (is_set(first-&gt;flags, pe_action_migrate_runnable) &amp;&amp;</a>
<a name="ln1907">                is_set(then-&gt;flags, pe_action_migrate_runnable) == FALSE) {</a>
<a name="ln1908"> </a>
<a name="ln1909">                pe_rsc_trace(first-&gt;rsc, &quot;Unset migrate runnable on %s because of %s&quot;, first-&gt;uuid, then-&gt;uuid);</a>
<a name="ln1910">                pe_clear_action_bit(first, pe_action_migrate_runnable);</a>
<a name="ln1911">            }</a>
<a name="ln1912">            pe_rsc_trace(then-&gt;rsc, &quot;Unset optional on %s because of %s&quot;, first-&gt;uuid, then-&gt;uuid);</a>
<a name="ln1913">        }</a>
<a name="ln1914">    }</a>
<a name="ln1915"> </a>
<a name="ln1916">    if ((type &amp; pe_order_implies_first_migratable)</a>
<a name="ln1917">        &amp;&amp; is_set(filter, pe_action_optional)) {</a>
<a name="ln1918"> </a>
<a name="ln1919">        if (((then-&gt;flags &amp; pe_action_migrate_runnable) == FALSE) ||</a>
<a name="ln1920">            ((then-&gt;flags &amp; pe_action_runnable) == FALSE)) {</a>
<a name="ln1921"> </a>
<a name="ln1922">            pe_rsc_trace(then-&gt;rsc, &quot;Unset runnable on %s because %s is neither runnable or migratable&quot;, first-&gt;uuid, then-&gt;uuid);</a>
<a name="ln1923">            pe_clear_action_bit(first, pe_action_runnable);</a>
<a name="ln1924">        }</a>
<a name="ln1925"> </a>
<a name="ln1926">        if ((then-&gt;flags &amp; pe_action_optional) == 0) {</a>
<a name="ln1927"> </a>
<a name="ln1928">            pe_rsc_trace(then-&gt;rsc, &quot;Unset optional on %s because %s is not optional&quot;, first-&gt;uuid, then-&gt;uuid);</a>
<a name="ln1929">            pe_clear_action_bit(first, pe_action_optional);</a>
<a name="ln1930">        }</a>
<a name="ln1931">    }</a>
<a name="ln1932"> </a>
<a name="ln1933">    if ((type &amp; pe_order_pseudo_left)</a>
<a name="ln1934">        &amp;&amp; is_set(filter, pe_action_optional)) {</a>
<a name="ln1935"> </a>
<a name="ln1936">        if ((first-&gt;flags &amp; pe_action_runnable) == FALSE) {</a>
<a name="ln1937">            pe_clear_action_bit(then, pe_action_migrate_runnable);</a>
<a name="ln1938">            pe_clear_action_bit(then, pe_action_pseudo);</a>
<a name="ln1939">            pe_rsc_trace(then-&gt;rsc, &quot;Unset pseudo on %s because %s is not runnable&quot;, then-&gt;uuid, first-&gt;uuid);</a>
<a name="ln1940">        }</a>
<a name="ln1941"> </a>
<a name="ln1942">    }</a>
<a name="ln1943"> </a>
<a name="ln1944">    if (is_set(type, pe_order_runnable_left)</a>
<a name="ln1945">        &amp;&amp; is_set(filter, pe_action_runnable)</a>
<a name="ln1946">        &amp;&amp; is_set(then-&gt;flags, pe_action_runnable)</a>
<a name="ln1947">        &amp;&amp; is_set(flags, pe_action_runnable) == FALSE) {</a>
<a name="ln1948">        pe_rsc_trace(then-&gt;rsc, &quot;Unset runnable on %s because of %s&quot;, then-&gt;uuid, first-&gt;uuid);</a>
<a name="ln1949">        pe_clear_action_bit(then, pe_action_runnable);</a>
<a name="ln1950">        pe_clear_action_bit(then, pe_action_migrate_runnable);</a>
<a name="ln1951">    }</a>
<a name="ln1952"> </a>
<a name="ln1953">    if (is_set(type, pe_order_implies_then)</a>
<a name="ln1954">        &amp;&amp; is_set(filter, pe_action_optional)</a>
<a name="ln1955">        &amp;&amp; is_set(then-&gt;flags, pe_action_optional)</a>
<a name="ln1956">        &amp;&amp; is_set(flags, pe_action_optional) == FALSE) {</a>
<a name="ln1957"> </a>
<a name="ln1958">        /* in this case, treat migrate_runnable as if first is optional */</a>
<a name="ln1959">        if (is_set(first-&gt;flags, pe_action_migrate_runnable) == FALSE) {</a>
<a name="ln1960">           pe_rsc_trace(then-&gt;rsc, &quot;Unset optional on %s because of %s&quot;, then-&gt;uuid, first-&gt;uuid);</a>
<a name="ln1961">           pe_clear_action_bit(then, pe_action_optional);</a>
<a name="ln1962">        }</a>
<a name="ln1963">    }</a>
<a name="ln1964"> </a>
<a name="ln1965">    if (is_set(type, pe_order_restart)) {</a>
<a name="ln1966">        const char *reason = NULL;</a>
<a name="ln1967"> </a>
<a name="ln1968">        CRM_ASSERT(first-&gt;rsc &amp;&amp; first-&gt;rsc-&gt;variant == pe_native);</a>
<a name="ln1969">        CRM_ASSERT(then-&gt;rsc &amp;&amp; then-&gt;rsc-&gt;variant == pe_native);</a>
<a name="ln1970"> </a>
<a name="ln1971">        if ((filter &amp; pe_action_runnable)</a>
<a name="ln1972">            &amp;&amp; (then-&gt;flags &amp; pe_action_runnable) == 0</a>
<a name="ln1973">            &amp;&amp; (then-&gt;rsc-&gt;flags &amp; pe_rsc_managed)) {</a>
<a name="ln1974">            reason = &quot;shutdown&quot;;</a>
<a name="ln1975">        }</a>
<a name="ln1976"> </a>
<a name="ln1977">        if ((filter &amp; pe_action_optional) &amp;&amp; (then-&gt;flags &amp; pe_action_optional) == 0) {</a>
<a name="ln1978">            reason = &quot;recover&quot;;</a>
<a name="ln1979">        }</a>
<a name="ln1980"> </a>
<a name="ln1981">        if (reason &amp;&amp; is_set(first-&gt;flags, pe_action_optional)) {</a>
<a name="ln1982">            if (is_set(first-&gt;flags, pe_action_runnable)</a>
<a name="ln1983">                || is_not_set(then-&gt;flags, pe_action_optional)) {</a>
<a name="ln1984">                pe_rsc_trace(first-&gt;rsc, &quot;Handling %s: %s -&gt; %s&quot;, reason, first-&gt;uuid, then-&gt;uuid);</a>
<a name="ln1985">                pe_clear_action_bit(first, pe_action_optional);</a>
<a name="ln1986">            }</a>
<a name="ln1987">        }</a>
<a name="ln1988"> </a>
<a name="ln1989">        if (reason &amp;&amp; is_not_set(first-&gt;flags, pe_action_optional)</a>
<a name="ln1990">            &amp;&amp; is_not_set(first-&gt;flags, pe_action_runnable)) {</a>
<a name="ln1991">            pe_rsc_trace(then-&gt;rsc, &quot;Handling %s: %s -&gt; %s&quot;, reason, first-&gt;uuid, then-&gt;uuid);</a>
<a name="ln1992">            pe_clear_action_bit(then, pe_action_runnable);</a>
<a name="ln1993">        }</a>
<a name="ln1994"> </a>
<a name="ln1995">        if (reason &amp;&amp;</a>
<a name="ln1996">            is_not_set(first-&gt;flags, pe_action_optional) &amp;&amp;</a>
<a name="ln1997">            is_set(first-&gt;flags, pe_action_migrate_runnable)  &amp;&amp;</a>
<a name="ln1998">            is_not_set(then-&gt;flags, pe_action_migrate_runnable)) {</a>
<a name="ln1999"> </a>
<a name="ln2000">            pe_clear_action_bit(first, pe_action_migrate_runnable);</a>
<a name="ln2001">        }</a>
<a name="ln2002"> </a>
<a name="ln2003">    }</a>
<a name="ln2004"> </a>
<a name="ln2005">    if (then_flags != then-&gt;flags) {</a>
<a name="ln2006">        changed |= pe_graph_updated_then;</a>
<a name="ln2007">        pe_rsc_trace(then-&gt;rsc,</a>
<a name="ln2008">                     &quot;Then: Flags for %s on %s are now  0x%.6x (was 0x%.6x) because of %s 0x%.6x&quot;,</a>
<a name="ln2009">                     then-&gt;uuid, then-&gt;node ? then-&gt;node-&gt;details-&gt;uname : &quot;[none]&quot;, then-&gt;flags,</a>
<a name="ln2010">                     then_flags, first-&gt;uuid, first-&gt;flags);</a>
<a name="ln2011"> </a>
<a name="ln2012">        if(then-&gt;rsc &amp;&amp; then-&gt;rsc-&gt;parent) {</a>
<a name="ln2013">            /* &quot;X_stop then X_start&quot; doesn't get handled for cloned groups unless we do this */</a>
<a name="ln2014">            update_action(then);</a>
<a name="ln2015">        }</a>
<a name="ln2016">    }</a>
<a name="ln2017"> </a>
<a name="ln2018">    if (first_flags != first-&gt;flags) {</a>
<a name="ln2019">        changed |= pe_graph_updated_first;</a>
<a name="ln2020">        pe_rsc_trace(first-&gt;rsc,</a>
<a name="ln2021">                     &quot;First: Flags for %s on %s are now  0x%.6x (was 0x%.6x) because of %s 0x%.6x&quot;,</a>
<a name="ln2022">                     first-&gt;uuid, first-&gt;node ? first-&gt;node-&gt;details-&gt;uname : &quot;[none]&quot;,</a>
<a name="ln2023">                     first-&gt;flags, first_flags, then-&gt;uuid, then-&gt;flags);</a>
<a name="ln2024">    }</a>
<a name="ln2025"> </a>
<a name="ln2026">    return changed;</a>
<a name="ln2027">}</a>
<a name="ln2028"> </a>
<a name="ln2029">void</a>
<a name="ln2030">native_rsc_location(resource_t * rsc, rsc_to_node_t * constraint)</a>
<a name="ln2031">{</a>
<a name="ln2032">    GListPtr gIter = NULL;</a>
<a name="ln2033">    GHashTableIter iter;</a>
<a name="ln2034">    node_t *node = NULL;</a>
<a name="ln2035"> </a>
<a name="ln2036">    if (constraint == NULL) {</a>
<a name="ln2037">        pe_err(&quot;Constraint is NULL&quot;);</a>
<a name="ln2038">        return;</a>
<a name="ln2039"> </a>
<a name="ln2040">    } else if (rsc == NULL) {</a>
<a name="ln2041">        pe_err(&quot;LHS of rsc_to_node (%s) is NULL&quot;, constraint-&gt;id);</a>
<a name="ln2042">        return;</a>
<a name="ln2043">    }</a>
<a name="ln2044"> </a>
<a name="ln2045">    pe_rsc_trace(rsc, &quot;Applying %s (%s) to %s&quot;, constraint-&gt;id,</a>
<a name="ln2046">                 role2text(constraint-&gt;role_filter), rsc-&gt;id);</a>
<a name="ln2047"> </a>
<a name="ln2048">    /* take &quot;lifetime&quot; into account */</a>
<a name="ln2049">    if (constraint-&gt;role_filter &gt; RSC_ROLE_UNKNOWN &amp;&amp; constraint-&gt;role_filter != rsc-&gt;next_role) {</a>
<a name="ln2050">        pe_rsc_debug(rsc, &quot;Constraint (%s) is not active (role : %s vs. %s)&quot;,</a>
<a name="ln2051">                     constraint-&gt;id, role2text(constraint-&gt;role_filter), role2text(rsc-&gt;next_role));</a>
<a name="ln2052">        return;</a>
<a name="ln2053"> </a>
<a name="ln2054">    } else if (is_active(constraint) == FALSE) {</a>
<a name="ln2055">        pe_rsc_trace(rsc, &quot;Constraint (%s) is not active&quot;, constraint-&gt;id);</a>
<a name="ln2056">        return;</a>
<a name="ln2057">    }</a>
<a name="ln2058"> </a>
<a name="ln2059">    if (constraint-&gt;node_list_rh == NULL) {</a>
<a name="ln2060">        pe_rsc_trace(rsc, &quot;RHS of constraint %s is NULL&quot;, constraint-&gt;id);</a>
<a name="ln2061">        return;</a>
<a name="ln2062">    }</a>
<a name="ln2063"> </a>
<a name="ln2064">    for (gIter = constraint-&gt;node_list_rh; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2065">        node_t *node = (node_t *) gIter-&gt;data;</a>
<a name="ln2066">        node_t *other_node = NULL;</a>
<a name="ln2067"> </a>
<a name="ln2068">        other_node = (node_t *) pe_hash_table_lookup(rsc-&gt;allowed_nodes, node-&gt;details-&gt;id);</a>
<a name="ln2069"> </a>
<a name="ln2070">        if (other_node != NULL) {</a>
<a name="ln2071">            pe_rsc_trace(rsc, &quot;%s + %s: %d + %d&quot;,</a>
<a name="ln2072">                         node-&gt;details-&gt;uname,</a>
<a name="ln2073">                         other_node-&gt;details-&gt;uname, node-&gt;weight, other_node-&gt;weight);</a>
<a name="ln2074">            other_node-&gt;weight = merge_weights(other_node-&gt;weight, node-&gt;weight);</a>
<a name="ln2075"> </a>
<a name="ln2076">        } else {</a>
<a name="ln2077">            other_node = node_copy(node);</a>
<a name="ln2078"> </a>
<a name="ln2079">            g_hash_table_insert(rsc-&gt;allowed_nodes, (gpointer) other_node-&gt;details-&gt;id, other_node);</a>
<a name="ln2080">        }</a>
<a name="ln2081"> </a>
<a name="ln2082">        if (other_node-&gt;rsc_discover_mode &lt; constraint-&gt;discover_mode) {</a>
<a name="ln2083">            if (constraint-&gt;discover_mode == discover_exclusive) {</a>
<a name="ln2084">                rsc-&gt;exclusive_discover = TRUE;</a>
<a name="ln2085">            }</a>
<a name="ln2086">            /* exclusive &gt; never &gt; always... always is default */</a>
<a name="ln2087">            other_node-&gt;rsc_discover_mode = constraint-&gt;discover_mode;</a>
<a name="ln2088">        }</a>
<a name="ln2089">    }</a>
<a name="ln2090"> </a>
<a name="ln2091">    g_hash_table_iter_init(&amp;iter, rsc-&gt;allowed_nodes);</a>
<a name="ln2092">    while (g_hash_table_iter_next(&amp;iter, NULL, (void **)&amp;node)) {</a>
<a name="ln2093">        pe_rsc_trace(rsc, &quot;%s + %s : %d&quot;, rsc-&gt;id, node-&gt;details-&gt;uname, node-&gt;weight);</a>
<a name="ln2094">    }</a>
<a name="ln2095">}</a>
<a name="ln2096"> </a>
<a name="ln2097">void</a>
<a name="ln2098">native_expand(resource_t * rsc, pe_working_set_t * data_set)</a>
<a name="ln2099">{</a>
<a name="ln2100">    GListPtr gIter = NULL;</a>
<a name="ln2101"> </a>
<a name="ln2102">    CRM_ASSERT(rsc);</a>
<a name="ln2103">    pe_rsc_trace(rsc, &quot;Processing actions from %s&quot;, rsc-&gt;id);</a>
<a name="ln2104"> </a>
<a name="ln2105">    for (gIter = rsc-&gt;actions; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2106">        action_t *action = (action_t *) gIter-&gt;data;</a>
<a name="ln2107"> </a>
<a name="ln2108">        crm_trace(&quot;processing action %d for rsc=%s&quot;, action-&gt;id, rsc-&gt;id);</a>
<a name="ln2109">        graph_element_from_action(action, data_set);</a>
<a name="ln2110">    }</a>
<a name="ln2111"> </a>
<a name="ln2112">    for (gIter = rsc-&gt;children; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2113">        resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln2114"> </a>
<a name="ln2115">        child_rsc-&gt;cmds-&gt;expand(child_rsc, data_set);</a>
<a name="ln2116">    }</a>
<a name="ln2117">}</a>
<a name="ln2118"> </a>
<a name="ln2119">#define log_change(fmt, args...)  do {          \</a>
<a name="ln2120">        if(terminal) {                          \</a>
<a name="ln2121">            printf(&quot; * &quot;fmt&quot;\n&quot;, ##args);       \</a>
<a name="ln2122">        } else {                                \</a>
<a name="ln2123">            crm_notice(fmt, ##args);            \</a>
<a name="ln2124">        }                                       \</a>
<a name="ln2125">    } while(0)</a>
<a name="ln2126"> </a>
<a name="ln2127">#define STOP_SANITY_ASSERT(lineno) do {                                 \</a>
<a name="ln2128">        if(current &amp;&amp; current-&gt;details-&gt;unclean) {                      \</a>
<a name="ln2129">            /* It will be a pseudo op */                                \</a>
<a name="ln2130">        } else if(stop == NULL) {                                       \</a>
<a name="ln2131">            crm_err(&quot;%s:%d: No stop action exists for %s&quot;, __FUNCTION__, lineno, rsc-&gt;id); \</a>
<a name="ln2132">            CRM_ASSERT(stop != NULL);                                   \</a>
<a name="ln2133">        } else if(is_set(stop-&gt;flags, pe_action_optional)) { \</a>
<a name="ln2134">            crm_err(&quot;%s:%d: Action %s is still optional&quot;, __FUNCTION__, lineno, stop-&gt;uuid); \</a>
<a name="ln2135">            CRM_ASSERT(is_not_set(stop-&gt;flags, pe_action_optional));    \</a>
<a name="ln2136">        }                                                               \</a>
<a name="ln2137">    } while(0)</a>
<a name="ln2138"> </a>
<a name="ln2139">void</a>
<a name="ln2140">LogActions(resource_t * rsc, pe_working_set_t * data_set, gboolean terminal)</a>
<a name="ln2141">{</a>
<a name="ln2142">    node_t *next = NULL;</a>
<a name="ln2143">    node_t *current = NULL;</a>
<a name="ln2144"> </a>
<a name="ln2145">    action_t *stop = NULL;</a>
<a name="ln2146">    action_t *start = NULL;</a>
<a name="ln2147">    action_t *demote = NULL;</a>
<a name="ln2148">    action_t *promote = NULL;</a>
<a name="ln2149"> </a>
<a name="ln2150">    char *key = NULL;</a>
<a name="ln2151">    gboolean moving = FALSE;</a>
<a name="ln2152">    GListPtr possible_matches = NULL;</a>
<a name="ln2153"> </a>
<a name="ln2154">    if(rsc-&gt;variant == pe_container) {</a>
<a name="ln2155">        container_LogActions(rsc, data_set, terminal);</a>
<a name="ln2156">        return;</a>
<a name="ln2157">    }</a>
<a name="ln2158"> </a>
<a name="ln2159">    if (rsc-&gt;children) {</a>
<a name="ln2160">        GListPtr gIter = NULL;</a>
<a name="ln2161"> </a>
<a name="ln2162">        for (gIter = rsc-&gt;children; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2163">            resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln2164"> </a>
<a name="ln2165">            LogActions(child_rsc, data_set, terminal);</a>
<a name="ln2166">        }</a>
<a name="ln2167">        return;</a>
<a name="ln2168">    }</a>
<a name="ln2169"> </a>
<a name="ln2170">    next = rsc-&gt;allocated_to;</a>
<a name="ln2171">    if (rsc-&gt;running_on) {</a>
<a name="ln2172">        if (g_list_length(rsc-&gt;running_on) &gt; 1 &amp;&amp; rsc-&gt;partial_migration_source) {</a>
<a name="ln2173">            current = rsc-&gt;partial_migration_source;</a>
<a name="ln2174">        } else {</a>
<a name="ln2175">            current = rsc-&gt;running_on-&gt;data;</a>
<a name="ln2176">        }</a>
<a name="ln2177"> </a>
<a name="ln2178">        if (rsc-&gt;role == RSC_ROLE_STOPPED) {</a>
<a name="ln2179">            /*</a>
<a name="ln2180">             * This can occur when resources are being recovered</a>
<a name="ln2181">             * We fiddle with the current role in native_create_actions()</a>
<a name="ln2182">             */</a>
<a name="ln2183">            rsc-&gt;role = RSC_ROLE_STARTED;</a>
<a name="ln2184">        }</a>
<a name="ln2185">    }</a>
<a name="ln2186"> </a>
<a name="ln2187">    if (current == NULL &amp;&amp; is_set(rsc-&gt;flags, pe_rsc_orphan)) {</a>
<a name="ln2188">        /* Don't log stopped orphans */</a>
<a name="ln2189">        return;</a>
<a name="ln2190">    }</a>
<a name="ln2191"> </a>
<a name="ln2192">    if (is_not_set(rsc-&gt;flags, pe_rsc_managed)</a>
<a name="ln2193">        || (current == NULL &amp;&amp; next == NULL)) {</a>
<a name="ln2194">        pe_rsc_info(rsc, &quot;Leave   %s\t(%s%s)&quot;,</a>
<a name="ln2195">                    rsc-&gt;id, role2text(rsc-&gt;role), is_not_set(rsc-&gt;flags,</a>
<a name="ln2196">                                                              pe_rsc_managed) ? &quot; unmanaged&quot; : &quot;&quot;);</a>
<a name="ln2197">        return;</a>
<a name="ln2198">    }</a>
<a name="ln2199"> </a>
<a name="ln2200">    if (current != NULL &amp;&amp; next != NULL &amp;&amp; safe_str_neq(current-&gt;details-&gt;id, next-&gt;details-&gt;id)) {</a>
<a name="ln2201">        moving = TRUE;</a>
<a name="ln2202">    }</a>
<a name="ln2203"> </a>
<a name="ln2204">    key = start_key(rsc);</a>
<a name="ln2205">    possible_matches = find_actions(rsc-&gt;actions, key, next);</a>
<a name="ln2206">    free(key);</a>
<a name="ln2207">    if (possible_matches) {</a>
<a name="ln2208">        start = possible_matches-&gt;data;</a>
<a name="ln2209">        g_list_free(possible_matches);</a>
<a name="ln2210">    }</a>
<a name="ln2211"> </a>
<a name="ln2212">    key = stop_key(rsc);</a>
<a name="ln2213">    if(start == NULL || is_set(start-&gt;flags, pe_action_runnable) == FALSE) {</a>
<a name="ln2214">        possible_matches = find_actions(rsc-&gt;actions, key, NULL);</a>
<a name="ln2215">    } else {</a>
<a name="ln2216">        possible_matches = find_actions(rsc-&gt;actions, key, current);</a>
<a name="ln2217">    }</a>
<a name="ln2218">    free(key);</a>
<a name="ln2219">    if (possible_matches) {</a>
<a name="ln2220">        stop = possible_matches-&gt;data;</a>
<a name="ln2221">        g_list_free(possible_matches);</a>
<a name="ln2222">    }</a>
<a name="ln2223"> </a>
<a name="ln2224">    key = promote_key(rsc);</a>
<a name="ln2225">    possible_matches = find_actions(rsc-&gt;actions, key, next);</a>
<a name="ln2226">    free(key);</a>
<a name="ln2227">    if (possible_matches) {</a>
<a name="ln2228">        promote = possible_matches-&gt;data;</a>
<a name="ln2229">        g_list_free(possible_matches);</a>
<a name="ln2230">    }</a>
<a name="ln2231"> </a>
<a name="ln2232">    key = demote_key(rsc);</a>
<a name="ln2233">    possible_matches = find_actions(rsc-&gt;actions, key, next);</a>
<a name="ln2234">    free(key);</a>
<a name="ln2235">    if (possible_matches) {</a>
<a name="ln2236">        demote = possible_matches-&gt;data;</a>
<a name="ln2237">        g_list_free(possible_matches);</a>
<a name="ln2238">    }</a>
<a name="ln2239"> </a>
<a name="ln2240">    if (rsc-&gt;role == rsc-&gt;next_role) {</a>
<a name="ln2241">        action_t *migrate_to = NULL;</a>
<a name="ln2242">        key = generate_op_key(rsc-&gt;id, RSC_MIGRATED, 0);</a>
<a name="ln2243">        possible_matches = find_actions(rsc-&gt;actions, key, next);</a>
<a name="ln2244">        free(key);</a>
<a name="ln2245"> </a>
<a name="ln2246">        if (possible_matches) {</a>
<a name="ln2247">            migrate_to = possible_matches-&gt;data;</a>
<a name="ln2248">        }</a>
<a name="ln2249"> </a>
<a name="ln2250">        CRM_CHECK(next != NULL,);</a>
<a name="ln2251">        if (next == NULL) {</a>
<a name="ln2252">        } else if (migrate_to &amp;&amp; is_set(migrate_to-&gt;flags, pe_action_runnable) &amp;&amp; current) {</a>
<a name="ln2253">            log_change(&quot;Migrate %s\t(%s %s -&gt; %s)&quot;,</a>
<a name="ln2254">                       rsc-&gt;id, role2text(rsc-&gt;role), current-&gt;details-&gt;uname,</a>
<a name="ln2255">                       next-&gt;details-&gt;uname);</a>
<a name="ln2256"> </a>
<a name="ln2257">        } else if (is_set(rsc-&gt;flags, pe_rsc_reload)) {</a>
<a name="ln2258">            log_change(&quot;Reload  %s\t(%s %s)&quot;, rsc-&gt;id, role2text(rsc-&gt;role), next-&gt;details-&gt;uname);</a>
<a name="ln2259"> </a>
<a name="ln2260">        } else if (start == NULL || is_set(start-&gt;flags, pe_action_optional)) {</a>
<a name="ln2261">            pe_rsc_info(rsc, &quot;Leave   %s\t(%s %s)&quot;, rsc-&gt;id, role2text(rsc-&gt;role),</a>
<a name="ln2262">                        next-&gt;details-&gt;uname);</a>
<a name="ln2263"> </a>
<a name="ln2264">        } else if (start &amp;&amp; is_set(start-&gt;flags, pe_action_runnable) == FALSE) {</a>
<a name="ln2265">            log_change(&quot;Stop    %s\t(%s %s%s)&quot;, rsc-&gt;id, role2text(rsc-&gt;role), current?current-&gt;details-&gt;uname:&quot;N/A&quot;,</a>
<a name="ln2266">                       stop &amp;&amp; is_not_set(stop-&gt;flags, pe_action_runnable) ? &quot; - blocked&quot; : &quot;&quot;);</a>
<a name="ln2267">            STOP_SANITY_ASSERT(__LINE__);</a>
<a name="ln2268"> </a>
<a name="ln2269">        } else if (moving &amp;&amp; current) {</a>
<a name="ln2270">            log_change(&quot;%s %s\t(%s %s -&gt; %s)&quot;,</a>
<a name="ln2271">                       is_set(rsc-&gt;flags, pe_rsc_failed) ? &quot;Recover&quot; : &quot;Move   &quot;,</a>
<a name="ln2272">                       rsc-&gt;id, role2text(rsc-&gt;role),</a>
<a name="ln2273">                       current-&gt;details-&gt;uname, next-&gt;details-&gt;uname);</a>
<a name="ln2274"> </a>
<a name="ln2275">        } else if (is_set(rsc-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln2276">            log_change(&quot;Recover %s\t(%s %s)&quot;, rsc-&gt;id, role2text(rsc-&gt;role), next-&gt;details-&gt;uname);</a>
<a name="ln2277">            STOP_SANITY_ASSERT(__LINE__);</a>
<a name="ln2278"> </a>
<a name="ln2279">        } else {</a>
<a name="ln2280">            log_change(&quot;Restart %s\t(%s %s)&quot;, rsc-&gt;id, role2text(rsc-&gt;role), next-&gt;details-&gt;uname);</a>
<a name="ln2281">            /* STOP_SANITY_ASSERT(__LINE__); False positive for migrate-fail-7 */</a>
<a name="ln2282">        }</a>
<a name="ln2283"> </a>
<a name="ln2284">        g_list_free(possible_matches);</a>
<a name="ln2285">        return;</a>
<a name="ln2286">    }</a>
<a name="ln2287"> </a>
<a name="ln2288">    if (rsc-&gt;role &gt; RSC_ROLE_SLAVE &amp;&amp; rsc-&gt;role &gt; rsc-&gt;next_role) {</a>
<a name="ln2289">        CRM_CHECK(current != NULL,);</a>
<a name="ln2290">        if (current != NULL) {</a>
<a name="ln2291">            gboolean allowed = FALSE;</a>
<a name="ln2292"> </a>
<a name="ln2293">            if (demote != NULL &amp;&amp; (demote-&gt;flags &amp; pe_action_runnable)) {</a>
<a name="ln2294">                allowed = TRUE;</a>
<a name="ln2295">            }</a>
<a name="ln2296"> </a>
<a name="ln2297">            log_change(&quot;Demote  %s\t(%s -&gt; %s %s%s)&quot;,</a>
<a name="ln2298">                       rsc-&gt;id,</a>
<a name="ln2299">                       role2text(rsc-&gt;role),</a>
<a name="ln2300">                       role2text(rsc-&gt;next_role),</a>
<a name="ln2301">                       current-&gt;details-&gt;uname, allowed ? &quot;&quot; : &quot; - blocked&quot;);</a>
<a name="ln2302"> </a>
<a name="ln2303">            if (stop != NULL &amp;&amp; is_not_set(stop-&gt;flags, pe_action_optional)</a>
<a name="ln2304">                &amp;&amp; rsc-&gt;next_role &gt; RSC_ROLE_STOPPED &amp;&amp; moving == FALSE) {</a>
<a name="ln2305">                if (is_set(rsc-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln2306">                    log_change(&quot;Recover %s\t(%s %s)&quot;,</a>
<a name="ln2307">                               rsc-&gt;id, role2text(rsc-&gt;role), next-&gt;details-&gt;uname);</a>
<a name="ln2308">                    STOP_SANITY_ASSERT(__LINE__);</a>
<a name="ln2309"> </a>
<a name="ln2310">                } else if (is_set(rsc-&gt;flags, pe_rsc_reload)) {</a>
<a name="ln2311">                    log_change(&quot;Reload  %s\t(%s %s)&quot;, rsc-&gt;id, role2text(rsc-&gt;role),</a>
<a name="ln2312">                               next-&gt;details-&gt;uname);</a>
<a name="ln2313"> </a>
<a name="ln2314">                } else {</a>
<a name="ln2315">                    log_change(&quot;Restart %s\t(%s %s)&quot;,</a>
<a name="ln2316">                               rsc-&gt;id, role2text(rsc-&gt;next_role), next-&gt;details-&gt;uname);</a>
<a name="ln2317">                    STOP_SANITY_ASSERT(__LINE__);</a>
<a name="ln2318">                }</a>
<a name="ln2319">            }</a>
<a name="ln2320">        }</a>
<a name="ln2321"> </a>
<a name="ln2322">    } else if (rsc-&gt;next_role == RSC_ROLE_STOPPED) {</a>
<a name="ln2323">        GListPtr gIter = NULL;</a>
<a name="ln2324"> </a>
<a name="ln2325">        CRM_CHECK(current != NULL,);</a>
<a name="ln2326"> </a>
<a name="ln2327">        key = stop_key(rsc);</a>
<a name="ln2328">        for (gIter = rsc-&gt;running_on; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2329">            node_t *node = (node_t *) gIter-&gt;data;</a>
<a name="ln2330">            action_t *stop_op = NULL;</a>
<a name="ln2331">            gboolean allowed = FALSE;</a>
<a name="ln2332"> </a>
<a name="ln2333">            possible_matches = find_actions(rsc-&gt;actions, key, node);</a>
<a name="ln2334">            if (possible_matches) {</a>
<a name="ln2335">                stop_op = possible_matches-&gt;data;</a>
<a name="ln2336">                g_list_free(possible_matches);</a>
<a name="ln2337">            }</a>
<a name="ln2338"> </a>
<a name="ln2339">            if (stop_op &amp;&amp; (stop_op-&gt;flags &amp; pe_action_runnable)) {</a>
<a name="ln2340">                STOP_SANITY_ASSERT(__LINE__);</a>
<a name="ln2341">                allowed = TRUE;</a>
<a name="ln2342">            }</a>
<a name="ln2343"> </a>
<a name="ln2344">            log_change(&quot;Stop    %s\t(%s%s)&quot;, rsc-&gt;id, node-&gt;details-&gt;uname,</a>
<a name="ln2345">                       allowed ? &quot;&quot; : &quot; - blocked&quot;);</a>
<a name="ln2346">        }</a>
<a name="ln2347"> </a>
<a name="ln2348">        free(key);</a>
<a name="ln2349">    }</a>
<a name="ln2350"> </a>
<a name="ln2351">    if (moving) {</a>
<a name="ln2352">        log_change(&quot;Move    %s\t(%s %s -&gt; %s)&quot;,</a>
<a name="ln2353">                   rsc-&gt;id, role2text(rsc-&gt;next_role), current-&gt;details-&gt;uname,</a>
<a name="ln2354">                   next-&gt;details-&gt;uname);</a>
<a name="ln2355">        STOP_SANITY_ASSERT(__LINE__);</a>
<a name="ln2356">    }</a>
<a name="ln2357"> </a>
<a name="ln2358">    if (rsc-&gt;role == RSC_ROLE_STOPPED) {</a>
<a name="ln2359">        gboolean allowed = FALSE;</a>
<a name="ln2360"> </a>
<a name="ln2361">        if (start &amp;&amp; (start-&gt;flags &amp; pe_action_runnable)) {</a>
<a name="ln2362">            allowed = TRUE;</a>
<a name="ln2363">        }</a>
<a name="ln2364"> </a>
<a name="ln2365">        CRM_CHECK(next != NULL,);</a>
<a name="ln2366">        if (next != NULL) {</a>
<a name="ln2367">            log_change(&quot;Start   %s\t(%s%s)&quot;, rsc-&gt;id, next-&gt;details-&gt;uname,</a>
<a name="ln2368">                       allowed ? &quot;&quot; : &quot; - blocked&quot;);</a>
<a name="ln2369">        }</a>
<a name="ln2370">        if (allowed == FALSE) {</a>
<a name="ln2371">            return;</a>
<a name="ln2372">        }</a>
<a name="ln2373">    }</a>
<a name="ln2374"> </a>
<a name="ln2375">    if (rsc-&gt;next_role &gt; RSC_ROLE_SLAVE &amp;&amp; rsc-&gt;role &lt; rsc-&gt;next_role) {</a>
<a name="ln2376">        gboolean allowed = FALSE;</a>
<a name="ln2377"> </a>
<a name="ln2378">        CRM_LOG_ASSERT(next);</a>
<a name="ln2379">        if (stop != NULL &amp;&amp; is_not_set(stop-&gt;flags, pe_action_optional)</a>
<a name="ln2380">            &amp;&amp; rsc-&gt;role &gt; RSC_ROLE_STOPPED) {</a>
<a name="ln2381">            if (is_set(rsc-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln2382">                log_change(&quot;Recover %s\t(%s %s)&quot;,</a>
<a name="ln2383">                           rsc-&gt;id, role2text(rsc-&gt;role), next?next-&gt;details-&gt;uname:NULL);</a>
<a name="ln2384">                STOP_SANITY_ASSERT(__LINE__);</a>
<a name="ln2385"> </a>
<a name="ln2386">            } else if (is_set(rsc-&gt;flags, pe_rsc_reload)) {</a>
<a name="ln2387">                log_change(&quot;Reload  %s\t(%s %s)&quot;, rsc-&gt;id, role2text(rsc-&gt;role),</a>
<a name="ln2388">                           next?next-&gt;details-&gt;uname:NULL);</a>
<a name="ln2389">                STOP_SANITY_ASSERT(__LINE__);</a>
<a name="ln2390"> </a>
<a name="ln2391">            } else {</a>
<a name="ln2392">                log_change(&quot;Restart %s\t(%s %s)&quot;,</a>
<a name="ln2393">                           rsc-&gt;id, role2text(rsc-&gt;role), next?next-&gt;details-&gt;uname:NULL);</a>
<a name="ln2394">                STOP_SANITY_ASSERT(__LINE__);</a>
<a name="ln2395">            }</a>
<a name="ln2396">        }</a>
<a name="ln2397"> </a>
<a name="ln2398">        if (promote &amp;&amp; (promote-&gt;flags &amp; pe_action_runnable)) {</a>
<a name="ln2399">            allowed = TRUE;</a>
<a name="ln2400">        }</a>
<a name="ln2401"> </a>
<a name="ln2402">        log_change(&quot;Promote %s\t(%s -&gt; %s %s%s)&quot;,</a>
<a name="ln2403">                   rsc-&gt;id,</a>
<a name="ln2404">                   role2text(rsc-&gt;role),</a>
<a name="ln2405">                   role2text(rsc-&gt;next_role),</a>
<a name="ln2406">                   next?next-&gt;details-&gt;uname:NULL,</a>
<a name="ln2407">                   allowed ? &quot;&quot; : &quot; - blocked&quot;);</a>
<a name="ln2408">    }</a>
<a name="ln2409">}</a>
<a name="ln2410"> </a>
<a name="ln2411">gboolean</a>
<a name="ln2412">StopRsc(resource_t * rsc, node_t * next, gboolean optional, pe_working_set_t * data_set)</a>
<a name="ln2413">{</a>
<a name="ln2414">    GListPtr gIter = NULL;</a>
<a name="ln2415"> </a>
<a name="ln2416">    CRM_ASSERT(rsc);</a>
<a name="ln2417">    pe_rsc_trace(rsc, &quot;%s&quot;, rsc-&gt;id);</a>
<a name="ln2418"> </a>
<a name="ln2419">    for (gIter = rsc-&gt;running_on; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2420">        node_t *current = (node_t *) gIter-&gt;data;</a>
<a name="ln2421">        action_t *stop;</a>
<a name="ln2422"> </a>
<a name="ln2423">        if (rsc-&gt;partial_migration_target) {</a>
<a name="ln2424">            if (rsc-&gt;partial_migration_target-&gt;details == current-&gt;details) {</a>
<a name="ln2425">                pe_rsc_trace(rsc, &quot;Filtered %s -&gt; %s %s&quot;, current-&gt;details-&gt;uname,</a>
<a name="ln2426">                             next-&gt;details-&gt;uname, rsc-&gt;id);</a>
<a name="ln2427">                continue;</a>
<a name="ln2428">            } else {</a>
<a name="ln2429">                pe_rsc_trace(rsc, &quot;Forced on %s %s&quot;, current-&gt;details-&gt;uname, rsc-&gt;id);</a>
<a name="ln2430">                optional = FALSE;</a>
<a name="ln2431">            }</a>
<a name="ln2432">        }</a>
<a name="ln2433"> </a>
<a name="ln2434">        pe_rsc_trace(rsc, &quot;%s on %s&quot;, rsc-&gt;id, current-&gt;details-&gt;uname);</a>
<a name="ln2435">        stop = stop_action(rsc, current, optional);</a>
<a name="ln2436"> </a>
<a name="ln2437">        if (is_not_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln2438">            update_action_flags(stop, pe_action_runnable | pe_action_clear, __FUNCTION__, __LINE__);</a>
<a name="ln2439">        }</a>
<a name="ln2440"> </a>
<a name="ln2441">        if (is_set(data_set-&gt;flags, pe_flag_remove_after_stop)) {</a>
<a name="ln2442">            DeleteRsc(rsc, current, optional, data_set);</a>
<a name="ln2443">        }</a>
<a name="ln2444">    }</a>
<a name="ln2445"> </a>
<a name="ln2446">    return TRUE;</a>
<a name="ln2447">}</a>
<a name="ln2448"> </a>
<a name="ln2449">gboolean</a>
<a name="ln2450">StartRsc(resource_t * rsc, node_t * next, gboolean optional, pe_working_set_t * data_set)</a>
<a name="ln2451">{</a>
<a name="ln2452">    action_t *start = NULL;</a>
<a name="ln2453"> </a>
<a name="ln2454">    CRM_ASSERT(rsc);</a>
<a name="ln2455">    pe_rsc_trace(rsc, &quot;%s on %s %d&quot;, rsc-&gt;id, next ? next-&gt;details-&gt;uname : &quot;N/A&quot;, optional);</a>
<a name="ln2456">    start = start_action(rsc, next, TRUE);</a>
<a name="ln2457">    if (is_set(start-&gt;flags, pe_action_runnable) &amp;&amp; optional == FALSE) {</a>
<a name="ln2458">        update_action_flags(start, pe_action_optional | pe_action_clear, __FUNCTION__, __LINE__);</a>
<a name="ln2459">    }</a>
<a name="ln2460">    return TRUE;</a>
<a name="ln2461">}</a>
<a name="ln2462"> </a>
<a name="ln2463">gboolean</a>
<a name="ln2464">PromoteRsc(resource_t * rsc, node_t * next, gboolean optional, pe_working_set_t * data_set)</a>
<a name="ln2465">{</a>
<a name="ln2466">    char *key = NULL;</a>
<a name="ln2467">    GListPtr gIter = NULL;</a>
<a name="ln2468">    gboolean runnable = TRUE;</a>
<a name="ln2469">    GListPtr action_list = NULL;</a>
<a name="ln2470"> </a>
<a name="ln2471">    CRM_ASSERT(rsc);</a>
<a name="ln2472">    CRM_CHECK(next != NULL, return FALSE);</a>
<a name="ln2473">    pe_rsc_trace(rsc, &quot;%s on %s&quot;, rsc-&gt;id, next-&gt;details-&gt;uname);</a>
<a name="ln2474"> </a>
<a name="ln2475">    key = start_key(rsc);</a>
<a name="ln2476">    action_list = find_actions_exact(rsc-&gt;actions, key, next);</a>
<a name="ln2477">    free(key);</a>
<a name="ln2478"> </a>
<a name="ln2479">    for (gIter = action_list; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2480">        action_t *start = (action_t *) gIter-&gt;data;</a>
<a name="ln2481"> </a>
<a name="ln2482">        if (is_set(start-&gt;flags, pe_action_runnable) == FALSE) {</a>
<a name="ln2483">            runnable = FALSE;</a>
<a name="ln2484">        }</a>
<a name="ln2485">    }</a>
<a name="ln2486">    g_list_free(action_list);</a>
<a name="ln2487"> </a>
<a name="ln2488">    if (runnable) {</a>
<a name="ln2489">        promote_action(rsc, next, optional);</a>
<a name="ln2490">        return TRUE;</a>
<a name="ln2491">    }</a>
<a name="ln2492"> </a>
<a name="ln2493">    pe_rsc_debug(rsc, &quot;%s\tPromote %s (canceled)&quot;, next-&gt;details-&gt;uname, rsc-&gt;id);</a>
<a name="ln2494"> </a>
<a name="ln2495">    key = promote_key(rsc);</a>
<a name="ln2496">    action_list = find_actions_exact(rsc-&gt;actions, key, next);</a>
<a name="ln2497">    free(key);</a>
<a name="ln2498"> </a>
<a name="ln2499">    for (gIter = action_list; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2500">        action_t *promote = (action_t *) gIter-&gt;data;</a>
<a name="ln2501"> </a>
<a name="ln2502">        update_action_flags(promote, pe_action_runnable | pe_action_clear, __FUNCTION__, __LINE__);</a>
<a name="ln2503">    }</a>
<a name="ln2504"> </a>
<a name="ln2505">    g_list_free(action_list);</a>
<a name="ln2506">    return TRUE;</a>
<a name="ln2507">}</a>
<a name="ln2508"> </a>
<a name="ln2509">gboolean</a>
<a name="ln2510">DemoteRsc(resource_t * rsc, node_t * next, gboolean optional, pe_working_set_t * data_set)</a>
<a name="ln2511">{</a>
<a name="ln2512">    GListPtr gIter = NULL;</a>
<a name="ln2513"> </a>
<a name="ln2514">    CRM_ASSERT(rsc);</a>
<a name="ln2515">    pe_rsc_trace(rsc, &quot;%s&quot;, rsc-&gt;id);</a>
<a name="ln2516"> </a>
<a name="ln2517">/* 	CRM_CHECK(rsc-&gt;next_role == RSC_ROLE_SLAVE, return FALSE); */</a>
<a name="ln2518">    for (gIter = rsc-&gt;running_on; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2519">        node_t *current = (node_t *) gIter-&gt;data;</a>
<a name="ln2520"> </a>
<a name="ln2521">        pe_rsc_trace(rsc, &quot;%s on %s&quot;, rsc-&gt;id, next ? next-&gt;details-&gt;uname : &quot;N/A&quot;);</a>
<a name="ln2522">        demote_action(rsc, current, optional);</a>
<a name="ln2523">    }</a>
<a name="ln2524">    return TRUE;</a>
<a name="ln2525">}</a>
<a name="ln2526"> </a>
<a name="ln2527">gboolean</a>
<a name="ln2528">RoleError(resource_t * rsc, node_t * next, gboolean optional, pe_working_set_t * data_set)</a>
<a name="ln2529">{</a>
<a name="ln2530">    CRM_ASSERT(rsc);</a>
<a name="ln2531">    crm_err(&quot;%s on %s&quot;, rsc-&gt;id, next ? next-&gt;details-&gt;uname : &quot;N/A&quot;);</a>
<a name="ln2532">    CRM_CHECK(FALSE, return FALSE);</a>
<a name="ln2533">    return FALSE;</a>
<a name="ln2534">}</a>
<a name="ln2535"> </a>
<a name="ln2536">gboolean</a>
<a name="ln2537">NullOp(resource_t * rsc, node_t * next, gboolean optional, pe_working_set_t * data_set)</a>
<a name="ln2538">{</a>
<a name="ln2539">    CRM_ASSERT(rsc);</a>
<a name="ln2540">    pe_rsc_trace(rsc, &quot;%s&quot;, rsc-&gt;id);</a>
<a name="ln2541">    return FALSE;</a>
<a name="ln2542">}</a>
<a name="ln2543"> </a>
<a name="ln2544">gboolean</a>
<a name="ln2545">DeleteRsc(resource_t * rsc, node_t * node, gboolean optional, pe_working_set_t * data_set)</a>
<a name="ln2546">{</a>
<a name="ln2547">    if (is_set(rsc-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln2548">        pe_rsc_trace(rsc, &quot;Resource %s not deleted from %s: failed&quot;, rsc-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln2549">        return FALSE;</a>
<a name="ln2550"> </a>
<a name="ln2551">    } else if (node == NULL) {</a>
<a name="ln2552">        pe_rsc_trace(rsc, &quot;Resource %s not deleted: NULL node&quot;, rsc-&gt;id);</a>
<a name="ln2553">        return FALSE;</a>
<a name="ln2554"> </a>
<a name="ln2555">    } else if (node-&gt;details-&gt;unclean || node-&gt;details-&gt;online == FALSE) {</a>
<a name="ln2556">        pe_rsc_trace(rsc, &quot;Resource %s not deleted from %s: unrunnable&quot;, rsc-&gt;id,</a>
<a name="ln2557">                     node-&gt;details-&gt;uname);</a>
<a name="ln2558">        return FALSE;</a>
<a name="ln2559">    }</a>
<a name="ln2560"> </a>
<a name="ln2561">    crm_notice(&quot;Removing %s from %s&quot;, rsc-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln2562"> </a>
<a name="ln2563">    delete_action(rsc, node, optional);</a>
<a name="ln2564"> </a>
<a name="ln2565">    new_rsc_order(rsc, RSC_STOP, rsc, RSC_DELETE,</a>
<a name="ln2566">                  optional ? pe_order_implies_then : pe_order_optional, data_set);</a>
<a name="ln2567"> </a>
<a name="ln2568">    new_rsc_order(rsc, RSC_DELETE, rsc, RSC_START,</a>
<a name="ln2569">                  optional ? pe_order_implies_then : pe_order_optional, data_set);</a>
<a name="ln2570"> </a>
<a name="ln2571">    return TRUE;</a>
<a name="ln2572">}</a>
<a name="ln2573"> </a>
<a name="ln2574">#include &lt;../lib/pengine/unpack.h&gt;</a>
<a name="ln2575">#define set_char(x) last_rsc_id[lpc] = x; complete = TRUE;</a>
<a name="ln2576">static char *</a>
<a name="ln2577">increment_clone(char *last_rsc_id)</a>
<a name="ln2578">{</a>
<a name="ln2579">    int lpc = 0;</a>
<a name="ln2580">    int len = 0;</a>
<a name="ln2581">    char *tmp = NULL;</a>
<a name="ln2582">    gboolean complete = FALSE;</a>
<a name="ln2583"> </a>
<a name="ln2584">    CRM_CHECK(last_rsc_id != NULL, return NULL);</a>
<a name="ln2585">    if (last_rsc_id != NULL) {</a>
<a name="ln2586">        len = strlen(last_rsc_id);</a>
<a name="ln2587">    }</a>
<a name="ln2588"> </a>
<a name="ln2589">    lpc = len - 1;</a>
<a name="ln2590">    while (complete == FALSE &amp;&amp; lpc &gt; 0) {</a>
<a name="ln2591">        switch (last_rsc_id[lpc]) {</a>
<a name="ln2592">            case 0:</a>
<a name="ln2593">                lpc--;</a>
<a name="ln2594">                break;</a>
<a name="ln2595">            case '0':</a>
<a name="ln2596">                set_char('1');</a>
<a name="ln2597">                break;</a>
<a name="ln2598">            case '1':</a>
<a name="ln2599">                set_char('2');</a>
<a name="ln2600">                break;</a>
<a name="ln2601">            case '2':</a>
<a name="ln2602">                set_char('3');</a>
<a name="ln2603">                break;</a>
<a name="ln2604">            case '3':</a>
<a name="ln2605">                set_char('4');</a>
<a name="ln2606">                break;</a>
<a name="ln2607">            case '4':</a>
<a name="ln2608">                set_char('5');</a>
<a name="ln2609">                break;</a>
<a name="ln2610">            case '5':</a>
<a name="ln2611">                set_char('6');</a>
<a name="ln2612">                break;</a>
<a name="ln2613">            case '6':</a>
<a name="ln2614">                set_char('7');</a>
<a name="ln2615">                break;</a>
<a name="ln2616">            case '7':</a>
<a name="ln2617">                set_char('8');</a>
<a name="ln2618">                break;</a>
<a name="ln2619">            case '8':</a>
<a name="ln2620">                set_char('9');</a>
<a name="ln2621">                break;</a>
<a name="ln2622">            case '9':</a>
<a name="ln2623">                last_rsc_id[lpc] = '0';</a>
<a name="ln2624">                lpc--;</a>
<a name="ln2625">                break;</a>
<a name="ln2626">            case ':':</a>
<a name="ln2627">                tmp = last_rsc_id;</a>
<a name="ln2628">                last_rsc_id = calloc(1, len + 2);</a>
<a name="ln2629">                memcpy(last_rsc_id, tmp, len);</a>
<a name="ln2630">                last_rsc_id[++lpc] = '1';</a>
<a name="ln2631">                last_rsc_id[len] = '0';</a>
<a name="ln2632">                last_rsc_id[len + 1] = 0;</a>
<a name="ln2633">                complete = TRUE;</a>
<a name="ln2634">                free(tmp);</a>
<a name="ln2635">                break;</a>
<a name="ln2636">            default:</a>
<a name="ln2637">                crm_err(&quot;Unexpected char: %c (%d)&quot;, last_rsc_id[lpc], lpc);</a>
<a name="ln2638">                return NULL;</a>
<a name="ln2639">                break;</a>
<a name="ln2640">        }</a>
<a name="ln2641">    }</a>
<a name="ln2642">    return last_rsc_id;</a>
<a name="ln2643">}</a>
<a name="ln2644"> </a>
<a name="ln2645">static node_t *</a>
<a name="ln2646">probe_grouped_clone(resource_t * rsc, node_t * node, pe_working_set_t * data_set)</a>
<a name="ln2647">{</a>
<a name="ln2648">    node_t *running = NULL;</a>
<a name="ln2649">    resource_t *top = uber_parent(rsc);</a>
<a name="ln2650"> </a>
<a name="ln2651">    if (running == NULL &amp;&amp; is_set(top-&gt;flags, pe_rsc_unique) == FALSE) {</a>
<a name="ln2652">        /* Annoyingly we also need to check any other clone instances</a>
<a name="ln2653">         * Clumsy, but it will work.</a>
<a name="ln2654">         *</a>
<a name="ln2655">         * An alternative would be to update known_on for every peer</a>
<a name="ln2656">         * during process_rsc_state()</a>
<a name="ln2657">         *</a>
<a name="ln2658">         * This code desperately needs optimization</a>
<a name="ln2659">         * ptest -x with 100 nodes, 100 clones and clone-max=10:</a>
<a name="ln2660">         *   No probes                          O(25s)</a>
<a name="ln2661">         *   Detection without clone loop               O(3m)</a>
<a name="ln2662">         *   Detection with clone loop                  O(8m)</a>
<a name="ln2663"> </a>
<a name="ln2664">         ptest[32211]: 2010/02/18_14:27:55 CRIT: stage5: Probing for unknown resources</a>
<a name="ln2665">         ptest[32211]: 2010/02/18_14:33:39 CRIT: stage5: Done</a>
<a name="ln2666">         ptest[32211]: 2010/02/18_14:35:05 CRIT: stage7: Updating action states</a>
<a name="ln2667">         ptest[32211]: 2010/02/18_14:35:05 CRIT: stage7: Done</a>
<a name="ln2668"> </a>
<a name="ln2669">         */</a>
<a name="ln2670">        char *clone_id = clone_zero(rsc-&gt;id);</a>
<a name="ln2671">        resource_t *peer = pe_find_resource(top-&gt;children, clone_id);</a>
<a name="ln2672"> </a>
<a name="ln2673">        while (peer &amp;&amp; running == NULL) {</a>
<a name="ln2674">            running = pe_hash_table_lookup(peer-&gt;known_on, node-&gt;details-&gt;id);</a>
<a name="ln2675">            if (running != NULL) {</a>
<a name="ln2676">                /* we already know the status of the resource on this node */</a>
<a name="ln2677">                pe_rsc_trace(rsc, &quot;Skipping active clone: %s&quot;, rsc-&gt;id);</a>
<a name="ln2678">                free(clone_id);</a>
<a name="ln2679">                return running;</a>
<a name="ln2680">            }</a>
<a name="ln2681">            clone_id = increment_clone(clone_id);</a>
<a name="ln2682">            peer = pe_find_resource(data_set-&gt;resources, clone_id);</a>
<a name="ln2683">        }</a>
<a name="ln2684"> </a>
<a name="ln2685">        free(clone_id);</a>
<a name="ln2686">    }</a>
<a name="ln2687">    return running;</a>
<a name="ln2688">}</a>
<a name="ln2689"> </a>
<a name="ln2690">gboolean</a>
<a name="ln2691">native_create_probe(resource_t * rsc, node_t * node, action_t * complete,</a>
<a name="ln2692">                    gboolean force, pe_working_set_t * data_set)</a>
<a name="ln2693">{</a>
<a name="ln2694">    enum pe_ordering flags = pe_order_optional;</a>
<a name="ln2695">    char *key = NULL;</a>
<a name="ln2696">    action_t *probe = NULL;</a>
<a name="ln2697">    node_t *running = NULL;</a>
<a name="ln2698">    node_t *allowed = NULL;</a>
<a name="ln2699">    resource_t *top = uber_parent(rsc);</a>
<a name="ln2700"> </a>
<a name="ln2701">    static const char *rc_master = NULL;</a>
<a name="ln2702">    static const char *rc_inactive = NULL;</a>
<a name="ln2703"> </a>
<a name="ln2704">    if (rc_inactive == NULL) {</a>
<a name="ln2705">        rc_inactive = crm_itoa(PCMK_OCF_NOT_RUNNING);</a>
<a name="ln2706">        rc_master = crm_itoa(PCMK_OCF_RUNNING_MASTER);</a>
<a name="ln2707">    }</a>
<a name="ln2708"> </a>
<a name="ln2709">    CRM_CHECK(node != NULL, return FALSE);</a>
<a name="ln2710">    if (force == FALSE &amp;&amp; is_not_set(data_set-&gt;flags, pe_flag_startup_probes)) {</a>
<a name="ln2711">        pe_rsc_trace(rsc, &quot;Skipping active resource detection for %s&quot;, rsc-&gt;id);</a>
<a name="ln2712">        return FALSE;</a>
<a name="ln2713">    } else if (force == FALSE &amp;&amp; is_container_remote_node(node)) {</a>
<a name="ln2714">        pe_rsc_trace(rsc, &quot;Skipping active resource detection for %s on container %s&quot;,</a>
<a name="ln2715">                     rsc-&gt;id, node-&gt;details-&gt;id);</a>
<a name="ln2716">        return FALSE;</a>
<a name="ln2717">    }</a>
<a name="ln2718"> </a>
<a name="ln2719">    if (is_remote_node(node)) {</a>
<a name="ln2720">        const char *class = crm_element_value(rsc-&gt;xml, XML_AGENT_ATTR_CLASS);</a>
<a name="ln2721"> </a>
<a name="ln2722">        if (safe_str_eq(class, PCMK_RESOURCE_CLASS_STONITH)) {</a>
<a name="ln2723">            pe_rsc_trace(rsc, &quot;Skipping probe for %s on node %s, remote-nodes do not run stonith agents.&quot;, rsc-&gt;id, node-&gt;details-&gt;id);</a>
<a name="ln2724">            return FALSE;</a>
<a name="ln2725">        } else if (rsc_contains_remote_node(data_set, rsc)) {</a>
<a name="ln2726">            pe_rsc_trace(rsc, &quot;Skipping probe for %s on node %s, remote-nodes can not run resources that contain connection resources.&quot;, rsc-&gt;id, node-&gt;details-&gt;id);</a>
<a name="ln2727">            return FALSE;</a>
<a name="ln2728">        } else if (rsc-&gt;is_remote_node) {</a>
<a name="ln2729">            pe_rsc_trace(rsc, &quot;Skipping probe for %s on node %s, remote-nodes can not run connection resources&quot;, rsc-&gt;id, node-&gt;details-&gt;id);</a>
<a name="ln2730">            return FALSE;</a>
<a name="ln2731">        }</a>
<a name="ln2732">    }</a>
<a name="ln2733"> </a>
<a name="ln2734">    if (rsc-&gt;children) {</a>
<a name="ln2735">        GListPtr gIter = NULL;</a>
<a name="ln2736">        gboolean any_created = FALSE;</a>
<a name="ln2737"> </a>
<a name="ln2738">        for (gIter = rsc-&gt;children; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2739">            resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln2740"> </a>
<a name="ln2741">            any_created = child_rsc-&gt;cmds-&gt;create_probe(child_rsc, node, complete, force, data_set)</a>
<a name="ln2742">                || any_created;</a>
<a name="ln2743">        }</a>
<a name="ln2744"> </a>
<a name="ln2745">        return any_created;</a>
<a name="ln2746"> </a>
<a name="ln2747">    } else if ((rsc-&gt;container) &amp;&amp; (!rsc-&gt;is_remote_node)) {</a>
<a name="ln2748">        pe_rsc_trace(rsc, &quot;Skipping %s: it is within container %s&quot;, rsc-&gt;id, rsc-&gt;container-&gt;id);</a>
<a name="ln2749">        return FALSE;</a>
<a name="ln2750">    }</a>
<a name="ln2751"> </a>
<a name="ln2752">    if (is_set(rsc-&gt;flags, pe_rsc_orphan)) {</a>
<a name="ln2753">        pe_rsc_trace(rsc, &quot;Skipping orphan: %s&quot;, rsc-&gt;id);</a>
<a name="ln2754">        return FALSE;</a>
<a name="ln2755">    }</a>
<a name="ln2756"> </a>
<a name="ln2757">    running = g_hash_table_lookup(rsc-&gt;known_on, node-&gt;details-&gt;id);</a>
<a name="ln2758">    if (running == NULL &amp;&amp; is_set(rsc-&gt;flags, pe_rsc_unique) == FALSE) {</a>
<a name="ln2759">        /* Anonymous clones */</a>
<a name="ln2760">        if (rsc-&gt;parent == top) {</a>
<a name="ln2761">            running = g_hash_table_lookup(rsc-&gt;parent-&gt;known_on, node-&gt;details-&gt;id);</a>
<a name="ln2762"> </a>
<a name="ln2763">        } else {</a>
<a name="ln2764">            /* Grouped anonymous clones need extra special handling */</a>
<a name="ln2765">            running = probe_grouped_clone(rsc, node, data_set);</a>
<a name="ln2766">        }</a>
<a name="ln2767">    }</a>
<a name="ln2768"> </a>
<a name="ln2769">    if (force == FALSE &amp;&amp; running != NULL) {</a>
<a name="ln2770">        /* we already know the status of the resource on this node */</a>
<a name="ln2771">        pe_rsc_trace(rsc, &quot;Skipping active: %s on %s&quot;, rsc-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln2772">        return FALSE;</a>
<a name="ln2773">    }</a>
<a name="ln2774"> </a>
<a name="ln2775">    allowed = g_hash_table_lookup(rsc-&gt;allowed_nodes, node-&gt;details-&gt;id);</a>
<a name="ln2776">    if (rsc-&gt;exclusive_discover || top-&gt;exclusive_discover) {</a>
<a name="ln2777">        if (allowed == NULL) {</a>
<a name="ln2778">            /* exclusive discover is enabled and this node is not in the allowed list. */    </a>
<a name="ln2779">            return FALSE;</a>
<a name="ln2780">        } else if (allowed-&gt;rsc_discover_mode != discover_exclusive) {</a>
<a name="ln2781">            /* exclusive discover is enabled and this node is not marked</a>
<a name="ln2782">             * as a node this resource should be discovered on */ </a>
<a name="ln2783">            return FALSE;</a>
<a name="ln2784">        }</a>
<a name="ln2785">    }</a>
<a name="ln2786">    if (allowed &amp;&amp; allowed-&gt;rsc_discover_mode == discover_never) {</a>
<a name="ln2787">        /* this resource is marked as not needing to be discovered on this node */</a>
<a name="ln2788">        return FALSE;</a>
<a name="ln2789">    }</a>
<a name="ln2790"> </a>
<a name="ln2791"> </a>
<a name="ln2792">    key = generate_op_key(rsc-&gt;id, RSC_STATUS, 0);</a>
<a name="ln2793">    probe = custom_action(rsc, key, RSC_STATUS, node, FALSE, TRUE, data_set);</a>
<a name="ln2794">    update_action_flags(probe, pe_action_optional | pe_action_clear, __FUNCTION__, __LINE__);</a>
<a name="ln2795"> </a>
<a name="ln2796">    /* If enabled, require unfencing before probing any fence devices</a>
<a name="ln2797">     * but ensure it happens after any resources that require</a>
<a name="ln2798">     * unfencing have been probed.</a>
<a name="ln2799">     *</a>
<a name="ln2800">     * Doing it the other way (requiring unfencing after probing</a>
<a name="ln2801">     * resources that need it) would result in the node being</a>
<a name="ln2802">     * unfenced, and all its resources being stopped, whenever a new</a>
<a name="ln2803">     * resource is added.  Which would be highly suboptimal.</a>
<a name="ln2804">     *</a>
<a name="ln2805">     * So essentially, at the point the fencing device(s) have been</a>
<a name="ln2806">     * probed, we know the state of all resources that require</a>
<a name="ln2807">     * unfencing and that unfencing occurred.</a>
<a name="ln2808">     */</a>
<a name="ln2809">    if(is_set(rsc-&gt;flags, pe_rsc_fence_device) &amp;&amp; is_set(data_set-&gt;flags, pe_flag_enable_unfencing)) {</a>
<a name="ln2810">        trigger_unfencing(NULL, node, &quot;node discovery&quot;, probe, data_set);</a>
<a name="ln2811">        probe-&gt;priority = INFINITY; /* Ensure this runs if unfencing succeeds */</a>
<a name="ln2812"> </a>
<a name="ln2813">    } else if(is_set(rsc-&gt;flags, pe_rsc_needs_unfencing)) {</a>
<a name="ln2814">        action_t *unfence = pe_fence_op(node, &quot;on&quot;, TRUE, data_set);</a>
<a name="ln2815"> </a>
<a name="ln2816">        order_actions(probe, unfence, pe_order_optional);</a>
<a name="ln2817">    }</a>
<a name="ln2818"> </a>
<a name="ln2819">    /*</a>
<a name="ln2820">     * We need to know if it's running_on (not just known_on) this node</a>
<a name="ln2821">     * to correctly determine the target rc.</a>
<a name="ln2822">     */</a>
<a name="ln2823">    running = pe_find_node_id(rsc-&gt;running_on, node-&gt;details-&gt;id);</a>
<a name="ln2824">    if (running == NULL) {</a>
<a name="ln2825">        add_hash_param(probe-&gt;meta, XML_ATTR_TE_TARGET_RC, rc_inactive);</a>
<a name="ln2826"> </a>
<a name="ln2827">    } else if (rsc-&gt;role == RSC_ROLE_MASTER) {</a>
<a name="ln2828">        add_hash_param(probe-&gt;meta, XML_ATTR_TE_TARGET_RC, rc_master);</a>
<a name="ln2829">    }</a>
<a name="ln2830"> </a>
<a name="ln2831">    crm_debug(&quot;Probing %s on %s (%s) %d %p&quot;, rsc-&gt;id, node-&gt;details-&gt;uname, role2text(rsc-&gt;role),</a>
<a name="ln2832">              is_set(probe-&gt;flags, pe_action_runnable), rsc-&gt;running_on);</a>
<a name="ln2833"> </a>
<a name="ln2834">    if(is_set(rsc-&gt;flags, pe_rsc_fence_device) &amp;&amp; is_set(data_set-&gt;flags, pe_flag_enable_unfencing)) {</a>
<a name="ln2835">        top = rsc;</a>
<a name="ln2836"> </a>
<a name="ln2837">    } else if (pe_rsc_is_clone(top) == FALSE) {</a>
<a name="ln2838">        top = rsc;</a>
<a name="ln2839"> </a>
<a name="ln2840">    } else {</a>
<a name="ln2841">        crm_trace(&quot;Probing %s on %s (%s) as %s&quot;, rsc-&gt;id, node-&gt;details-&gt;uname, role2text(rsc-&gt;role), top-&gt;id);</a>
<a name="ln2842">    }</a>
<a name="ln2843"> </a>
<a name="ln2844">    if(is_not_set(probe-&gt;flags, pe_action_runnable) &amp;&amp; rsc-&gt;running_on == NULL) {</a>
<a name="ln2845">        /* Prevent the start from occuring if rsc isn't active, but</a>
<a name="ln2846">         * don't cause it to stop if it was active already</a>
<a name="ln2847">         */</a>
<a name="ln2848">        flags |= pe_order_runnable_left;</a>
<a name="ln2849">    }</a>
<a name="ln2850"> </a>
<a name="ln2851">    custom_action_order(rsc, NULL, probe,</a>
<a name="ln2852">                        top, generate_op_key(top-&gt;id, RSC_START, 0), NULL,</a>
<a name="ln2853">                        flags, data_set);</a>
<a name="ln2854"> </a>
<a name="ln2855">    /* Before any reloads, if they exist */</a>
<a name="ln2856">    custom_action_order(rsc, NULL, probe,</a>
<a name="ln2857">                        top, reload_key(rsc), NULL,</a>
<a name="ln2858">                        pe_order_optional, data_set);</a>
<a name="ln2859">    </a>
<a name="ln2860">    if (node-&gt;details-&gt;shutdown == FALSE) {</a>
<a name="ln2861">        custom_action_order(rsc, NULL, probe,</a>
<a name="ln2862">                            rsc, generate_op_key(rsc-&gt;id, RSC_STOP, 0), NULL,</a>
<a name="ln2863">                            pe_order_optional, data_set);</a>
<a name="ln2864">    }</a>
<a name="ln2865"> </a>
<a name="ln2866">    if(is_set(rsc-&gt;flags, pe_rsc_fence_device) &amp;&amp; is_set(data_set-&gt;flags, pe_flag_enable_unfencing)) {</a>
<a name="ln2867">        /* Normally rsc.start depends on probe complete which depends</a>
<a name="ln2868">         * on rsc.probe. But this can't be the case in this scenario as</a>
<a name="ln2869">         * it would create graph loops.</a>
<a name="ln2870">         *</a>
<a name="ln2871">         * So instead we explicitly order 'rsc.probe then rsc.start'</a>
<a name="ln2872">         */</a>
<a name="ln2873"> </a>
<a name="ln2874">    } else {</a>
<a name="ln2875">        order_actions(probe, complete, pe_order_implies_then);</a>
<a name="ln2876">    }</a>
<a name="ln2877">    return TRUE;</a>
<a name="ln2878">}</a>
<a name="ln2879"> </a>
<a name="ln2880">static void</a>
<a name="ln2881">native_start_constraints(resource_t * rsc, action_t * stonith_op, pe_working_set_t * data_set)</a>
<a name="ln2882">{</a>
<a name="ln2883">    node_t *target;</a>
<a name="ln2884">    GListPtr gIter = NULL;</a>
<a name="ln2885">    action_t *all_stopped = get_pseudo_op(ALL_STOPPED, data_set);</a>
<a name="ln2886">    action_t *stonith_done = get_pseudo_op(STONITH_DONE, data_set);</a>
<a name="ln2887"> </a>
<a name="ln2888">    CRM_CHECK(stonith_op &amp;&amp; stonith_op-&gt;node, return);</a>
<a name="ln2889">    target = stonith_op-&gt;node;</a>
<a name="ln2890"> </a>
<a name="ln2891">    for (gIter = rsc-&gt;actions; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2892">        action_t *action = (action_t *) gIter-&gt;data;</a>
<a name="ln2893"> </a>
<a name="ln2894">        if(action-&gt;needs == rsc_req_nothing) {</a>
<a name="ln2895">            /* Anything other than start or promote requires nothing */</a>
<a name="ln2896"> </a>
<a name="ln2897">        } else if (action-&gt;needs == rsc_req_stonith) {</a>
<a name="ln2898">            order_actions(stonith_done, action, pe_order_optional);</a>
<a name="ln2899"> </a>
<a name="ln2900">        } else if (safe_str_eq(action-&gt;task, RSC_START)</a>
<a name="ln2901">                   &amp;&amp; NULL == pe_hash_table_lookup(rsc-&gt;known_on, target-&gt;details-&gt;id)) {</a>
<a name="ln2902">            /* if known == NULL, then we don't know if</a>
<a name="ln2903">             *   the resource is active on the node</a>
<a name="ln2904">             *   we're about to shoot</a>
<a name="ln2905">             *</a>
<a name="ln2906">             * in this case, regardless of action-&gt;needs,</a>
<a name="ln2907">             *   the only safe option is to wait until</a>
<a name="ln2908">             *   the node is shot before doing anything</a>
<a name="ln2909">             *   to with the resource</a>
<a name="ln2910">             *</a>
<a name="ln2911">             * it's analogous to waiting for all the probes</a>
<a name="ln2912">             *   for rscX to complete before starting rscX</a>
<a name="ln2913">             *</a>
<a name="ln2914">             * the most likely explanation is that the</a>
<a name="ln2915">             *   DC died and took its status with it</a>
<a name="ln2916">             */</a>
<a name="ln2917"> </a>
<a name="ln2918">            pe_rsc_debug(rsc, &quot;Ordering %s after %s recovery&quot;, action-&gt;uuid,</a>
<a name="ln2919">                         target-&gt;details-&gt;uname);</a>
<a name="ln2920">            order_actions(all_stopped, action, pe_order_optional | pe_order_runnable_left);</a>
<a name="ln2921">        }</a>
<a name="ln2922">    }</a>
<a name="ln2923">}</a>
<a name="ln2924"> </a>
<a name="ln2925">static void</a>
<a name="ln2926">native_stop_constraints(resource_t * rsc, action_t * stonith_op, pe_working_set_t * data_set)</a>
<a name="ln2927">{</a>
<a name="ln2928">    char *key = NULL;</a>
<a name="ln2929">    GListPtr gIter = NULL;</a>
<a name="ln2930">    GListPtr action_list = NULL;</a>
<a name="ln2931"> </a>
<a name="ln2932">    action_t *start = NULL;</a>
<a name="ln2933">    resource_t *top = uber_parent(rsc);</a>
<a name="ln2934">    node_t *target;</a>
<a name="ln2935"> </a>
<a name="ln2936">    CRM_CHECK(stonith_op &amp;&amp; stonith_op-&gt;node, return);</a>
<a name="ln2937">    target = stonith_op-&gt;node;</a>
<a name="ln2938"> </a>
<a name="ln2939">    /* Check whether the resource has a pending start action */</a>
<a name="ln2940">    start = find_first_action(rsc-&gt;actions, NULL, CRMD_ACTION_START, NULL);</a>
<a name="ln2941"> </a>
<a name="ln2942">    /* Get a list of stop actions potentially implied by the fencing */</a>
<a name="ln2943">    key = stop_key(rsc);</a>
<a name="ln2944">    action_list = find_actions(rsc-&gt;actions, key, target);</a>
<a name="ln2945">    free(key);</a>
<a name="ln2946"> </a>
<a name="ln2947">    for (gIter = action_list; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2948">        action_t *action = (action_t *) gIter-&gt;data;</a>
<a name="ln2949"> </a>
<a name="ln2950">        if (is_set(rsc-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln2951">            crm_notice(&quot;Stop of failed resource %s is implicit after %s is fenced&quot;,</a>
<a name="ln2952">                       rsc-&gt;id, target-&gt;details-&gt;uname);</a>
<a name="ln2953">        } else {</a>
<a name="ln2954">            crm_info(&quot;%s is implicit after %s is fenced&quot;,</a>
<a name="ln2955">                     action-&gt;uuid, target-&gt;details-&gt;uname);</a>
<a name="ln2956">        }</a>
<a name="ln2957"> </a>
<a name="ln2958">        /* The stop would never complete and is now implied by the fencing,</a>
<a name="ln2959">         * so convert it into a pseudo-action.</a>
<a name="ln2960">         */</a>
<a name="ln2961">        update_action_flags(action, pe_action_pseudo, __FUNCTION__, __LINE__);</a>
<a name="ln2962">        update_action_flags(action, pe_action_runnable, __FUNCTION__, __LINE__);</a>
<a name="ln2963">        update_action_flags(action, pe_action_implied_by_stonith, __FUNCTION__, __LINE__);</a>
<a name="ln2964"> </a>
<a name="ln2965">        if(start == NULL || start-&gt;needs &gt; rsc_req_quorum) {</a>
<a name="ln2966">            enum pe_ordering flags = pe_order_optional;</a>
<a name="ln2967">            action_t *parent_stop = find_first_action(top-&gt;actions, NULL, RSC_STOP, NULL);</a>
<a name="ln2968"> </a>
<a name="ln2969">            if (target-&gt;details-&gt;remote_rsc) {</a>
<a name="ln2970">                /* User constraints must not order a resource in a guest node</a>
<a name="ln2971">                 * relative to the guest node container resource. This flag</a>
<a name="ln2972">                 * marks constraints as generated by the cluster and thus</a>
<a name="ln2973">                 * immune to that check.</a>
<a name="ln2974">                 */</a>
<a name="ln2975">                flags |= pe_order_preserve;</a>
<a name="ln2976">            }</a>
<a name="ln2977">            order_actions(stonith_op, action, flags);</a>
<a name="ln2978">            order_actions(stonith_op, parent_stop, flags);</a>
<a name="ln2979">        }</a>
<a name="ln2980"> </a>
<a name="ln2981">        if (is_set(rsc-&gt;flags, pe_rsc_notify)) {</a>
<a name="ln2982">            /* Create a second notification that will be delivered</a>
<a name="ln2983">             *   immediately after the node is fenced</a>
<a name="ln2984">             *</a>
<a name="ln2985">             * Basic problem:</a>
<a name="ln2986">             * - C is a clone active on the node to be shot and stopping on another</a>
<a name="ln2987">             * - R is a resource that depends on C</a>
<a name="ln2988">             *</a>
<a name="ln2989">             * + C.stop depends on R.stop</a>
<a name="ln2990">             * + C.stopped depends on STONITH</a>
<a name="ln2991">             * + C.notify depends on C.stopped</a>
<a name="ln2992">             * + C.healthy depends on C.notify</a>
<a name="ln2993">             * + R.stop depends on C.healthy</a>
<a name="ln2994">             *</a>
<a name="ln2995">             * The extra notification here changes</a>
<a name="ln2996">             *  + C.healthy depends on C.notify</a>
<a name="ln2997">             * into:</a>
<a name="ln2998">             *  + C.healthy depends on C.notify'</a>
<a name="ln2999">             *  + C.notify' depends on STONITH'</a>
<a name="ln3000">             * thus breaking the loop</a>
<a name="ln3001">             */</a>
<a name="ln3002">            create_secondary_notification(action, rsc, stonith_op, data_set);</a>
<a name="ln3003">        }</a>
<a name="ln3004"> </a>
<a name="ln3005">/* From Bug #1601, successful fencing must be an input to a failed resources stop action.</a>
<a name="ln3006"> </a>
<a name="ln3007">   However given group(rA, rB) running on nodeX and B.stop has failed,</a>
<a name="ln3008">   A := stop healthy resource (rA.stop)</a>
<a name="ln3009">   B := stop failed resource (pseudo operation B.stop)</a>
<a name="ln3010">   C := stonith nodeX</a>
<a name="ln3011">   A requires B, B requires C, C requires A</a>
<a name="ln3012">   This loop would prevent the cluster from making progress.</a>
<a name="ln3013"> </a>
<a name="ln3014">   This block creates the &quot;C requires A&quot; dependency and therefore must (at least</a>
<a name="ln3015">   for now) be disabled.</a>
<a name="ln3016"> </a>
<a name="ln3017">   Instead, run the block above and treat all resources on nodeX as B would be</a>
<a name="ln3018">   (marked as a pseudo op depending on the STONITH).</a>
<a name="ln3019"> </a>
<a name="ln3020">   TODO: Break the &quot;A requires B&quot; dependency in update_action() and re-enable this block</a>
<a name="ln3021"> </a>
<a name="ln3022">   } else if(is_stonith == FALSE) {</a>
<a name="ln3023">   crm_info(&quot;Moving healthy resource %s&quot;</a>
<a name="ln3024">   &quot; off %s before fencing&quot;,</a>
<a name="ln3025">   rsc-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln3026"> </a>
<a name="ln3027">   * stop healthy resources before the</a>
<a name="ln3028">   * stonith op</a>
<a name="ln3029">   *</a>
<a name="ln3030">   custom_action_order(</a>
<a name="ln3031">   rsc, stop_key(rsc), NULL,</a>
<a name="ln3032">   NULL,strdup(CRM_OP_FENCE),stonith_op,</a>
<a name="ln3033">   pe_order_optional, data_set);</a>
<a name="ln3034">*/</a>
<a name="ln3035">    }</a>
<a name="ln3036"> </a>
<a name="ln3037">    g_list_free(action_list);</a>
<a name="ln3038"> </a>
<a name="ln3039">    /* Get a list of demote actions potentially implied by the fencing */</a>
<a name="ln3040">    key = demote_key(rsc);</a>
<a name="ln3041">    action_list = find_actions(rsc-&gt;actions, key, target);</a>
<a name="ln3042">    free(key);</a>
<a name="ln3043"> </a>
<a name="ln3044">    for (gIter = action_list; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln3045">        action_t *action = (action_t *) gIter-&gt;data;</a>
<a name="ln3046"> </a>
<a name="ln3047">        if (action-&gt;node-&gt;details-&gt;online == FALSE || action-&gt;node-&gt;details-&gt;unclean == TRUE</a>
<a name="ln3048">            || is_set(rsc-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln3049"> </a>
<a name="ln3050">            if (is_set(rsc-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln3051">                pe_rsc_info(rsc,</a>
<a name="ln3052">                            &quot;Demote of failed resource %s is implicit after %s is fenced&quot;,</a>
<a name="ln3053">                            rsc-&gt;id, target-&gt;details-&gt;uname);</a>
<a name="ln3054">            } else {</a>
<a name="ln3055">                pe_rsc_info(rsc, &quot;%s is implicit after %s is fenced&quot;,</a>
<a name="ln3056">                            action-&gt;uuid, target-&gt;details-&gt;uname);</a>
<a name="ln3057">            }</a>
<a name="ln3058"> </a>
<a name="ln3059">            /* The demote would never complete and is now implied by the</a>
<a name="ln3060">             * fencing, so convert it into a pseudo-action.</a>
<a name="ln3061">             */</a>
<a name="ln3062">            update_action_flags(action, pe_action_pseudo, __FUNCTION__, __LINE__);</a>
<a name="ln3063">            update_action_flags(action, pe_action_runnable, __FUNCTION__, __LINE__);</a>
<a name="ln3064"> </a>
<a name="ln3065">            if (start == NULL || start-&gt;needs &gt; rsc_req_quorum) {</a>
<a name="ln3066">                order_actions(stonith_op, action, pe_order_preserve|pe_order_optional);</a>
<a name="ln3067">            }</a>
<a name="ln3068">        }</a>
<a name="ln3069">    }</a>
<a name="ln3070"> </a>
<a name="ln3071">    g_list_free(action_list);</a>
<a name="ln3072">}</a>
<a name="ln3073"> </a>
<a name="ln3074">void</a>
<a name="ln3075">rsc_stonith_ordering(resource_t * rsc, action_t * stonith_op, pe_working_set_t * data_set)</a>
<a name="ln3076">{</a>
<a name="ln3077">    if (rsc-&gt;children) {</a>
<a name="ln3078">        GListPtr gIter = NULL;</a>
<a name="ln3079"> </a>
<a name="ln3080">        for (gIter = rsc-&gt;children; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln3081">            resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln3082"> </a>
<a name="ln3083">            rsc_stonith_ordering(child_rsc, stonith_op, data_set);</a>
<a name="ln3084">        }</a>
<a name="ln3085"> </a>
<a name="ln3086">    } else if (is_not_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln3087">        pe_rsc_trace(rsc, &quot;Skipping fencing constraints for unmanaged resource: %s&quot;, rsc-&gt;id);</a>
<a name="ln3088"> </a>
<a name="ln3089">    } else {</a>
<a name="ln3090">        native_start_constraints(rsc, stonith_op, data_set);</a>
<a name="ln3091">        native_stop_constraints(rsc, stonith_op, data_set);</a>
<a name="ln3092">    }</a>
<a name="ln3093">}</a>
<a name="ln3094"> </a>
<a name="ln3095">enum stack_activity {</a>
<a name="ln3096">    stack_stable = 0,</a>
<a name="ln3097">    stack_starting = 1,</a>
<a name="ln3098">    stack_stopping = 2,</a>
<a name="ln3099">    stack_middle = 4,</a>
<a name="ln3100">};</a>
<a name="ln3101"> </a>
<a name="ln3102">static action_t *</a>
<a name="ln3103">get_first_named_action(resource_t * rsc, const char *action, gboolean only_valid, node_t * current)</a>
<a name="ln3104">{</a>
<a name="ln3105">    action_t *a = NULL;</a>
<a name="ln3106">    GListPtr action_list = NULL;</a>
<a name="ln3107">    char *key = generate_op_key(rsc-&gt;id, action, 0);</a>
<a name="ln3108"> </a>
<a name="ln3109">    action_list = find_actions(rsc-&gt;actions, key, current);</a>
<a name="ln3110"> </a>
<a name="ln3111">    if (action_list == NULL || action_list-&gt;data == NULL) {</a>
<a name="ln3112">        crm_trace(&quot;%s: no %s action&quot;, rsc-&gt;id, action);</a>
<a name="ln3113">        free(key);</a>
<a name="ln3114">        return NULL;</a>
<a name="ln3115">    }</a>
<a name="ln3116"> </a>
<a name="ln3117">    a = action_list-&gt;data;</a>
<a name="ln3118">    g_list_free(action_list);</a>
<a name="ln3119"> </a>
<a name="ln3120">    if (only_valid &amp;&amp; is_set(a-&gt;flags, pe_action_pseudo)) {</a>
<a name="ln3121">        crm_trace(&quot;%s: pseudo&quot;, key);</a>
<a name="ln3122">        a = NULL;</a>
<a name="ln3123"> </a>
<a name="ln3124">    } else if (only_valid &amp;&amp; is_not_set(a-&gt;flags, pe_action_runnable)) {</a>
<a name="ln3125">        crm_trace(&quot;%s: runnable&quot;, key);</a>
<a name="ln3126">        a = NULL;</a>
<a name="ln3127">    }</a>
<a name="ln3128"> </a>
<a name="ln3129">    free(key);</a>
<a name="ln3130">    return a;</a>
<a name="ln3131">}</a>
<a name="ln3132"> </a>
<a name="ln3133">void</a>
<a name="ln3134">ReloadRsc(resource_t * rsc, node_t *node, pe_working_set_t * data_set)</a>
<a name="ln3135">{</a>
<a name="ln3136">    GListPtr gIter = NULL;</a>
<a name="ln3137">    action_t *other = NULL;</a>
<a name="ln3138">    action_t *reload = NULL;</a>
<a name="ln3139"> </a>
<a name="ln3140">    if (rsc-&gt;children) {</a>
<a name="ln3141">        for (gIter = rsc-&gt;children; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln3142">            resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln3143"> </a>
<a name="ln3144">            ReloadRsc(child_rsc, node, data_set);</a>
<a name="ln3145">        }</a>
<a name="ln3146">        return;</a>
<a name="ln3147"> </a>
<a name="ln3148">    } else if (rsc-&gt;variant &gt; pe_native) {</a>
<a name="ln3149">        /* Complex resource with no children */</a>
<a name="ln3150">        return;</a>
<a name="ln3151"> </a>
<a name="ln3152">    } else if (is_not_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln3153">        pe_rsc_trace(rsc, &quot;%s: unmanaged&quot;, rsc-&gt;id);</a>
<a name="ln3154">        return;</a>
<a name="ln3155"> </a>
<a name="ln3156">    } else if (is_set(rsc-&gt;flags, pe_rsc_failed) || is_set(rsc-&gt;flags, pe_rsc_start_pending)) {</a>
<a name="ln3157">        pe_rsc_trace(rsc, &quot;%s: general resource state: flags=0x%.16llx&quot;, rsc-&gt;id, rsc-&gt;flags);</a>
<a name="ln3158">        stop_action(rsc, node, FALSE); /* Force a full restart, overkill? */</a>
<a name="ln3159">        return;</a>
<a name="ln3160"> </a>
<a name="ln3161">    } else if (node == NULL) {</a>
<a name="ln3162">        pe_rsc_trace(rsc, &quot;%s: not active&quot;, rsc-&gt;id);</a>
<a name="ln3163">        return;</a>
<a name="ln3164">    }</a>
<a name="ln3165"> </a>
<a name="ln3166">    pe_rsc_trace(rsc, &quot;Processing %s&quot;, rsc-&gt;id);</a>
<a name="ln3167">    set_bit(rsc-&gt;flags, pe_rsc_reload);</a>
<a name="ln3168">    </a>
<a name="ln3169">    reload = custom_action(</a>
<a name="ln3170">        rsc, reload_key(rsc), CRMD_ACTION_RELOAD, node, FALSE, TRUE, data_set);</a>
<a name="ln3171"> </a>
<a name="ln3172">    /* stop = stop_action(rsc, node, optional); */</a>
<a name="ln3173">    other = get_first_named_action(rsc, RSC_STOP, TRUE, node);</a>
<a name="ln3174">    if (other != NULL) {</a>
<a name="ln3175">        order_actions(reload, other, pe_order_optional);</a>
<a name="ln3176">    }</a>
<a name="ln3177"> </a>
<a name="ln3178">    other = get_first_named_action(rsc, RSC_DEMOTE, TRUE, node);</a>
<a name="ln3179">    if (other != NULL) {</a>
<a name="ln3180">        order_actions(reload, other, pe_order_optional);</a>
<a name="ln3181">    }</a>
<a name="ln3182">}</a>
<a name="ln3183"> </a>
<a name="ln3184">void</a>
<a name="ln3185">native_append_meta(resource_t * rsc, xmlNode * xml)</a>
<a name="ln3186">{</a>
<a name="ln3187">    char *value = g_hash_table_lookup(rsc-&gt;meta, XML_RSC_ATTR_INCARNATION);</a>
<a name="ln3188">    resource_t *iso_parent, *last_parent, *parent;</a>
<a name="ln3189"> </a>
<a name="ln3190">    if (value) {</a>
<a name="ln3191">        char *name = NULL;</a>
<a name="ln3192"> </a>
<a name="ln3193">        name = crm_meta_name(XML_RSC_ATTR_INCARNATION);</a>
<a name="ln3194">        crm_xml_add(xml, name, value);</a>
<a name="ln3195">        free(name);</a>
<a name="ln3196">    }</a>
<a name="ln3197"> </a>
<a name="ln3198">    value = g_hash_table_lookup(rsc-&gt;meta, XML_RSC_ATTR_REMOTE_NODE);</a>
<a name="ln3199">    if (value) {</a>
<a name="ln3200">        char *name = NULL;</a>
<a name="ln3201"> </a>
<a name="ln3202">        name = crm_meta_name(XML_RSC_ATTR_REMOTE_NODE);</a>
<a name="ln3203">        crm_xml_add(xml, name, value);</a>
<a name="ln3204">        free(name);</a>
<a name="ln3205">    }</a>
<a name="ln3206"> </a>
<a name="ln3207">    for (parent = rsc; parent != NULL; parent = parent-&gt;parent) {</a>
<a name="ln3208">        if (parent-&gt;container) {</a>
<a name="ln3209">            crm_xml_add(xml, CRM_META&quot;_&quot;XML_RSC_ATTR_CONTAINER, parent-&gt;container-&gt;id);</a>
<a name="ln3210">        }</a>
<a name="ln3211">    }</a>
<a name="ln3212"> </a>
<a name="ln3213">    last_parent = iso_parent = rsc;</a>
<a name="ln3214">    while (iso_parent != NULL) {</a>
<a name="ln3215">        char *name = NULL;</a>
<a name="ln3216">        char *iso = NULL;</a>
<a name="ln3217"> </a>
<a name="ln3218">        if (iso_parent-&gt;isolation_wrapper == NULL) {</a>
<a name="ln3219">            last_parent = iso_parent;</a>
<a name="ln3220">            iso_parent = iso_parent-&gt;parent;</a>
<a name="ln3221">            continue;</a>
<a name="ln3222">        }</a>
<a name="ln3223"> </a>
<a name="ln3224">        /* name of wrapper script this resource is routed through. */</a>
<a name="ln3225">        name = crm_meta_name(XML_RSC_ATTR_ISOLATION_WRAPPER);</a>
<a name="ln3226">        crm_xml_add(xml, name, iso_parent-&gt;isolation_wrapper);</a>
<a name="ln3227">        free(name);</a>
<a name="ln3228"> </a>
<a name="ln3229">        /* instance name for isolated environment */</a>
<a name="ln3230">        name = crm_meta_name(XML_RSC_ATTR_ISOLATION_INSTANCE);</a>
<a name="ln3231">        if (pe_rsc_is_clone(iso_parent)) { </a>
<a name="ln3232">            /* if isolation is set at the clone/master level, we have to </a>
<a name="ln3233">             * give this resource the unique isolation instance associated</a>
<a name="ln3234">             * with the clone child (last_parent)*/</a>
<a name="ln3235"> </a>
<a name="ln3236">            /* Example: cloned group. group is container</a>
<a name="ln3237">             * clone myclone - iso_parent</a>
<a name="ln3238">             *    group mygroup - last_parent (this is the iso environment)</a>
<a name="ln3239">             *       rsc myrsc1 - rsc</a>
<a name="ln3240">             *       rsc myrsc2</a>
<a name="ln3241">             * The group is what is isolated in example1. We have to make</a>
<a name="ln3242">             * sure myrsc1 and myrsc2 launch in the same isolated environment.</a>
<a name="ln3243">             *</a>
<a name="ln3244">             * Example: cloned primitives. rsc primitive is container</a>
<a name="ln3245">             * clone myclone iso_parent</a>
<a name="ln3246">             *     rsc myrsc1 - last_parent == rsc (this is the iso environment)</a>
<a name="ln3247">             * The individual cloned primitive instances are isolated</a>
<a name="ln3248">             */</a>
<a name="ln3249">            value = g_hash_table_lookup(last_parent-&gt;meta, XML_RSC_ATTR_INCARNATION);</a>
<a name="ln3250">            CRM_ASSERT(value != NULL);</a>
<a name="ln3251"> </a>
<a name="ln3252">            iso = crm_concat(crm_element_value(last_parent-&gt;xml, XML_ATTR_ID), value, '_');</a>
<a name="ln3253">            crm_xml_add(xml, name, iso);</a>
<a name="ln3254">            free(iso);</a>
<a name="ln3255">        } else { </a>
<a name="ln3256">            /*</a>
<a name="ln3257">             * Example: cloned group of containers</a>
<a name="ln3258">             * clone myclone</a>
<a name="ln3259">             *    group mygroup</a>
<a name="ln3260">             *       rsc myrsc1 - iso_parent (this is the iso environment)</a>
<a name="ln3261">             *       rsc myrsc2</a>
<a name="ln3262">             *</a>
<a name="ln3263">             * Example: group of containers</a>
<a name="ln3264">             * group mygroup</a>
<a name="ln3265">             *   rsc myrsc1 - iso_parent (this is the iso environment)</a>
<a name="ln3266">             *   rsc myrsc2</a>
<a name="ln3267">             * </a>
<a name="ln3268">             * Example: group is container</a>
<a name="ln3269">             * group mygroup - iso_parent ( this is iso environment)</a>
<a name="ln3270">             *   rsc myrsc1 </a>
<a name="ln3271">             *   rsc myrsc2</a>
<a name="ln3272">             *</a>
<a name="ln3273">             * Example: single primitive</a>
<a name="ln3274">             * rsc myrsc1 - iso_parent (this is the iso environment)</a>
<a name="ln3275">             */</a>
<a name="ln3276">            value = g_hash_table_lookup(iso_parent-&gt;meta, XML_RSC_ATTR_INCARNATION);</a>
<a name="ln3277">            if (value) {</a>
<a name="ln3278">                crm_xml_add(xml, name, iso_parent-&gt;id);</a>
<a name="ln3279">                iso = crm_concat(crm_element_value(iso_parent-&gt;xml, XML_ATTR_ID), value, '_');</a>
<a name="ln3280">                crm_xml_add(xml, name, iso);</a>
<a name="ln3281">                free(iso);</a>
<a name="ln3282">            } else {</a>
<a name="ln3283">                crm_xml_add(xml, name, iso_parent-&gt;id);</a>
<a name="ln3284">            }</a>
<a name="ln3285">        }</a>
<a name="ln3286">        free(name);</a>
<a name="ln3287"> </a>
<a name="ln3288">        break;</a>
<a name="ln3289">    }</a>
<a name="ln3290">}</a>

</code></pre>
<div class="balloon" rel="967"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V547/" target="_blank">V547</a> Expression 'probe_complete_ops' is always false.</p></div>
<div class="balloon" rel="1276"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V547/" target="_blank">V547</a> Expression 'rsc' is always true.</p></div>
<div class="balloon" rel="2264"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V560/" target="_blank">V560</a> A part of conditional expression is always true: start.</p></div>
<div class="balloon" rel="2455"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V547/" target="_blank">V547</a> Expression 'rsc' is always true.</p></div>
<div class="balloon" rel="2521"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V547/" target="_blank">V547</a> Expression 'rsc' is always true.</p></div>
<div class="balloon" rel="2629"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 2629, 2628.</p></div>
<div class="balloon" rel="2651"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V560/" target="_blank">V560</a> A part of conditional expression is always true: running == NULL.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
