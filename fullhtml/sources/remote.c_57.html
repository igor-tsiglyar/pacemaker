
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (C) 2004 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * This program is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2 of the License, or (at your option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This software is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;crm_internal.h&gt;</a>
<a name="ln24">#include &lt;crm/crm.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;sys/param.h&gt;</a>
<a name="ln27">#include &lt;stdio.h&gt;</a>
<a name="ln28">#include &lt;sys/types.h&gt;</a>
<a name="ln29">#include &lt;sys/stat.h&gt;</a>
<a name="ln30">#include &lt;unistd.h&gt;</a>
<a name="ln31">#include &lt;sys/socket.h&gt;</a>
<a name="ln32">#include &lt;arpa/inet.h&gt;</a>
<a name="ln33"> </a>
<a name="ln34">#include &lt;netinet/ip.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">#include &lt;stdlib.h&gt;</a>
<a name="ln37">#include &lt;errno.h&gt;</a>
<a name="ln38">#include &lt;fcntl.h&gt;</a>
<a name="ln39">#include &lt;glib.h&gt;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;crm/msg_xml.h&gt;</a>
<a name="ln42">#include &lt;crm/common/ipc.h&gt;</a>
<a name="ln43">#include &lt;crm/common/ipcs.h&gt;</a>
<a name="ln44">#include &lt;crm/common/xml.h&gt;</a>
<a name="ln45">#include &lt;crm/cib/internal.h&gt;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;callbacks.h&quot;</a>
<a name="ln48">/* #undef HAVE_PAM_PAM_APPL_H */</a>
<a name="ln49">/* #undef HAVE_GNUTLS_GNUTLS_H */</a>
<a name="ln50"> </a>
<a name="ln51">#ifdef HAVE_GNUTLS_GNUTLS_H</a>
<a name="ln52">#  undef KEYFILE</a>
<a name="ln53">#  include &lt;gnutls/gnutls.h&gt;</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">#include &lt;pwd.h&gt;</a>
<a name="ln57">#include &lt;grp.h&gt;</a>
<a name="ln58">#if HAVE_SECURITY_PAM_APPL_H</a>
<a name="ln59">#  include &lt;security/pam_appl.h&gt;</a>
<a name="ln60">#  define HAVE_PAM 1</a>
<a name="ln61">#else</a>
<a name="ln62">#  if HAVE_PAM_PAM_APPL_H</a>
<a name="ln63">#    include &lt;pam/pam_appl.h&gt;</a>
<a name="ln64">#    define HAVE_PAM 1</a>
<a name="ln65">#  endif</a>
<a name="ln66">#endif</a>
<a name="ln67"> </a>
<a name="ln68">extern int remote_tls_fd;</a>
<a name="ln69">extern gboolean cib_shutdown_flag;</a>
<a name="ln70"> </a>
<a name="ln71">int init_remote_listener(int port, gboolean encrypted);</a>
<a name="ln72">void cib_remote_connection_destroy(gpointer user_data);</a>
<a name="ln73"> </a>
<a name="ln74">#ifdef HAVE_GNUTLS_GNUTLS_H</a>
<a name="ln75">#  define DH_BITS 1024</a>
<a name="ln76">gnutls_dh_params_t dh_params;</a>
<a name="ln77">gnutls_anon_server_credentials_t anon_cred_s;</a>
<a name="ln78">static void</a>
<a name="ln79">debug_log(int level, const char *str)</a>
<a name="ln80">{</a>
<a name="ln81">    fputs(str, stderr);</a>
<a name="ln82">}</a>
<a name="ln83">#endif</a>
<a name="ln84"> </a>
<a name="ln85">#define REMOTE_AUTH_TIMEOUT 10000</a>
<a name="ln86"> </a>
<a name="ln87">int num_clients;</a>
<a name="ln88">int authenticate_user(const char *user, const char *passwd);</a>
<a name="ln89">int cib_remote_listen(gpointer data);</a>
<a name="ln90">int cib_remote_msg(gpointer data);</a>
<a name="ln91"> </a>
<a name="ln92">static void</a>
<a name="ln93">remote_connection_destroy(gpointer user_data)</a>
<a name="ln94">{</a>
<a name="ln95">    return;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">#define ERROR_SUFFIX &quot;  Shutting down remote listener&quot;</a>
<a name="ln99">int</a>
<a name="ln100">init_remote_listener(int port, gboolean encrypted)</a>
<a name="ln101">{</a>
<a name="ln102">    int rc;</a>
<a name="ln103">    int *ssock = NULL;</a>
<a name="ln104">    struct sockaddr_in saddr;</a>
<a name="ln105">    int optval;</a>
<a name="ln106"> </a>
<a name="ln107">    static struct mainloop_fd_callbacks remote_listen_fd_callbacks = {</a>
<a name="ln108">        .dispatch = cib_remote_listen,</a>
<a name="ln109">        .destroy = remote_connection_destroy,</a>
<a name="ln110">    };</a>
<a name="ln111"> </a>
<a name="ln112">    if (port &lt;= 0) {</a>
<a name="ln113">        /* don't start it */</a>
<a name="ln114">        return 0;</a>
<a name="ln115">    }</a>
<a name="ln116"> </a>
<a name="ln117">    if (encrypted) {</a>
<a name="ln118">#ifndef HAVE_GNUTLS_GNUTLS_H</a>
<a name="ln119">        crm_warn(&quot;TLS support is not available&quot;);</a>
<a name="ln120">        return 0;</a>
<a name="ln121">#else</a>
<a name="ln122">        crm_notice(&quot;Starting a tls listener on port %d.&quot;, port);</a>
<a name="ln123">        crm_gnutls_global_init();</a>
<a name="ln124">        /* gnutls_global_set_log_level (10); */</a>
<a name="ln125">        gnutls_global_set_log_function(debug_log);</a>
<a name="ln126">        gnutls_dh_params_init(&amp;dh_params);</a>
<a name="ln127">        gnutls_dh_params_generate2(dh_params, DH_BITS);</a>
<a name="ln128">        gnutls_anon_allocate_server_credentials(&amp;anon_cred_s);</a>
<a name="ln129">        gnutls_anon_set_server_dh_params(anon_cred_s, dh_params);</a>
<a name="ln130">#endif</a>
<a name="ln131">    } else {</a>
<a name="ln132">        crm_warn(&quot;Starting a plain_text listener on port %d.&quot;, port);</a>
<a name="ln133">    }</a>
<a name="ln134">#ifndef HAVE_PAM</a>
<a name="ln135">    crm_warn(&quot;PAM is _not_ enabled!&quot;);</a>
<a name="ln136">#endif</a>
<a name="ln137"> </a>
<a name="ln138">    /* create server socket */</a>
<a name="ln139">    ssock = malloc(sizeof(int));</a>
<a name="ln140">    if(ssock == NULL) {</a>
<a name="ln141">        crm_perror(LOG_ERR, &quot;Can not create server socket.&quot; ERROR_SUFFIX);</a>
<a name="ln142">        return -1;</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">    *ssock = socket(AF_INET, SOCK_STREAM, 0);</a>
<a name="ln146">    if (*ssock == -1) {</a>
<a name="ln147">        crm_perror(LOG_ERR, &quot;Can not create server socket.&quot; ERROR_SUFFIX);</a>
<a name="ln148">        free(ssock);</a>
<a name="ln149">        return -1;</a>
<a name="ln150">    }</a>
<a name="ln151"> </a>
<a name="ln152">    /* reuse address */</a>
<a name="ln153">    optval = 1;</a>
<a name="ln154">    rc = setsockopt(*ssock, SOL_SOCKET, SO_REUSEADDR, &amp;optval, sizeof(optval));</a>
<a name="ln155">    if (rc &lt; 0) {</a>
<a name="ln156">        crm_perror(LOG_INFO, &quot;Couldn't allow the reuse of local addresses by our remote listener&quot;);</a>
<a name="ln157">    }</a>
<a name="ln158"> </a>
<a name="ln159">    /* bind server socket */</a>
<a name="ln160">    memset(&amp;saddr, '\0', sizeof(saddr));</a>
<a name="ln161">    saddr.sin_family = AF_INET;</a>
<a name="ln162">    saddr.sin_addr.s_addr = INADDR_ANY;</a>
<a name="ln163">    saddr.sin_port = htons(port);</a>
<a name="ln164">    if (bind(*ssock, (struct sockaddr *)&amp;saddr, sizeof(saddr)) == -1) {</a>
<a name="ln165">        crm_perror(LOG_ERR, &quot;Can not bind server socket.&quot; ERROR_SUFFIX);</a>
<a name="ln166">        close(*ssock);</a>
<a name="ln167">        free(ssock);</a>
<a name="ln168">        return -2;</a>
<a name="ln169">    }</a>
<a name="ln170">    if (listen(*ssock, 10) == -1) {</a>
<a name="ln171">        crm_perror(LOG_ERR, &quot;Can not start listen.&quot; ERROR_SUFFIX);</a>
<a name="ln172">        close(*ssock);</a>
<a name="ln173">        free(ssock);</a>
<a name="ln174">        return -3;</a>
<a name="ln175">    }</a>
<a name="ln176"> </a>
<a name="ln177">    mainloop_add_fd(&quot;cib-remote&quot;, G_PRIORITY_DEFAULT, *ssock, ssock, &amp;remote_listen_fd_callbacks);</a>
<a name="ln178"> </a>
<a name="ln179">    return *ssock;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">static int</a>
<a name="ln183">check_group_membership(const char *usr, const char *grp)</a>
<a name="ln184">{</a>
<a name="ln185">    int index = 0;</a>
<a name="ln186">    struct passwd *pwd = NULL;</a>
<a name="ln187">    struct group *group = NULL;</a>
<a name="ln188"> </a>
<a name="ln189">    CRM_CHECK(usr != NULL, return FALSE);</a>
<a name="ln190">    CRM_CHECK(grp != NULL, return FALSE);</a>
<a name="ln191"> </a>
<a name="ln192">    pwd = getpwnam(usr);</a>
<a name="ln193">    if (pwd == NULL) {</a>
<a name="ln194">        crm_err(&quot;No user named '%s' exists!&quot;, usr);</a>
<a name="ln195">        return FALSE;</a>
<a name="ln196">    }</a>
<a name="ln197"> </a>
<a name="ln198">    group = getgrgid(pwd-&gt;pw_gid);</a>
<a name="ln199">    if (group != NULL &amp;&amp; crm_str_eq(grp, group-&gt;gr_name, TRUE)) {</a>
<a name="ln200">        return TRUE;</a>
<a name="ln201">    }</a>
<a name="ln202"> </a>
<a name="ln203">    group = getgrnam(grp);</a>
<a name="ln204">    if (group == NULL) {</a>
<a name="ln205">        crm_err(&quot;No group named '%s' exists!&quot;, grp);</a>
<a name="ln206">        return FALSE;</a>
<a name="ln207">    }</a>
<a name="ln208"> </a>
<a name="ln209">    while (TRUE) {</a>
<a name="ln210">        char *member = group-&gt;gr_mem[index++];</a>
<a name="ln211"> </a>
<a name="ln212">        if (member == NULL) {</a>
<a name="ln213">            break;</a>
<a name="ln214"> </a>
<a name="ln215">        } else if (crm_str_eq(usr, member, TRUE)) {</a>
<a name="ln216">            return TRUE;</a>
<a name="ln217">        }</a>
<a name="ln218">    };</a>
<a name="ln219"> </a>
<a name="ln220">    return FALSE;</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">static gboolean</a>
<a name="ln224">cib_remote_auth(xmlNode * login)</a>
<a name="ln225">{</a>
<a name="ln226">    const char *user = NULL;</a>
<a name="ln227">    const char *pass = NULL;</a>
<a name="ln228">    const char *tmp = NULL;</a>
<a name="ln229"> </a>
<a name="ln230">    crm_log_xml_info(login, &quot;Login: &quot;);</a>
<a name="ln231">    if (login == NULL) {</a>
<a name="ln232">        return FALSE;</a>
<a name="ln233">    }</a>
<a name="ln234"> </a>
<a name="ln235">    tmp = crm_element_name(login);</a>
<a name="ln236">    if (safe_str_neq(tmp, &quot;cib_command&quot;)) {</a>
<a name="ln237">        crm_err(&quot;Wrong tag: %s&quot;, tmp);</a>
<a name="ln238">        return FALSE;</a>
<a name="ln239">    }</a>
<a name="ln240"> </a>
<a name="ln241">    tmp = crm_element_value(login, &quot;op&quot;);</a>
<a name="ln242">    if (safe_str_neq(tmp, &quot;authenticate&quot;)) {</a>
<a name="ln243">        crm_err(&quot;Wrong operation: %s&quot;, tmp);</a>
<a name="ln244">        return FALSE;</a>
<a name="ln245">    }</a>
<a name="ln246"> </a>
<a name="ln247">    user = crm_element_value(login, &quot;user&quot;);</a>
<a name="ln248">    pass = crm_element_value(login, &quot;password&quot;);</a>
<a name="ln249"> </a>
<a name="ln250">    if (!user || !pass) {</a>
<a name="ln251">        crm_err(&quot;missing auth credentials&quot;);</a>
<a name="ln252">        return FALSE;</a>
<a name="ln253">    }</a>
<a name="ln254"> </a>
<a name="ln255">    /* Non-root daemons can only validate the password of the</a>
<a name="ln256">     * user they're running as</a>
<a name="ln257">     */</a>
<a name="ln258">    if (check_group_membership(user, CRM_DAEMON_GROUP) == FALSE) {</a>
<a name="ln259">        crm_err(&quot;User is not a member of the required group&quot;);</a>
<a name="ln260">        return FALSE;</a>
<a name="ln261"> </a>
<a name="ln262">    } else if (authenticate_user(user, pass) == FALSE) {</a>
<a name="ln263">        crm_err(&quot;PAM auth failed&quot;);</a>
<a name="ln264">        return FALSE;</a>
<a name="ln265">    }</a>
<a name="ln266"> </a>
<a name="ln267">    return TRUE;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">static gboolean</a>
<a name="ln271">remote_auth_timeout_cb(gpointer data)</a>
<a name="ln272">{</a>
<a name="ln273">    crm_client_t *client = data;</a>
<a name="ln274"> </a>
<a name="ln275">    client-&gt;remote-&gt;auth_timeout = 0;</a>
<a name="ln276"> </a>
<a name="ln277">    if (client-&gt;remote-&gt;authenticated == TRUE) {</a>
<a name="ln278">        return FALSE;</a>
<a name="ln279">    }</a>
<a name="ln280"> </a>
<a name="ln281">    mainloop_del_fd(client-&gt;remote-&gt;source);</a>
<a name="ln282">    crm_err(&quot;Remote client authentication timed out&quot;);</a>
<a name="ln283"> </a>
<a name="ln284">    return FALSE;</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">int</a>
<a name="ln288">cib_remote_listen(gpointer data)</a>
<a name="ln289">{</a>
<a name="ln290">    int csock = 0;</a>
<a name="ln291">    unsigned laddr;</a>
<a name="ln292">    struct sockaddr_storage addr;</a>
<a name="ln293">    char ipstr[INET6_ADDRSTRLEN];</a>
<a name="ln294">    int ssock = *(int *)data;</a>
<a name="ln295">    int flag;</a>
<a name="ln296"> </a>
<a name="ln297">    crm_client_t *new_client = NULL;</a>
<a name="ln298"> </a>
<a name="ln299">    static struct mainloop_fd_callbacks remote_client_fd_callbacks = {</a>
<a name="ln300">        .dispatch = cib_remote_msg,</a>
<a name="ln301">        .destroy = cib_remote_connection_destroy,</a>
<a name="ln302">    };</a>
<a name="ln303"> </a>
<a name="ln304">    /* accept the connection */</a>
<a name="ln305">    laddr = sizeof(addr);</a>
<a name="ln306">    memset(&amp;addr, 0, sizeof(addr));</a>
<a name="ln307">    csock = accept(ssock, (struct sockaddr *)&amp;addr, &amp;laddr);</a>
<a name="ln308">    if (csock == -1) {</a>
<a name="ln309">        crm_perror(LOG_ERR, &quot;Could not accept socket connection&quot;);</a>
<a name="ln310">        return TRUE;</a>
<a name="ln311">    }</a>
<a name="ln312"> </a>
<a name="ln313">    crm_sockaddr2str(&amp;addr, ipstr);</a>
<a name="ln314">    crm_debug(&quot;New %s connection from %s&quot;,</a>
<a name="ln315">              ((ssock == remote_tls_fd)? &quot;secure&quot; : &quot;clear-text&quot;), ipstr);</a>
<a name="ln316"> </a>
<a name="ln317">    if ((flag = fcntl(csock, F_GETFL)) &gt;= 0) {</a>
<a name="ln318">        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) &lt; 0) {</a>
<a name="ln319">            crm_err(&quot;fcntl() write failed&quot;);</a>
<a name="ln320">            close(csock);</a>
<a name="ln321">            return TRUE;</a>
<a name="ln322">        }</a>
<a name="ln323">    } else {</a>
<a name="ln324">        crm_err(&quot;fcntl() read failed&quot;);</a>
<a name="ln325">        close(csock);</a>
<a name="ln326">        return TRUE;</a>
<a name="ln327">    }</a>
<a name="ln328"> </a>
<a name="ln329">    num_clients++;</a>
<a name="ln330"> </a>
<a name="ln331">    crm_client_init();</a>
<a name="ln332">    new_client = calloc(1, sizeof(crm_client_t));</a>
<a name="ln333">    new_client-&gt;remote = calloc(1, sizeof(crm_remote_t));</a>
<a name="ln334"> </a>
<a name="ln335">    new_client-&gt;id = crm_generate_uuid();</a>
<a name="ln336"> </a>
<a name="ln337">    g_hash_table_insert(client_connections, new_client-&gt;id /* Should work */ , new_client);</a>
<a name="ln338"> </a>
<a name="ln339">    if (ssock == remote_tls_fd) {</a>
<a name="ln340">#ifdef HAVE_GNUTLS_GNUTLS_H</a>
<a name="ln341">        new_client-&gt;kind = CRM_CLIENT_TLS;</a>
<a name="ln342"> </a>
<a name="ln343">        /* create gnutls session for the server socket */</a>
<a name="ln344">        new_client-&gt;remote-&gt;tls_session =</a>
<a name="ln345">            crm_create_anon_tls_session(csock, GNUTLS_SERVER, anon_cred_s);</a>
<a name="ln346"> </a>
<a name="ln347">        if (new_client-&gt;remote-&gt;tls_session == NULL) {</a>
<a name="ln348">            crm_err(&quot;TLS session creation failed&quot;);</a>
<a name="ln349">            close(csock);</a>
<a name="ln350">            return TRUE;</a>
<a name="ln351">        }</a>
<a name="ln352">#endif</a>
<a name="ln353">    } else {</a>
<a name="ln354">        new_client-&gt;kind = CRM_CLIENT_TCP;</a>
<a name="ln355">        new_client-&gt;remote-&gt;tcp_socket = csock;</a>
<a name="ln356">    }</a>
<a name="ln357"> </a>
<a name="ln358">    /* clients have a few seconds to perform handshake. */</a>
<a name="ln359">    new_client-&gt;remote-&gt;auth_timeout =</a>
<a name="ln360">        g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, new_client);</a>
<a name="ln361"> </a>
<a name="ln362">    new_client-&gt;remote-&gt;source =</a>
<a name="ln363">        mainloop_add_fd(&quot;cib-remote-client&quot;, G_PRIORITY_DEFAULT, csock, new_client,</a>
<a name="ln364">                        &amp;remote_client_fd_callbacks);</a>
<a name="ln365"> </a>
<a name="ln366">    return TRUE;</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369">void</a>
<a name="ln370">cib_remote_connection_destroy(gpointer user_data)</a>
<a name="ln371">{</a>
<a name="ln372">    crm_client_t *client = user_data;</a>
<a name="ln373">    int csock = 0;</a>
<a name="ln374"> </a>
<a name="ln375">    if (client == NULL) {</a>
<a name="ln376">        return;</a>
<a name="ln377">    }</a>
<a name="ln378"> </a>
<a name="ln379">    crm_trace(&quot;Cleaning up after client disconnect: %s/%s&quot;, crm_str(client-&gt;name), client-&gt;id);</a>
<a name="ln380"> </a>
<a name="ln381">    num_clients--;</a>
<a name="ln382">    crm_trace(&quot;Num unfree'd clients: %d&quot;, num_clients);</a>
<a name="ln383"> </a>
<a name="ln384">    switch (client-&gt;kind) {</a>
<a name="ln385">        case CRM_CLIENT_TCP:</a>
<a name="ln386">            csock = client-&gt;remote-&gt;tcp_socket;</a>
<a name="ln387">            break;</a>
<a name="ln388">#ifdef HAVE_GNUTLS_GNUTLS_H</a>
<a name="ln389">        case CRM_CLIENT_TLS:</a>
<a name="ln390">            if (client-&gt;remote-&gt;tls_session) {</a>
<a name="ln391">                void *sock_ptr = gnutls_transport_get_ptr(*client-&gt;remote-&gt;tls_session);</a>
<a name="ln392"> </a>
<a name="ln393">                csock = GPOINTER_TO_INT(sock_ptr);</a>
<a name="ln394">                if (client-&gt;remote-&gt;tls_handshake_complete) {</a>
<a name="ln395">                    gnutls_bye(*client-&gt;remote-&gt;tls_session, GNUTLS_SHUT_WR);</a>
<a name="ln396">                }</a>
<a name="ln397">                gnutls_deinit(*client-&gt;remote-&gt;tls_session);</a>
<a name="ln398">                gnutls_free(client-&gt;remote-&gt;tls_session);</a>
<a name="ln399">                client-&gt;remote-&gt;tls_session = NULL;</a>
<a name="ln400">            }</a>
<a name="ln401">            break;</a>
<a name="ln402">#endif</a>
<a name="ln403">        default:</a>
<a name="ln404">            crm_warn(&quot;Unexpected client type %d&quot;, client-&gt;kind);</a>
<a name="ln405">    }</a>
<a name="ln406"> </a>
<a name="ln407">    if (csock &gt; 0) {</a>
<a name="ln408">        close(csock);</a>
<a name="ln409">    }</a>
<a name="ln410"> </a>
<a name="ln411">    crm_client_destroy(client);</a>
<a name="ln412"> </a>
<a name="ln413">    crm_trace(&quot;Freed the cib client&quot;);</a>
<a name="ln414"> </a>
<a name="ln415">    if (cib_shutdown_flag) {</a>
<a name="ln416">        cib_shutdown(0);</a>
<a name="ln417">    }</a>
<a name="ln418">    return;</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">static void</a>
<a name="ln422">cib_handle_remote_msg(crm_client_t * client, xmlNode * command)</a>
<a name="ln423">{</a>
<a name="ln424">    const char *value = NULL;</a>
<a name="ln425"> </a>
<a name="ln426">    value = crm_element_name(command);</a>
<a name="ln427">    if (safe_str_neq(value, &quot;cib_command&quot;)) {</a>
<a name="ln428">        crm_log_xml_trace(command, &quot;Bad command: &quot;);</a>
<a name="ln429">        return;</a>
<a name="ln430">    }</a>
<a name="ln431"> </a>
<a name="ln432">    if (client-&gt;name == NULL) {</a>
<a name="ln433">        value = crm_element_value(command, F_CLIENTNAME);</a>
<a name="ln434">        if (value == NULL) {</a>
<a name="ln435">            client-&gt;name = strdup(client-&gt;id);</a>
<a name="ln436">        } else {</a>
<a name="ln437">            client-&gt;name = strdup(value);</a>
<a name="ln438">        }</a>
<a name="ln439">    }</a>
<a name="ln440"> </a>
<a name="ln441">    if (client-&gt;userdata == NULL) {</a>
<a name="ln442">        value = crm_element_value(command, F_CIB_CALLBACK_TOKEN);</a>
<a name="ln443">        if (value != NULL) {</a>
<a name="ln444">            client-&gt;userdata = strdup(value);</a>
<a name="ln445">            crm_trace(&quot;Callback channel for %s is %s&quot;, client-&gt;id, (char*)client-&gt;userdata);</a>
<a name="ln446"> </a>
<a name="ln447">        } else {</a>
<a name="ln448">            client-&gt;userdata = strdup(client-&gt;id);</a>
<a name="ln449">        }</a>
<a name="ln450">    }</a>
<a name="ln451"> </a>
<a name="ln452">    /* unset dangerous options */</a>
<a name="ln453">    xml_remove_prop(command, F_ORIG);</a>
<a name="ln454">    xml_remove_prop(command, F_CIB_HOST);</a>
<a name="ln455">    xml_remove_prop(command, F_CIB_GLOBAL_UPDATE);</a>
<a name="ln456"> </a>
<a name="ln457">    crm_xml_add(command, F_TYPE, T_CIB);</a>
<a name="ln458">    crm_xml_add(command, F_CIB_CLIENTID, client-&gt;id);</a>
<a name="ln459">    crm_xml_add(command, F_CIB_CLIENTNAME, client-&gt;name);</a>
<a name="ln460">#if ENABLE_ACL</a>
<a name="ln461">    crm_xml_add(command, F_CIB_USER, client-&gt;user);</a>
<a name="ln462">#endif</a>
<a name="ln463"> </a>
<a name="ln464">    if (crm_element_value(command, F_CIB_CALLID) == NULL) {</a>
<a name="ln465">        char *call_uuid = crm_generate_uuid();</a>
<a name="ln466"> </a>
<a name="ln467">        /* fix the command */</a>
<a name="ln468">        crm_xml_add(command, F_CIB_CALLID, call_uuid);</a>
<a name="ln469">        free(call_uuid);</a>
<a name="ln470">    }</a>
<a name="ln471"> </a>
<a name="ln472">    if (crm_element_value(command, F_CIB_CALLOPTS) == NULL) {</a>
<a name="ln473">        crm_xml_add_int(command, F_CIB_CALLOPTS, 0);</a>
<a name="ln474">    }</a>
<a name="ln475"> </a>
<a name="ln476">    crm_log_xml_trace(command, &quot;Remote command: &quot;);</a>
<a name="ln477">    cib_common_callback_worker(0, 0, command, client, TRUE);</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">int</a>
<a name="ln481">cib_remote_msg(gpointer data)</a>
<a name="ln482">{</a>
<a name="ln483">    xmlNode *command = NULL;</a>
<a name="ln484">    crm_client_t *client = data;</a>
<a name="ln485">    int disconnected = 0;</a>
<a name="ln486">    int timeout = client-&gt;remote-&gt;authenticated ? -1 : 1000;</a>
<a name="ln487"> </a>
<a name="ln488">    crm_trace(&quot;%s callback&quot;, client-&gt;kind != CRM_CLIENT_TCP ? &quot;secure&quot; : &quot;clear-text&quot;);</a>
<a name="ln489"> </a>
<a name="ln490">#ifdef HAVE_GNUTLS_GNUTLS_H</a>
<a name="ln491">    if (client-&gt;kind == CRM_CLIENT_TLS &amp;&amp; (client-&gt;remote-&gt;tls_handshake_complete == FALSE)) {</a>
<a name="ln492">        int rc = 0;</a>
<a name="ln493"> </a>
<a name="ln494">        /* Muliple calls to handshake will be required, this callback</a>
<a name="ln495">         * will be invoked once the client sends more handshake data. */</a>
<a name="ln496">        do {</a>
<a name="ln497">            rc = gnutls_handshake(*client-&gt;remote-&gt;tls_session);</a>
<a name="ln498"> </a>
<a name="ln499">            if (rc &lt; 0 &amp;&amp; rc != GNUTLS_E_AGAIN) {</a>
<a name="ln500">                crm_err(&quot;Remote cib tls handshake failed&quot;);</a>
<a name="ln501">                return -1;</a>
<a name="ln502">            }</a>
<a name="ln503">        } while (rc == GNUTLS_E_INTERRUPTED);</a>
<a name="ln504"> </a>
<a name="ln505">        if (rc == 0) {</a>
<a name="ln506">            crm_debug(&quot;Remote cib tls handshake completed&quot;);</a>
<a name="ln507">            client-&gt;remote-&gt;tls_handshake_complete = TRUE;</a>
<a name="ln508">            if (client-&gt;remote-&gt;auth_timeout) {</a>
<a name="ln509">                g_source_remove(client-&gt;remote-&gt;auth_timeout);</a>
<a name="ln510">            }</a>
<a name="ln511">            /* after handshake, clients must send auth in a few seconds */</a>
<a name="ln512">            client-&gt;remote-&gt;auth_timeout =</a>
<a name="ln513">                g_timeout_add(REMOTE_AUTH_TIMEOUT, remote_auth_timeout_cb, client);</a>
<a name="ln514">        }</a>
<a name="ln515">        return 0;</a>
<a name="ln516">    }</a>
<a name="ln517">#endif</a>
<a name="ln518"> </a>
<a name="ln519">    crm_remote_recv(client-&gt;remote, timeout, &amp;disconnected);</a>
<a name="ln520"> </a>
<a name="ln521">    /* must pass auth before we will process anything else */</a>
<a name="ln522">    if (client-&gt;remote-&gt;authenticated == FALSE) {</a>
<a name="ln523">        xmlNode *reg;</a>
<a name="ln524"> </a>
<a name="ln525">#if ENABLE_ACL</a>
<a name="ln526">        const char *user = NULL;</a>
<a name="ln527">#endif</a>
<a name="ln528">        command = crm_remote_parse_buffer(client-&gt;remote);</a>
<a name="ln529">        if (cib_remote_auth(command) == FALSE) {</a>
<a name="ln530">            free_xml(command);</a>
<a name="ln531">            return -1;</a>
<a name="ln532">        }</a>
<a name="ln533"> </a>
<a name="ln534">        crm_debug(&quot;remote connection authenticated successfully&quot;);</a>
<a name="ln535">        client-&gt;remote-&gt;authenticated = TRUE;</a>
<a name="ln536">        g_source_remove(client-&gt;remote-&gt;auth_timeout);</a>
<a name="ln537">        client-&gt;remote-&gt;auth_timeout = 0;</a>
<a name="ln538">        client-&gt;name = crm_element_value_copy(command, &quot;name&quot;);</a>
<a name="ln539"> </a>
<a name="ln540">#if ENABLE_ACL</a>
<a name="ln541">        user = crm_element_value(command, &quot;user&quot;);</a>
<a name="ln542">        if (user) {</a>
<a name="ln543">            client-&gt;user = strdup(user);</a>
<a name="ln544">        }</a>
<a name="ln545">#endif</a>
<a name="ln546"> </a>
<a name="ln547">        /* send ACK */</a>
<a name="ln548">        reg = create_xml_node(NULL, &quot;cib_result&quot;);</a>
<a name="ln549">        crm_xml_add(reg, F_CIB_OPERATION, CRM_OP_REGISTER);</a>
<a name="ln550">        crm_xml_add(reg, F_CIB_CLIENTID, client-&gt;id);</a>
<a name="ln551">        crm_remote_send(client-&gt;remote, reg);</a>
<a name="ln552">        free_xml(reg);</a>
<a name="ln553">        free_xml(command);</a>
<a name="ln554">    }</a>
<a name="ln555"> </a>
<a name="ln556">    command = crm_remote_parse_buffer(client-&gt;remote);</a>
<a name="ln557">    while (command) {</a>
<a name="ln558">        crm_trace(&quot;command received&quot;);</a>
<a name="ln559">        cib_handle_remote_msg(client, command);</a>
<a name="ln560">        free_xml(command);</a>
<a name="ln561">        command = crm_remote_parse_buffer(client-&gt;remote);</a>
<a name="ln562">    }</a>
<a name="ln563"> </a>
<a name="ln564">    if (disconnected) {</a>
<a name="ln565">        crm_trace(&quot;disconnected while receiving remote cib msg.&quot;);</a>
<a name="ln566">        return -1;</a>
<a name="ln567">    }</a>
<a name="ln568"> </a>
<a name="ln569">    return 0;</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">#ifdef HAVE_PAM</a>
<a name="ln573">/*</a>
<a name="ln574"> * Useful Examples:</a>
<a name="ln575"> *    http://www.kernel.org/pub/linux/libs/pam/Linux-PAM-html</a>
<a name="ln576"> *    http://developer.apple.com/samplecode/CryptNoMore/index.html</a>
<a name="ln577"> */</a>
<a name="ln578">static int</a>
<a name="ln579">construct_pam_passwd(int num_msg, const struct pam_message **msg,</a>
<a name="ln580">                     struct pam_response **response, void *data)</a>
<a name="ln581">{</a>
<a name="ln582">    int count = 0;</a>
<a name="ln583">    struct pam_response *reply;</a>
<a name="ln584">    char *string = (char *)data;</a>
<a name="ln585"> </a>
<a name="ln586">    CRM_CHECK(data, return PAM_CONV_ERR);</a>
<a name="ln587">    CRM_CHECK(num_msg == 1, return PAM_CONV_ERR);       /* We only want to handle one message */</a>
<a name="ln588"> </a>
<a name="ln589">    reply = calloc(1, sizeof(struct pam_response));</a>
<a name="ln590">    CRM_ASSERT(reply != NULL);</a>
<a name="ln591"> </a>
<a name="ln592">    for (count = 0; count &lt; num_msg; ++count) {</a>
<a name="ln593">        switch (msg[count]-&gt;msg_style) {</a>
<a name="ln594">            case PAM_TEXT_INFO:</a>
<a name="ln595">                crm_info(&quot;PAM: %s&quot;, msg[count]-&gt;msg);</a>
<a name="ln596">                break;</a>
<a name="ln597">            case PAM_PROMPT_ECHO_OFF:</a>
<a name="ln598">            case PAM_PROMPT_ECHO_ON:</a>
<a name="ln599">                reply[count].resp_retcode = 0;</a>
<a name="ln600">                reply[count].resp = string;     /* We already made a copy */</a>
<a name="ln601">            case PAM_ERROR_MSG:</a>
<a name="ln602">                /* In theory we'd want to print this, but then</a>
<a name="ln603">                 * we see the password prompt in the logs</a>
<a name="ln604">                 */</a>
<a name="ln605">                /* crm_err(&quot;PAM error: %s&quot;, msg[count]-&gt;msg); */</a>
<a name="ln606">                break;</a>
<a name="ln607">            default:</a>
<a name="ln608">                crm_err(&quot;Unhandled conversation type: %d&quot;, msg[count]-&gt;msg_style);</a>
<a name="ln609">                goto bail;</a>
<a name="ln610">        }</a>
<a name="ln611">    }</a>
<a name="ln612"> </a>
<a name="ln613">    *response = reply;</a>
<a name="ln614">    reply = NULL;</a>
<a name="ln615"> </a>
<a name="ln616">    return PAM_SUCCESS;</a>
<a name="ln617"> </a>
<a name="ln618">  bail:</a>
<a name="ln619">    for (count = 0; count &lt; num_msg; ++count) {</a>
<a name="ln620">        if (reply[count].resp != NULL) {</a>
<a name="ln621">            switch (msg[count]-&gt;msg_style) {</a>
<a name="ln622">                case PAM_PROMPT_ECHO_ON:</a>
<a name="ln623">                case PAM_PROMPT_ECHO_OFF:</a>
<a name="ln624">                    /* Erase the data - it contained a password */</a>
<a name="ln625">                    while (*(reply[count].resp)) {</a>
<a name="ln626">                        *(reply[count].resp)++ = '\0';</a>
<a name="ln627">                    }</a>
<a name="ln628">                    free(reply[count].resp);</a>
<a name="ln629">                    break;</a>
<a name="ln630">            }</a>
<a name="ln631">            reply[count].resp = NULL;</a>
<a name="ln632">        }</a>
<a name="ln633">    }</a>
<a name="ln634">    free(reply);</a>
<a name="ln635">    reply = NULL;</a>
<a name="ln636"> </a>
<a name="ln637">    return PAM_CONV_ERR;</a>
<a name="ln638">}</a>
<a name="ln639">#endif</a>
<a name="ln640"> </a>
<a name="ln641">int</a>
<a name="ln642">authenticate_user(const char *user, const char *passwd)</a>
<a name="ln643">{</a>
<a name="ln644">#ifndef HAVE_PAM</a>
<a name="ln645">    gboolean pass = TRUE;</a>
<a name="ln646">#else</a>
<a name="ln647">    int rc = 0;</a>
<a name="ln648">    gboolean pass = FALSE;</a>
<a name="ln649">    const void *p_user = NULL;</a>
<a name="ln650"> </a>
<a name="ln651">    struct pam_conv p_conv;</a>
<a name="ln652">    struct pam_handle *pam_h = NULL;</a>
<a name="ln653">    static const char *pam_name = NULL;</a>
<a name="ln654"> </a>
<a name="ln655">    if (pam_name == NULL) {</a>
<a name="ln656">        pam_name = getenv(&quot;CIB_pam_service&quot;);</a>
<a name="ln657">    }</a>
<a name="ln658">    if (pam_name == NULL) {</a>
<a name="ln659">        pam_name = &quot;login&quot;;</a>
<a name="ln660">    }</a>
<a name="ln661"> </a>
<a name="ln662">    p_conv.conv = construct_pam_passwd;</a>
<a name="ln663">    p_conv.appdata_ptr = strdup(passwd);</a>
<a name="ln664"> </a>
<a name="ln665">    rc = pam_start(pam_name, user, &amp;p_conv, &amp;pam_h);</a>
<a name="ln666">    if (rc != PAM_SUCCESS) {</a>
<a name="ln667">        crm_err(&quot;Could not initialize PAM: %s (%d)&quot;, pam_strerror(pam_h, rc), rc);</a>
<a name="ln668">        goto bail;</a>
<a name="ln669">    }</a>
<a name="ln670"> </a>
<a name="ln671">    rc = pam_authenticate(pam_h, 0);</a>
<a name="ln672">    if (rc != PAM_SUCCESS) {</a>
<a name="ln673">        crm_err(&quot;Authentication failed for %s: %s (%d)&quot;, user, pam_strerror(pam_h, rc), rc);</a>
<a name="ln674">        goto bail;</a>
<a name="ln675">    }</a>
<a name="ln676"> </a>
<a name="ln677">    /* Make sure we authenticated the user we wanted to authenticate.</a>
<a name="ln678">     * Since we also run as non-root, it might be worth pre-checking</a>
<a name="ln679">     * the user has the same EID as us, since that the only user we</a>
<a name="ln680">     * can authenticate.</a>
<a name="ln681">     */</a>
<a name="ln682">    rc = pam_get_item(pam_h, PAM_USER, &amp;p_user);</a>
<a name="ln683">    if (rc != PAM_SUCCESS) {</a>
<a name="ln684">        crm_err(&quot;Internal PAM error: %s (%d)&quot;, pam_strerror(pam_h, rc), rc);</a>
<a name="ln685">        goto bail;</a>
<a name="ln686"> </a>
<a name="ln687">    } else if (p_user == NULL) {</a>
<a name="ln688">        crm_err(&quot;Unknown user authenticated.&quot;);</a>
<a name="ln689">        goto bail;</a>
<a name="ln690"> </a>
<a name="ln691">    } else if (safe_str_neq(p_user, user)) {</a>
<a name="ln692">        crm_err(&quot;User mismatch: %s vs. %s.&quot;, (const char *)p_user, (const char *)user);</a>
<a name="ln693">        goto bail;</a>
<a name="ln694">    }</a>
<a name="ln695"> </a>
<a name="ln696">    rc = pam_acct_mgmt(pam_h, 0);</a>
<a name="ln697">    if (rc != PAM_SUCCESS) {</a>
<a name="ln698">        crm_err(&quot;Access denied: %s (%d)&quot;, pam_strerror(pam_h, rc), rc);</a>
<a name="ln699">        goto bail;</a>
<a name="ln700">    }</a>
<a name="ln701">    pass = TRUE;</a>
<a name="ln702"> </a>
<a name="ln703">  bail:</a>
<a name="ln704">    pam_end(pam_h, rc);</a>
<a name="ln705">#endif</a>
<a name="ln706">    return pass;</a>
<a name="ln707">}</a>

</code></pre>
<div class="balloon" rel="333"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'new_client'. Check lines: 333, 332.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
