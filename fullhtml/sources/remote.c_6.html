
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (c) 2008 Andrew Beekhof</a>
<a name="ln7"> *</a>
<a name="ln8"> * This library is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU Lesser General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2.1 of the License, or (at your option) any later version.</a>
<a name="ln12"> * </a>
<a name="ln13"> * This library is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * Lesser General Public License for more details.</a>
<a name="ln17"> * </a>
<a name="ln18"> * You should have received a copy of the GNU Lesser General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> *</a>
<a name="ln22"> */</a>
<a name="ln23">#include &lt;crm_internal.h&gt;</a>
<a name="ln24">#include &lt;crm/crm.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;sys/param.h&gt;</a>
<a name="ln27">#include &lt;stdio.h&gt;</a>
<a name="ln28">#include &lt;sys/types.h&gt;</a>
<a name="ln29">#include &lt;sys/stat.h&gt;</a>
<a name="ln30">#include &lt;unistd.h&gt;</a>
<a name="ln31">#include &lt;sys/socket.h&gt;</a>
<a name="ln32">#include &lt;arpa/inet.h&gt;</a>
<a name="ln33">#include &lt;netinet/in.h&gt;</a>
<a name="ln34">#include &lt;netinet/ip.h&gt;</a>
<a name="ln35">#include &lt;netinet/tcp.h&gt;</a>
<a name="ln36">#include &lt;netdb.h&gt;</a>
<a name="ln37"> </a>
<a name="ln38">#include &lt;stdlib.h&gt;</a>
<a name="ln39">#include &lt;errno.h&gt;</a>
<a name="ln40">#include &lt;fcntl.h&gt;</a>
<a name="ln41">#include &lt;glib.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;bzlib.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#include &lt;crm/common/ipcs.h&gt;</a>
<a name="ln46">#include &lt;crm/common/xml.h&gt;</a>
<a name="ln47">#include &lt;crm/common/mainloop.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">#ifdef HAVE_GNUTLS_GNUTLS_H</a>
<a name="ln50">#  undef KEYFILE</a>
<a name="ln51">#  include &lt;gnutls/gnutls.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">const int psk_tls_kx_order[] = {</a>
<a name="ln54">    GNUTLS_KX_DHE_PSK,</a>
<a name="ln55">    GNUTLS_KX_PSK,</a>
<a name="ln56">};</a>
<a name="ln57"> </a>
<a name="ln58">const int anon_tls_kx_order[] = {</a>
<a name="ln59">    GNUTLS_KX_ANON_DH,</a>
<a name="ln60">    GNUTLS_KX_DHE_RSA,</a>
<a name="ln61">    GNUTLS_KX_DHE_DSS,</a>
<a name="ln62">    GNUTLS_KX_RSA,</a>
<a name="ln63">    0</a>
<a name="ln64">};</a>
<a name="ln65">#endif</a>
<a name="ln66"> </a>
<a name="ln67">/* Swab macros from linux/swab.h */</a>
<a name="ln68">#ifdef HAVE_LINUX_SWAB_H</a>
<a name="ln69">#  include &lt;linux/swab.h&gt;</a>
<a name="ln70">#else</a>
<a name="ln71">/*</a>
<a name="ln72"> * casts are necessary for constants, because we never know how for sure</a>
<a name="ln73"> * how U/UL/ULL map to __u16, __u32, __u64. At least not in a portable way.</a>
<a name="ln74"> */</a>
<a name="ln75">#define __swab16(x) ((uint16_t)(                                      \</a>
<a name="ln76">        (((uint16_t)(x) &amp; (uint16_t)0x00ffU) &lt;&lt; 8) |                  \</a>
<a name="ln77">        (((uint16_t)(x) &amp; (uint16_t)0xff00U) &gt;&gt; 8)))</a>
<a name="ln78"> </a>
<a name="ln79">#define __swab32(x) ((uint32_t)(                                      \</a>
<a name="ln80">        (((uint32_t)(x) &amp; (uint32_t)0x000000ffUL) &lt;&lt; 24) |            \</a>
<a name="ln81">        (((uint32_t)(x) &amp; (uint32_t)0x0000ff00UL) &lt;&lt;  8) |            \</a>
<a name="ln82">        (((uint32_t)(x) &amp; (uint32_t)0x00ff0000UL) &gt;&gt;  8) |            \</a>
<a name="ln83">        (((uint32_t)(x) &amp; (uint32_t)0xff000000UL) &gt;&gt; 24)))</a>
<a name="ln84"> </a>
<a name="ln85">#define __swab64(x) ((uint64_t)(                                      \</a>
<a name="ln86">        (((uint64_t)(x) &amp; (uint64_t)0x00000000000000ffULL) &lt;&lt; 56) |   \</a>
<a name="ln87">        (((uint64_t)(x) &amp; (uint64_t)0x000000000000ff00ULL) &lt;&lt; 40) |   \</a>
<a name="ln88">        (((uint64_t)(x) &amp; (uint64_t)0x0000000000ff0000ULL) &lt;&lt; 24) |   \</a>
<a name="ln89">        (((uint64_t)(x) &amp; (uint64_t)0x00000000ff000000ULL) &lt;&lt;  8) |   \</a>
<a name="ln90">        (((uint64_t)(x) &amp; (uint64_t)0x000000ff00000000ULL) &gt;&gt;  8) |   \</a>
<a name="ln91">        (((uint64_t)(x) &amp; (uint64_t)0x0000ff0000000000ULL) &gt;&gt; 24) |   \</a>
<a name="ln92">        (((uint64_t)(x) &amp; (uint64_t)0x00ff000000000000ULL) &gt;&gt; 40) |   \</a>
<a name="ln93">        (((uint64_t)(x) &amp; (uint64_t)0xff00000000000000ULL) &gt;&gt; 56)))</a>
<a name="ln94">#endif</a>
<a name="ln95"> </a>
<a name="ln96">#define REMOTE_MSG_VERSION 1</a>
<a name="ln97">#define ENDIAN_LOCAL 0xBADADBBD</a>
<a name="ln98"> </a>
<a name="ln99">struct crm_remote_header_v0 </a>
<a name="ln100">{</a>
<a name="ln101">    uint32_t endian;    /* Detect messages from hosts with different endian-ness */</a>
<a name="ln102">    uint32_t version;</a>
<a name="ln103">    uint64_t id;</a>
<a name="ln104">    uint64_t flags;</a>
<a name="ln105">    uint32_t size_total;</a>
<a name="ln106">    uint32_t payload_offset;</a>
<a name="ln107">    uint32_t payload_compressed;</a>
<a name="ln108">    uint32_t payload_uncompressed;</a>
<a name="ln109"> </a>
<a name="ln110">        /* New fields get added here */</a>
<a name="ln111"> </a>
<a name="ln112">} __attribute__ ((packed));</a>
<a name="ln113"> </a>
<a name="ln114">static struct crm_remote_header_v0 *</a>
<a name="ln115">crm_remote_header(crm_remote_t * remote)</a>
<a name="ln116">{</a>
<a name="ln117">    struct crm_remote_header_v0 *header = (struct crm_remote_header_v0 *)remote-&gt;buffer;</a>
<a name="ln118">    if(remote-&gt;buffer_offset &lt; sizeof(struct crm_remote_header_v0)) {</a>
<a name="ln119">        return NULL;</a>
<a name="ln120"> </a>
<a name="ln121">    } else if(header-&gt;endian != ENDIAN_LOCAL) {</a>
<a name="ln122">        uint32_t endian = __swab32(header-&gt;endian);</a>
<a name="ln123"> </a>
<a name="ln124">        CRM_LOG_ASSERT(endian == ENDIAN_LOCAL);</a>
<a name="ln125">        if(endian != ENDIAN_LOCAL) {</a>
<a name="ln126">            crm_err(&quot;Invalid message detected, endian mismatch: %lx is neither %lx nor the swab'd %lx&quot;,</a>
<a name="ln127">                    ENDIAN_LOCAL, header-&gt;endian, endian);</a>
<a name="ln128">            return NULL;</a>
<a name="ln129">        }</a>
<a name="ln130"> </a>
<a name="ln131">        header-&gt;id = __swab64(header-&gt;id);</a>
<a name="ln132">        header-&gt;flags = __swab64(header-&gt;flags);</a>
<a name="ln133">        header-&gt;endian = __swab32(header-&gt;endian);</a>
<a name="ln134"> </a>
<a name="ln135">        header-&gt;version = __swab32(header-&gt;version);</a>
<a name="ln136">        header-&gt;size_total = __swab32(header-&gt;size_total);</a>
<a name="ln137">        header-&gt;payload_offset = __swab32(header-&gt;payload_offset);</a>
<a name="ln138">        header-&gt;payload_compressed = __swab32(header-&gt;payload_compressed);</a>
<a name="ln139">        header-&gt;payload_uncompressed = __swab32(header-&gt;payload_uncompressed);</a>
<a name="ln140">    }</a>
<a name="ln141"> </a>
<a name="ln142">    return header;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">#ifdef HAVE_GNUTLS_GNUTLS_H</a>
<a name="ln146"> </a>
<a name="ln147">int</a>
<a name="ln148">crm_initiate_client_tls_handshake(crm_remote_t * remote, int timeout_ms)</a>
<a name="ln149">{</a>
<a name="ln150">    int rc = 0;</a>
<a name="ln151">    int pollrc = 0;</a>
<a name="ln152">    time_t start = time(NULL);</a>
<a name="ln153"> </a>
<a name="ln154">    do {</a>
<a name="ln155">        rc = gnutls_handshake(*remote-&gt;tls_session);</a>
<a name="ln156">        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {</a>
<a name="ln157">            pollrc = crm_remote_ready(remote, 1000);</a>
<a name="ln158">            if (pollrc &lt; 0) {</a>
<a name="ln159">                /* poll returned error, there is no hope */</a>
<a name="ln160">                rc = -1;</a>
<a name="ln161">            }</a>
<a name="ln162">        }</a>
<a name="ln163"> </a>
<a name="ln164">    } while (((time(NULL) - start) &lt; (timeout_ms / 1000)) &amp;&amp;</a>
<a name="ln165">             (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN));</a>
<a name="ln166"> </a>
<a name="ln167">    if (rc &lt; 0) {</a>
<a name="ln168">        crm_trace(&quot;gnutls_handshake() failed with %d&quot;, rc);</a>
<a name="ln169">    }</a>
<a name="ln170">    return rc;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">void *</a>
<a name="ln174">crm_create_anon_tls_session(int csock, int type /* GNUTLS_SERVER, GNUTLS_CLIENT */ ,</a>
<a name="ln175">                            void *credentials)</a>
<a name="ln176">{</a>
<a name="ln177">    gnutls_session_t *session = gnutls_malloc(sizeof(gnutls_session_t));</a>
<a name="ln178"> </a>
<a name="ln179">    gnutls_init(session, type);</a>
<a name="ln180">#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT</a>
<a name="ln181">/*      http://www.manpagez.com/info/gnutls/gnutls-2.10.4/gnutls_81.php#Echo-Server-with-anonymous-authentication */</a>
<a name="ln182">    gnutls_priority_set_direct(*session, &quot;NORMAL:+ANON-DH&quot;, NULL);</a>
<a name="ln183">/*	gnutls_priority_set_direct (*session, &quot;NONE:+VERS-TLS-ALL:+CIPHER-ALL:+MAC-ALL:+SIGN-ALL:+COMP-ALL:+ANON-DH&quot;, NULL); */</a>
<a name="ln184">#  else</a>
<a name="ln185">    gnutls_set_default_priority(*session);</a>
<a name="ln186">    gnutls_kx_set_priority(*session, anon_tls_kx_order);</a>
<a name="ln187">#  endif</a>
<a name="ln188">    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr_t) GINT_TO_POINTER(csock));</a>
<a name="ln189">    switch (type) {</a>
<a name="ln190">        case GNUTLS_SERVER:</a>
<a name="ln191">            gnutls_credentials_set(*session, GNUTLS_CRD_ANON,</a>
<a name="ln192">                                   (gnutls_anon_server_credentials_t) credentials);</a>
<a name="ln193">            break;</a>
<a name="ln194">        case GNUTLS_CLIENT:</a>
<a name="ln195">            gnutls_credentials_set(*session, GNUTLS_CRD_ANON,</a>
<a name="ln196">                                   (gnutls_anon_client_credentials_t) credentials);</a>
<a name="ln197">            break;</a>
<a name="ln198">    }</a>
<a name="ln199"> </a>
<a name="ln200">    return session;</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">void *</a>
<a name="ln204">create_psk_tls_session(int csock, int type /* GNUTLS_SERVER, GNUTLS_CLIENT */ , void *credentials)</a>
<a name="ln205">{</a>
<a name="ln206">    gnutls_session_t *session = gnutls_malloc(sizeof(gnutls_session_t));</a>
<a name="ln207"> </a>
<a name="ln208">    gnutls_init(session, type);</a>
<a name="ln209">#  ifdef HAVE_GNUTLS_PRIORITY_SET_DIRECT</a>
<a name="ln210">    gnutls_priority_set_direct(*session, &quot;NORMAL:+DHE-PSK:+PSK&quot;, NULL);</a>
<a name="ln211">#  else</a>
<a name="ln212">    gnutls_set_default_priority(*session);</a>
<a name="ln213">    gnutls_kx_set_priority(*session, psk_tls_kx_order);</a>
<a name="ln214">#  endif</a>
<a name="ln215">    gnutls_transport_set_ptr(*session, (gnutls_transport_ptr_t) GINT_TO_POINTER(csock));</a>
<a name="ln216">    switch (type) {</a>
<a name="ln217">        case GNUTLS_SERVER:</a>
<a name="ln218">            gnutls_credentials_set(*session, GNUTLS_CRD_PSK,</a>
<a name="ln219">                                   (gnutls_psk_server_credentials_t) credentials);</a>
<a name="ln220">            break;</a>
<a name="ln221">        case GNUTLS_CLIENT:</a>
<a name="ln222">            gnutls_credentials_set(*session, GNUTLS_CRD_PSK,</a>
<a name="ln223">                                   (gnutls_psk_client_credentials_t) credentials);</a>
<a name="ln224">            break;</a>
<a name="ln225">    }</a>
<a name="ln226"> </a>
<a name="ln227">    return session;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">static int</a>
<a name="ln231">crm_send_tls(gnutls_session_t * session, const char *buf, size_t len)</a>
<a name="ln232">{</a>
<a name="ln233">    const char *unsent = buf;</a>
<a name="ln234">    int rc = 0;</a>
<a name="ln235">    int total_send;</a>
<a name="ln236"> </a>
<a name="ln237">    if (buf == NULL) {</a>
<a name="ln238">        return -1;</a>
<a name="ln239">    }</a>
<a name="ln240"> </a>
<a name="ln241">    total_send = len;</a>
<a name="ln242">    crm_trace(&quot;Message size: %llu&quot;, (unsigned long long) len);</a>
<a name="ln243"> </a>
<a name="ln244">    while (TRUE) {</a>
<a name="ln245">        rc = gnutls_record_send(*session, unsent, len);</a>
<a name="ln246"> </a>
<a name="ln247">        if (rc == GNUTLS_E_INTERRUPTED || rc == GNUTLS_E_AGAIN) {</a>
<a name="ln248">            crm_debug(&quot;Retry&quot;);</a>
<a name="ln249"> </a>
<a name="ln250">        } else if (rc &lt; 0) {</a>
<a name="ln251">            crm_err(&quot;Connection terminated rc = %d&quot;, rc);</a>
<a name="ln252">            break;</a>
<a name="ln253"> </a>
<a name="ln254">        } else if (rc &lt; len) {</a>
<a name="ln255">            crm_debug(&quot;Sent %d of %llu bytes&quot;, rc, (unsigned long long) len);</a>
<a name="ln256">            len -= rc;</a>
<a name="ln257">            unsent += rc;</a>
<a name="ln258">        } else {</a>
<a name="ln259">            crm_trace(&quot;Sent all %d bytes&quot;, rc);</a>
<a name="ln260">            break;</a>
<a name="ln261">        }</a>
<a name="ln262">    }</a>
<a name="ln263"> </a>
<a name="ln264">    return rc &lt; 0 ? rc : total_send;</a>
<a name="ln265">}</a>
<a name="ln266">#endif</a>
<a name="ln267"> </a>
<a name="ln268">static int</a>
<a name="ln269">crm_send_plaintext(int sock, const char *buf, size_t len)</a>
<a name="ln270">{</a>
<a name="ln271"> </a>
<a name="ln272">    int rc = 0;</a>
<a name="ln273">    const char *unsent = buf;</a>
<a name="ln274">    int total_send;</a>
<a name="ln275"> </a>
<a name="ln276">    if (buf == NULL) {</a>
<a name="ln277">        return -1;</a>
<a name="ln278">    }</a>
<a name="ln279">    total_send = len;</a>
<a name="ln280"> </a>
<a name="ln281">    crm_trace(&quot;Message on socket %d: size=%llu&quot;,</a>
<a name="ln282">              sock, (unsigned long long) len);</a>
<a name="ln283">  retry:</a>
<a name="ln284">    rc = write(sock, unsent, len);</a>
<a name="ln285">    if (rc &lt; 0) {</a>
<a name="ln286">        switch (errno) {</a>
<a name="ln287">            case EINTR:</a>
<a name="ln288">            case EAGAIN:</a>
<a name="ln289">                crm_trace(&quot;Retry&quot;);</a>
<a name="ln290">                goto retry;</a>
<a name="ln291">            default:</a>
<a name="ln292">                crm_perror(LOG_ERR, &quot;Could only write %d of the remaining %d bytes&quot;, rc, (int)len);</a>
<a name="ln293">                break;</a>
<a name="ln294">        }</a>
<a name="ln295"> </a>
<a name="ln296">    } else if (rc &lt; len) {</a>
<a name="ln297">        crm_trace(&quot;Only sent %d of %llu remaining bytes&quot;,</a>
<a name="ln298">                  rc, (unsigned long long) len);</a>
<a name="ln299">        len -= rc;</a>
<a name="ln300">        unsent += rc;</a>
<a name="ln301">        goto retry;</a>
<a name="ln302"> </a>
<a name="ln303">    } else {</a>
<a name="ln304">        crm_trace(&quot;Sent %d bytes: %.100s&quot;, rc, buf);</a>
<a name="ln305">    }</a>
<a name="ln306"> </a>
<a name="ln307">    return rc &lt; 0 ? rc : total_send;</a>
<a name="ln308"> </a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">static int</a>
<a name="ln312">crm_remote_sendv(crm_remote_t * remote, struct iovec * iov, int iovs)</a>
<a name="ln313">{</a>
<a name="ln314">    int lpc = 0;</a>
<a name="ln315">    int rc = -ESOCKTNOSUPPORT;</a>
<a name="ln316"> </a>
<a name="ln317">    for(; lpc &lt; iovs; lpc++) {</a>
<a name="ln318"> </a>
<a name="ln319">#ifdef HAVE_GNUTLS_GNUTLS_H</a>
<a name="ln320">        if (remote-&gt;tls_session) {</a>
<a name="ln321">            rc = crm_send_tls(remote-&gt;tls_session, iov[lpc].iov_base, iov[lpc].iov_len);</a>
<a name="ln322">        } else if (remote-&gt;tcp_socket) {</a>
<a name="ln323">#else</a>
<a name="ln324">        if (remote-&gt;tcp_socket) {</a>
<a name="ln325">#endif</a>
<a name="ln326">            rc = crm_send_plaintext(remote-&gt;tcp_socket, iov[lpc].iov_base, iov[lpc].iov_len);</a>
<a name="ln327"> </a>
<a name="ln328">        } else {</a>
<a name="ln329">            crm_err(&quot;Unsupported connection type&quot;);</a>
<a name="ln330">        }</a>
<a name="ln331">    }</a>
<a name="ln332">    return rc;</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335">int</a>
<a name="ln336">crm_remote_send(crm_remote_t * remote, xmlNode * msg)</a>
<a name="ln337">{</a>
<a name="ln338">    int rc = -1;</a>
<a name="ln339">    static uint64_t id = 0;</a>
<a name="ln340">    char *xml_text = dump_xml_unformatted(msg);</a>
<a name="ln341"> </a>
<a name="ln342">    struct iovec iov[2];</a>
<a name="ln343">    struct crm_remote_header_v0 *header;</a>
<a name="ln344"> </a>
<a name="ln345">    if (xml_text == NULL) {</a>
<a name="ln346">        crm_err(&quot;Invalid XML, can not send msg&quot;);</a>
<a name="ln347">        return -1;</a>
<a name="ln348">    }</a>
<a name="ln349"> </a>
<a name="ln350">    header = calloc(1, sizeof(struct crm_remote_header_v0));</a>
<a name="ln351">    iov[0].iov_base = header;</a>
<a name="ln352">    iov[0].iov_len = sizeof(struct crm_remote_header_v0);</a>
<a name="ln353"> </a>
<a name="ln354">    iov[1].iov_base = xml_text;</a>
<a name="ln355">    iov[1].iov_len = 1 + strlen(xml_text);</a>
<a name="ln356"> </a>
<a name="ln357">    id++;</a>
<a name="ln358">    header-&gt;id = id;</a>
<a name="ln359">    header-&gt;endian = ENDIAN_LOCAL;</a>
<a name="ln360">    header-&gt;version = REMOTE_MSG_VERSION;</a>
<a name="ln361">    header-&gt;payload_offset = iov[0].iov_len;</a>
<a name="ln362">    header-&gt;payload_uncompressed = iov[1].iov_len;</a>
<a name="ln363">    header-&gt;size_total = iov[0].iov_len + iov[1].iov_len;</a>
<a name="ln364"> </a>
<a name="ln365">    crm_trace(&quot;Sending len[0]=%d, start=%x&quot;,</a>
<a name="ln366">              (int)iov[0].iov_len, *(int*)(void*)xml_text);</a>
<a name="ln367">    rc = crm_remote_sendv(remote, iov, 2);</a>
<a name="ln368">    if (rc &lt; 0) {</a>
<a name="ln369">        crm_err(&quot;Failed to send remote msg, rc = %d&quot;, rc);</a>
<a name="ln370">    }</a>
<a name="ln371"> </a>
<a name="ln372">    free(iov[0].iov_base);</a>
<a name="ln373">    free(iov[1].iov_base);</a>
<a name="ln374">    return rc;</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377"> </a>
<a name="ln378">/*!</a>
<a name="ln379"> * \internal</a>
<a name="ln380"> * \brief handles the recv buffer and parsing out msgs.</a>
<a name="ln381"> * \note new_data is owned by this function once it is passed in.</a>
<a name="ln382"> */</a>
<a name="ln383">xmlNode *</a>
<a name="ln384">crm_remote_parse_buffer(crm_remote_t * remote)</a>
<a name="ln385">{</a>
<a name="ln386">    xmlNode *xml = NULL;</a>
<a name="ln387">    struct crm_remote_header_v0 *header = crm_remote_header(remote);</a>
<a name="ln388"> </a>
<a name="ln389">    if (remote-&gt;buffer == NULL || header == NULL) {</a>
<a name="ln390">        return NULL;</a>
<a name="ln391">    }</a>
<a name="ln392"> </a>
<a name="ln393">    /* Support compression on the receiving end now, in case we ever want to add it later */</a>
<a name="ln394">    if (header-&gt;payload_compressed) {</a>
<a name="ln395">        int rc = 0;</a>
<a name="ln396">        unsigned int size_u = 1 + header-&gt;payload_uncompressed;</a>
<a name="ln397">        char *uncompressed = calloc(1, header-&gt;payload_offset + size_u);</a>
<a name="ln398"> </a>
<a name="ln399">        crm_trace(&quot;Decompressing message data %d bytes into %d bytes&quot;,</a>
<a name="ln400">                 header-&gt;payload_compressed, size_u);</a>
<a name="ln401"> </a>
<a name="ln402">        rc = BZ2_bzBuffToBuffDecompress(uncompressed + header-&gt;payload_offset, &amp;size_u,</a>
<a name="ln403">                                        remote-&gt;buffer + header-&gt;payload_offset,</a>
<a name="ln404">                                        header-&gt;payload_compressed, 1, 0);</a>
<a name="ln405"> </a>
<a name="ln406">        if (rc != BZ_OK &amp;&amp; header-&gt;version &gt; REMOTE_MSG_VERSION) {</a>
<a name="ln407">            crm_warn(&quot;Couldn't decompress v%d message, we only understand v%d&quot;,</a>
<a name="ln408">                     header-&gt;version, REMOTE_MSG_VERSION);</a>
<a name="ln409">            free(uncompressed);</a>
<a name="ln410">            return NULL;</a>
<a name="ln411"> </a>
<a name="ln412">        } else if (rc != BZ_OK) {</a>
<a name="ln413">            crm_err(&quot;Decompression failed: %s (%d)&quot;, bz2_strerror(rc), rc);</a>
<a name="ln414">            free(uncompressed);</a>
<a name="ln415">            return NULL;</a>
<a name="ln416">        }</a>
<a name="ln417"> </a>
<a name="ln418">        CRM_ASSERT(size_u == header-&gt;payload_uncompressed);</a>
<a name="ln419"> </a>
<a name="ln420">        memcpy(uncompressed, remote-&gt;buffer, header-&gt;payload_offset);       /* Preserve the header */</a>
<a name="ln421">        remote-&gt;buffer_size = header-&gt;payload_offset + size_u;</a>
<a name="ln422"> </a>
<a name="ln423">        free(remote-&gt;buffer);</a>
<a name="ln424">        remote-&gt;buffer = uncompressed;</a>
<a name="ln425">        header = crm_remote_header(remote);</a>
<a name="ln426">    }</a>
<a name="ln427"> </a>
<a name="ln428">    /* take ownership of the buffer */</a>
<a name="ln429">    remote-&gt;buffer_offset = 0;</a>
<a name="ln430"> </a>
<a name="ln431">    CRM_LOG_ASSERT(remote-&gt;buffer[sizeof(struct crm_remote_header_v0) + header-&gt;payload_uncompressed - 1] == 0);</a>
<a name="ln432"> </a>
<a name="ln433">    xml = string2xml(remote-&gt;buffer + header-&gt;payload_offset);</a>
<a name="ln434">    if (xml == NULL &amp;&amp; header-&gt;version &gt; REMOTE_MSG_VERSION) {</a>
<a name="ln435">        crm_warn(&quot;Couldn't parse v%d message, we only understand v%d&quot;,</a>
<a name="ln436">                 header-&gt;version, REMOTE_MSG_VERSION);</a>
<a name="ln437"> </a>
<a name="ln438">    } else if (xml == NULL) {</a>
<a name="ln439">        crm_err(&quot;Couldn't parse: '%.120s'&quot;, remote-&gt;buffer + header-&gt;payload_offset);</a>
<a name="ln440">    }</a>
<a name="ln441"> </a>
<a name="ln442">    return xml;</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">/*!</a>
<a name="ln446"> * \internal</a>
<a name="ln447"> * \brief Wait for a remote session to have data to read</a>
<a name="ln448"> *</a>
<a name="ln449"> * \param[in] remote         Connection to check</a>
<a name="ln450"> * \param[in] total_timeout  Maximum time (in ms) to wait</a>
<a name="ln451"> *</a>
<a name="ln452"> * \return Positive value if ready to be read, 0 on timeout, -errno on error</a>
<a name="ln453"> */</a>
<a name="ln454">int</a>
<a name="ln455">crm_remote_ready(crm_remote_t *remote, int total_timeout)</a>
<a name="ln456">{</a>
<a name="ln457">    struct pollfd fds = { 0, };</a>
<a name="ln458">    int sock = 0;</a>
<a name="ln459">    int rc = 0;</a>
<a name="ln460">    time_t start;</a>
<a name="ln461">    int timeout = total_timeout;</a>
<a name="ln462"> </a>
<a name="ln463">#ifdef HAVE_GNUTLS_GNUTLS_H</a>
<a name="ln464">    if (remote-&gt;tls_session) {</a>
<a name="ln465">        void *sock_ptr = gnutls_transport_get_ptr(*remote-&gt;tls_session);</a>
<a name="ln466"> </a>
<a name="ln467">        sock = GPOINTER_TO_INT(sock_ptr);</a>
<a name="ln468">    } else if (remote-&gt;tcp_socket) {</a>
<a name="ln469">#else</a>
<a name="ln470">    if (remote-&gt;tcp_socket) {</a>
<a name="ln471">#endif</a>
<a name="ln472">        sock = remote-&gt;tcp_socket;</a>
<a name="ln473">    } else {</a>
<a name="ln474">        crm_err(&quot;Unsupported connection type&quot;);</a>
<a name="ln475">    }</a>
<a name="ln476"> </a>
<a name="ln477">    if (sock &lt;= 0) {</a>
<a name="ln478">        crm_trace(&quot;No longer connected&quot;);</a>
<a name="ln479">        return -ENOTCONN;</a>
<a name="ln480">    }</a>
<a name="ln481"> </a>
<a name="ln482">    start = time(NULL);</a>
<a name="ln483">    errno = 0;</a>
<a name="ln484">    do {</a>
<a name="ln485">        fds.fd = sock;</a>
<a name="ln486">        fds.events = POLLIN;</a>
<a name="ln487"> </a>
<a name="ln488">        /* If we got an EINTR while polling, and we have a</a>
<a name="ln489">         * specific timeout we are trying to honor, attempt</a>
<a name="ln490">         * to adjust the timeout to the closest second. */</a>
<a name="ln491">        if (errno == EINTR &amp;&amp; (timeout &gt; 0)) {</a>
<a name="ln492">            timeout = total_timeout - ((time(NULL) - start) * 1000);</a>
<a name="ln493">            if (timeout &lt; 1000) {</a>
<a name="ln494">                timeout = 1000;</a>
<a name="ln495">            }</a>
<a name="ln496">        }</a>
<a name="ln497"> </a>
<a name="ln498">        rc = poll(&amp;fds, 1, timeout);</a>
<a name="ln499">    } while (rc &lt; 0 &amp;&amp; errno == EINTR);</a>
<a name="ln500"> </a>
<a name="ln501">    return (rc &lt; 0)? -errno : rc;</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504"> </a>
<a name="ln505">/*!</a>
<a name="ln506"> * \internal</a>
<a name="ln507"> * \brief Read bytes off non blocking remote connection.</a>
<a name="ln508"> *</a>
<a name="ln509"> * \note only use with NON-Blocking sockets. Should only be used after polling socket.</a>
<a name="ln510"> *       This function will return once max_size is met, the socket read buffer</a>
<a name="ln511"> *       is empty, or an error is encountered.</a>
<a name="ln512"> *</a>
<a name="ln513"> * \retval number of bytes received</a>
<a name="ln514"> */</a>
<a name="ln515">static size_t</a>
<a name="ln516">crm_remote_recv_once(crm_remote_t * remote)</a>
<a name="ln517">{</a>
<a name="ln518">    int rc = 0;</a>
<a name="ln519">    size_t read_len = sizeof(struct crm_remote_header_v0);</a>
<a name="ln520">    struct crm_remote_header_v0 *header = crm_remote_header(remote);</a>
<a name="ln521"> </a>
<a name="ln522">    if(header) {</a>
<a name="ln523">        /* Stop at the end of the current message */</a>
<a name="ln524">        read_len = header-&gt;size_total;</a>
<a name="ln525">    }</a>
<a name="ln526"> </a>
<a name="ln527">    /* automatically grow the buffer when needed */</a>
<a name="ln528">    if(remote-&gt;buffer_size &lt; read_len) {</a>
<a name="ln529">           remote-&gt;buffer_size = 2 * read_len;</a>
<a name="ln530">        crm_trace(&quot;Expanding buffer to %llu bytes&quot;,</a>
<a name="ln531">                  (unsigned long long) remote-&gt;buffer_size);</a>
<a name="ln532"> </a>
<a name="ln533">        remote-&gt;buffer = realloc_safe(remote-&gt;buffer, remote-&gt;buffer_size + 1);</a>
<a name="ln534">        CRM_ASSERT(remote-&gt;buffer != NULL);</a>
<a name="ln535">    }</a>
<a name="ln536"> </a>
<a name="ln537">#ifdef HAVE_GNUTLS_GNUTLS_H</a>
<a name="ln538">    if (remote-&gt;tls_session) {</a>
<a name="ln539">        rc = gnutls_record_recv(*(remote-&gt;tls_session),</a>
<a name="ln540">                                remote-&gt;buffer + remote-&gt;buffer_offset,</a>
<a name="ln541">                                remote-&gt;buffer_size - remote-&gt;buffer_offset);</a>
<a name="ln542">        if (rc == GNUTLS_E_INTERRUPTED) {</a>
<a name="ln543">            rc = -EINTR;</a>
<a name="ln544">        } else if (rc == GNUTLS_E_AGAIN) {</a>
<a name="ln545">            rc = -EAGAIN;</a>
<a name="ln546">        } else if (rc &lt; 0) {</a>
<a name="ln547">            crm_debug(&quot;TLS receive failed: %s (%d)&quot;, gnutls_strerror(rc), rc);</a>
<a name="ln548">            rc = -pcmk_err_generic;</a>
<a name="ln549">        }</a>
<a name="ln550">    } else if (remote-&gt;tcp_socket) {</a>
<a name="ln551">#else</a>
<a name="ln552">    if (remote-&gt;tcp_socket) {</a>
<a name="ln553">#endif</a>
<a name="ln554">        errno = 0;</a>
<a name="ln555">        rc = read(remote-&gt;tcp_socket,</a>
<a name="ln556">                  remote-&gt;buffer + remote-&gt;buffer_offset,</a>
<a name="ln557">                  remote-&gt;buffer_size - remote-&gt;buffer_offset);</a>
<a name="ln558">        if(rc &lt; 0) {</a>
<a name="ln559">            rc = -errno;</a>
<a name="ln560">        }</a>
<a name="ln561"> </a>
<a name="ln562">    } else {</a>
<a name="ln563">        crm_err(&quot;Unsupported connection type&quot;);</a>
<a name="ln564">        return -ESOCKTNOSUPPORT;</a>
<a name="ln565">    }</a>
<a name="ln566"> </a>
<a name="ln567">    /* process any errors. */</a>
<a name="ln568">    if (rc &gt; 0) {</a>
<a name="ln569">        remote-&gt;buffer_offset += rc;</a>
<a name="ln570">        /* always null terminate buffer, the +1 to alloc always allows for this. */</a>
<a name="ln571">        remote-&gt;buffer[remote-&gt;buffer_offset] = '\0';</a>
<a name="ln572">        crm_trace(&quot;Received %u more bytes, %llu total&quot;,</a>
<a name="ln573">                  rc, (unsigned long long) remote-&gt;buffer_offset);</a>
<a name="ln574"> </a>
<a name="ln575">    } else if (rc == -EINTR || rc == -EAGAIN) {</a>
<a name="ln576">        crm_trace(&quot;non-blocking, exiting read: %s (%d)&quot;, pcmk_strerror(rc), rc);</a>
<a name="ln577"> </a>
<a name="ln578">    } else if (rc == 0) {</a>
<a name="ln579">        crm_debug(&quot;EOF encoutered after %llu bytes&quot;,</a>
<a name="ln580">                  (unsigned long long) remote-&gt;buffer_offset);</a>
<a name="ln581">        return -ENOTCONN;</a>
<a name="ln582"> </a>
<a name="ln583">    } else {</a>
<a name="ln584">        crm_debug(&quot;Error receiving message after %llu bytes: %s (%d)&quot;,</a>
<a name="ln585">                  (unsigned long long) remote-&gt;buffer_offset,</a>
<a name="ln586">                  pcmk_strerror(rc), rc);</a>
<a name="ln587">        return -ENOTCONN;</a>
<a name="ln588">    }</a>
<a name="ln589"> </a>
<a name="ln590">    header = crm_remote_header(remote);</a>
<a name="ln591">    if(header) {</a>
<a name="ln592">        if(remote-&gt;buffer_offset &lt; header-&gt;size_total) {</a>
<a name="ln593">            crm_trace(&quot;Read less than the advertised length: %llu &lt; %u bytes&quot;,</a>
<a name="ln594">                      (unsigned long long) remote-&gt;buffer_offset,</a>
<a name="ln595">                      header-&gt;size_total);</a>
<a name="ln596">        } else {</a>
<a name="ln597">            crm_trace(&quot;Read full message of %llu bytes&quot;,</a>
<a name="ln598">                      (unsigned long long) remote-&gt;buffer_offset);</a>
<a name="ln599">            return remote-&gt;buffer_offset;</a>
<a name="ln600">        }</a>
<a name="ln601">    }</a>
<a name="ln602"> </a>
<a name="ln603">    return -EAGAIN;</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">/*!</a>
<a name="ln607"> * \internal</a>
<a name="ln608"> * \brief Read message(s) from a remote connection</a>
<a name="ln609"> *</a>
<a name="ln610"> * \param[in]  remote         Remote connection to read</a>
<a name="ln611"> * \param[in]  total_timeout  Fail if message not read in this time (ms)</a>
<a name="ln612"> * \param[out] disconnected   Will be set to 1 if disconnect detected</a>
<a name="ln613"> *</a>
<a name="ln614"> * \return TRUE if at least one full message read, FALSE otherwise</a>
<a name="ln615"> */</a>
<a name="ln616">gboolean</a>
<a name="ln617">crm_remote_recv(crm_remote_t *remote, int total_timeout, int *disconnected)</a>
<a name="ln618">{</a>
<a name="ln619">    int rc;</a>
<a name="ln620">    time_t start = time(NULL);</a>
<a name="ln621">    int remaining_timeout = 0;</a>
<a name="ln622"> </a>
<a name="ln623">    if (total_timeout == 0) {</a>
<a name="ln624">        total_timeout = 10000;</a>
<a name="ln625">    } else if (total_timeout &lt; 0) {</a>
<a name="ln626">        total_timeout = 60000;</a>
<a name="ln627">    }</a>
<a name="ln628">    *disconnected = 0;</a>
<a name="ln629"> </a>
<a name="ln630">    remaining_timeout = total_timeout;</a>
<a name="ln631">    while ((remaining_timeout &gt; 0) &amp;&amp; !(*disconnected)) {</a>
<a name="ln632"> </a>
<a name="ln633">        crm_trace(&quot;Waiting for remote data (%d of %d ms timeout remaining)&quot;,</a>
<a name="ln634">                  remaining_timeout, total_timeout);</a>
<a name="ln635">        rc = crm_remote_ready(remote, remaining_timeout);</a>
<a name="ln636"> </a>
<a name="ln637">        if (rc == 0) {</a>
<a name="ln638">            crm_err(&quot;Timed out (%d ms) while waiting for remote data&quot;,</a>
<a name="ln639">                    remaining_timeout);</a>
<a name="ln640">            return FALSE;</a>
<a name="ln641"> </a>
<a name="ln642">        } else if (rc &lt; 0) {</a>
<a name="ln643">            crm_debug(&quot;Wait for remote data aborted, will try again: %s &quot;</a>
<a name="ln644">                      CRM_XS &quot; rc=%d&quot;, pcmk_strerror(rc), rc);</a>
<a name="ln645"> </a>
<a name="ln646">        } else {</a>
<a name="ln647">            rc = crm_remote_recv_once(remote);</a>
<a name="ln648">            if (rc &gt; 0) {</a>
<a name="ln649">                return TRUE;</a>
<a name="ln650">            } else if (rc == -EAGAIN) {</a>
<a name="ln651">                crm_trace(&quot;Still waiting for remote data&quot;);</a>
<a name="ln652">            } else if (rc &lt; 0) {</a>
<a name="ln653">                crm_debug(&quot;Could not receive remote data: %s &quot; CRM_XS &quot; rc=%d&quot;,</a>
<a name="ln654">                          pcmk_strerror(rc), rc);</a>
<a name="ln655">            }</a>
<a name="ln656">        }</a>
<a name="ln657"> </a>
<a name="ln658">        if (rc == -ENOTCONN) {</a>
<a name="ln659">            *disconnected = 1;</a>
<a name="ln660">            return FALSE;</a>
<a name="ln661">        }</a>
<a name="ln662"> </a>
<a name="ln663">        remaining_timeout = total_timeout - ((time(NULL) - start) * 1000);</a>
<a name="ln664">    }</a>
<a name="ln665"> </a>
<a name="ln666">    return FALSE;</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">struct tcp_async_cb_data {</a>
<a name="ln670">    gboolean success;</a>
<a name="ln671">    int sock;</a>
<a name="ln672">    void *userdata;</a>
<a name="ln673">    void (*callback) (void *userdata, int sock);</a>
<a name="ln674">    int timeout;                /*ms */</a>
<a name="ln675">    time_t start;</a>
<a name="ln676">};</a>
<a name="ln677"> </a>
<a name="ln678">static gboolean</a>
<a name="ln679">check_connect_finished(gpointer userdata)</a>
<a name="ln680">{</a>
<a name="ln681">    struct tcp_async_cb_data *cb_data = userdata;</a>
<a name="ln682">    int rc = 0;</a>
<a name="ln683">    int sock = cb_data-&gt;sock;</a>
<a name="ln684">    int error = 0;</a>
<a name="ln685"> </a>
<a name="ln686">    fd_set rset, wset;</a>
<a name="ln687">    socklen_t len = sizeof(error);</a>
<a name="ln688">    struct timeval ts = { 0, };</a>
<a name="ln689"> </a>
<a name="ln690">    if (cb_data-&gt;success == TRUE) {</a>
<a name="ln691">        goto dispatch_done;</a>
<a name="ln692">    }</a>
<a name="ln693"> </a>
<a name="ln694">    FD_ZERO(&amp;rset);</a>
<a name="ln695">    FD_SET(sock, &amp;rset);</a>
<a name="ln696">    wset = rset;</a>
<a name="ln697"> </a>
<a name="ln698">    crm_trace(&quot;fd %d: checking to see if connect finished&quot;, sock);</a>
<a name="ln699">    rc = select(sock + 1, &amp;rset, &amp;wset, NULL, &amp;ts);</a>
<a name="ln700"> </a>
<a name="ln701">    if (rc &lt; 0) {</a>
<a name="ln702">        rc = errno;</a>
<a name="ln703">        if ((errno == EINPROGRESS) || (errno == EAGAIN)) {</a>
<a name="ln704">            /* reschedule if there is still time left */</a>
<a name="ln705">            if ((time(NULL) - cb_data-&gt;start) &lt; (cb_data-&gt;timeout / 1000)) {</a>
<a name="ln706">                goto reschedule;</a>
<a name="ln707">            } else {</a>
<a name="ln708">                rc = -ETIMEDOUT;</a>
<a name="ln709">            }</a>
<a name="ln710">        }</a>
<a name="ln711">        crm_trace(&quot;fd %d: select failed %d connect dispatch &quot;, sock, rc);</a>
<a name="ln712">        goto dispatch_done;</a>
<a name="ln713">    } else if (rc == 0) {</a>
<a name="ln714">        if ((time(NULL) - cb_data-&gt;start) &lt; (cb_data-&gt;timeout / 1000)) {</a>
<a name="ln715">            goto reschedule;</a>
<a name="ln716">        }</a>
<a name="ln717">        crm_debug(&quot;fd %d: timeout during select&quot;, sock);</a>
<a name="ln718">        rc = -ETIMEDOUT;</a>
<a name="ln719">        goto dispatch_done;</a>
<a name="ln720">    } else {</a>
<a name="ln721">        crm_trace(&quot;fd %d: select returned success&quot;, sock);</a>
<a name="ln722">        rc = 0;</a>
<a name="ln723">    }</a>
<a name="ln724"> </a>
<a name="ln725">    /* can we read or write to the socket now? */</a>
<a name="ln726">    if (FD_ISSET(sock, &amp;rset) || FD_ISSET(sock, &amp;wset)) {</a>
<a name="ln727">        if (getsockopt(sock, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len) &lt; 0) {</a>
<a name="ln728">            crm_trace(&quot;fd %d: call to getsockopt failed&quot;, sock);</a>
<a name="ln729">            rc = -1;</a>
<a name="ln730">            goto dispatch_done;</a>
<a name="ln731">        }</a>
<a name="ln732"> </a>
<a name="ln733">        if (error) {</a>
<a name="ln734">            crm_trace(&quot;fd %d: error returned from getsockopt: %d&quot;, sock, error);</a>
<a name="ln735">            rc = -1;</a>
<a name="ln736">            goto dispatch_done;</a>
<a name="ln737">        }</a>
<a name="ln738">    } else {</a>
<a name="ln739">        crm_trace(&quot;neither read nor write set after select&quot;);</a>
<a name="ln740">        rc = -1;</a>
<a name="ln741">        goto dispatch_done;</a>
<a name="ln742">    }</a>
<a name="ln743"> </a>
<a name="ln744">  dispatch_done:</a>
<a name="ln745">    if (!rc) {</a>
<a name="ln746">        crm_trace(&quot;fd %d: connected&quot;, sock);</a>
<a name="ln747">        /* Success, set the return code to the sock to report to the callback */</a>
<a name="ln748">        rc = cb_data-&gt;sock;</a>
<a name="ln749">        cb_data-&gt;sock = 0;</a>
<a name="ln750">    } else {</a>
<a name="ln751">        close(sock);</a>
<a name="ln752">    }</a>
<a name="ln753"> </a>
<a name="ln754">    if (cb_data-&gt;callback) {</a>
<a name="ln755">        cb_data-&gt;callback(cb_data-&gt;userdata, rc);</a>
<a name="ln756">    }</a>
<a name="ln757">    free(cb_data);</a>
<a name="ln758">    return FALSE;</a>
<a name="ln759"> </a>
<a name="ln760">  reschedule:</a>
<a name="ln761"> </a>
<a name="ln762">    /* will check again next interval */</a>
<a name="ln763">    return TRUE;</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">static int</a>
<a name="ln767">internal_tcp_connect_async(int sock,</a>
<a name="ln768">                           const struct sockaddr *addr, socklen_t addrlen, int timeout /* ms */ ,</a>
<a name="ln769">                           int *timer_id, void *userdata, void (*callback) (void *userdata, int sock))</a>
<a name="ln770">{</a>
<a name="ln771">    int rc = 0;</a>
<a name="ln772">    int flag = 0;</a>
<a name="ln773">    int interval = 500;</a>
<a name="ln774">    int timer;</a>
<a name="ln775">    struct tcp_async_cb_data *cb_data = NULL;</a>
<a name="ln776"> </a>
<a name="ln777">    if ((flag = fcntl(sock, F_GETFL)) &gt;= 0) {</a>
<a name="ln778">        if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) &lt; 0) {</a>
<a name="ln779">            crm_err(&quot;fcntl() write failed&quot;);</a>
<a name="ln780">            return -1;</a>
<a name="ln781">        }</a>
<a name="ln782">    }</a>
<a name="ln783"> </a>
<a name="ln784">    rc = connect(sock, addr, addrlen);</a>
<a name="ln785"> </a>
<a name="ln786">    if (rc &lt; 0 &amp;&amp; (errno != EINPROGRESS) &amp;&amp; (errno != EAGAIN)) {</a>
<a name="ln787">        return -1;</a>
<a name="ln788">    }</a>
<a name="ln789"> </a>
<a name="ln790">    cb_data = calloc(1, sizeof(struct tcp_async_cb_data));</a>
<a name="ln791">    cb_data-&gt;userdata = userdata;</a>
<a name="ln792">    cb_data-&gt;callback = callback;</a>
<a name="ln793">    cb_data-&gt;sock = sock;</a>
<a name="ln794">    cb_data-&gt;timeout = timeout;</a>
<a name="ln795">    cb_data-&gt;start = time(NULL);</a>
<a name="ln796"> </a>
<a name="ln797">    if (rc == 0) {</a>
<a name="ln798">        /* The connect was successful immediately, we still return to mainloop</a>
<a name="ln799">         * and let this callback get called later. This avoids the user of this api</a>
<a name="ln800">         * to have to account for the fact the callback could be invoked within this</a>
<a name="ln801">         * function before returning. */</a>
<a name="ln802">        cb_data-&gt;success = TRUE;</a>
<a name="ln803">        interval = 1;</a>
<a name="ln804">    }</a>
<a name="ln805"> </a>
<a name="ln806">    /* Check connect finished is mostly doing a non-block poll on the socket</a>
<a name="ln807">     * to see if we can read/write to it. Once we can, the connect has completed.</a>
<a name="ln808">     * This method allows us to connect to the server without blocking mainloop.</a>
<a name="ln809">     *</a>
<a name="ln810">     * This is a poor man's way of polling to see when the connection finished.</a>
<a name="ln811">     * At some point we should figure out a way to use a mainloop fd callback for this.</a>
<a name="ln812">     * Something about the way mainloop is currently polling prevents this from working at the</a>
<a name="ln813">     * moment though. */</a>
<a name="ln814">    crm_trace(&quot;fd %d: scheduling to check if connect finished in %dms second&quot;, sock, interval);</a>
<a name="ln815">    timer = g_timeout_add(interval, check_connect_finished, cb_data);</a>
<a name="ln816">    if (timer_id) {</a>
<a name="ln817">        *timer_id = timer;</a>
<a name="ln818">    }</a>
<a name="ln819"> </a>
<a name="ln820">    return 0;</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">static int</a>
<a name="ln824">internal_tcp_connect(int sock, const struct sockaddr *addr, socklen_t addrlen)</a>
<a name="ln825">{</a>
<a name="ln826">    int flag = 0;</a>
<a name="ln827">    int rc = connect(sock, addr, addrlen);</a>
<a name="ln828"> </a>
<a name="ln829">    if (rc == 0) {</a>
<a name="ln830">        if ((flag = fcntl(sock, F_GETFL)) &gt;= 0) {</a>
<a name="ln831">            if (fcntl(sock, F_SETFL, flag | O_NONBLOCK) &lt; 0) {</a>
<a name="ln832">                crm_err(&quot;fcntl() write failed&quot;);</a>
<a name="ln833">                return -1;</a>
<a name="ln834">            }</a>
<a name="ln835">        }</a>
<a name="ln836">    }</a>
<a name="ln837"> </a>
<a name="ln838">    return rc;</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841">/*!</a>
<a name="ln842"> * \internal</a>
<a name="ln843"> * \brief tcp connection to server at specified port</a>
<a name="ln844"> * \retval negative, failed to connect.</a>
<a name="ln845"> * \retval positive, sock fd</a>
<a name="ln846"> */</a>
<a name="ln847">int</a>
<a name="ln848">crm_remote_tcp_connect_async(const char *host, int port, int timeout, /*ms */</a>
<a name="ln849">                             int *timer_id, void *userdata, void (*callback) (void *userdata, int sock))</a>
<a name="ln850">{</a>
<a name="ln851">    char buffer[INET6_ADDRSTRLEN];</a>
<a name="ln852">    struct addrinfo *res = NULL;</a>
<a name="ln853">    struct addrinfo *rp = NULL;</a>
<a name="ln854">    struct addrinfo hints;</a>
<a name="ln855">    const char *server = host;</a>
<a name="ln856">    int ret_ga;</a>
<a name="ln857">    int sock = -1;</a>
<a name="ln858"> </a>
<a name="ln859">    /* getaddrinfo */</a>
<a name="ln860">    memset(&amp;hints, 0, sizeof(struct addrinfo));</a>
<a name="ln861">    hints.ai_family = AF_UNSPEC;        /* Allow IPv4 or IPv6 */</a>
<a name="ln862">    hints.ai_socktype = SOCK_STREAM;</a>
<a name="ln863">    hints.ai_flags = AI_CANONNAME;</a>
<a name="ln864"> </a>
<a name="ln865">    crm_debug(&quot;Looking up %s&quot;, server);</a>
<a name="ln866">    ret_ga = getaddrinfo(server, NULL, &amp;hints, &amp;res);</a>
<a name="ln867">    if (ret_ga) {</a>
<a name="ln868">        crm_err(&quot;getaddrinfo: %s&quot;, gai_strerror(ret_ga));</a>
<a name="ln869">        return -1;</a>
<a name="ln870">    }</a>
<a name="ln871"> </a>
<a name="ln872">    if (!res || !res-&gt;ai_addr) {</a>
<a name="ln873">        crm_err(&quot;getaddrinfo failed&quot;);</a>
<a name="ln874">        goto async_cleanup;</a>
<a name="ln875">    }</a>
<a name="ln876"> </a>
<a name="ln877">    for (rp = res; rp != NULL; rp = rp-&gt;ai_next) {</a>
<a name="ln878">        struct sockaddr *addr = rp-&gt;ai_addr;</a>
<a name="ln879"> </a>
<a name="ln880">        if (!addr) {</a>
<a name="ln881">            continue;</a>
<a name="ln882">        }</a>
<a name="ln883"> </a>
<a name="ln884">        if (rp-&gt;ai_canonname) {</a>
<a name="ln885">            server = res-&gt;ai_canonname;</a>
<a name="ln886">        }</a>
<a name="ln887">        crm_debug(&quot;Got address %s for %s&quot;, server, host);</a>
<a name="ln888"> </a>
<a name="ln889">        /* create socket */</a>
<a name="ln890">        sock = socket(rp-&gt;ai_family, SOCK_STREAM, IPPROTO_TCP);</a>
<a name="ln891">        if (sock == -1) {</a>
<a name="ln892">            crm_err(&quot;Socket creation failed for remote client connection.&quot;);</a>
<a name="ln893">            continue;</a>
<a name="ln894">        }</a>
<a name="ln895"> </a>
<a name="ln896">        /* Set port appropriately for address family */</a>
<a name="ln897">        /* (void*) casts avoid false-positive compiler alignment warnings */</a>
<a name="ln898">        if (addr-&gt;sa_family == AF_INET6) {</a>
<a name="ln899">            ((struct sockaddr_in6 *)(void*)addr)-&gt;sin6_port = htons(port);</a>
<a name="ln900">        } else {</a>
<a name="ln901">            ((struct sockaddr_in *)(void*)addr)-&gt;sin_port = htons(port);</a>
<a name="ln902">        }</a>
<a name="ln903"> </a>
<a name="ln904">        memset(buffer, 0, DIMOF(buffer));</a>
<a name="ln905">        crm_sockaddr2str(addr, buffer);</a>
<a name="ln906">        crm_info(&quot;Attempting to connect to remote server at %s:%d&quot;, buffer, port);</a>
<a name="ln907"> </a>
<a name="ln908">        if (callback) {</a>
<a name="ln909">            if (internal_tcp_connect_async</a>
<a name="ln910">                (sock, rp-&gt;ai_addr, rp-&gt;ai_addrlen, timeout, timer_id, userdata, callback) == 0) {</a>
<a name="ln911">                goto async_cleanup; /* Success for now, we'll hear back later in the callback */</a>
<a name="ln912">            }</a>
<a name="ln913"> </a>
<a name="ln914">        } else {</a>
<a name="ln915">            if (internal_tcp_connect(sock, rp-&gt;ai_addr, rp-&gt;ai_addrlen) == 0) {</a>
<a name="ln916">                break;          /* Success */</a>
<a name="ln917">            }</a>
<a name="ln918">        }</a>
<a name="ln919"> </a>
<a name="ln920">        close(sock);</a>
<a name="ln921">        sock = -1;</a>
<a name="ln922">    }</a>
<a name="ln923"> </a>
<a name="ln924">async_cleanup:</a>
<a name="ln925"> </a>
<a name="ln926">    if (res) {</a>
<a name="ln927">        freeaddrinfo(res);</a>
<a name="ln928">    }</a>
<a name="ln929">    return sock;</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">int</a>
<a name="ln933">crm_remote_tcp_connect(const char *host, int port)</a>
<a name="ln934">{</a>
<a name="ln935">    return crm_remote_tcp_connect_async(host, port, -1, NULL, NULL, NULL);</a>
<a name="ln936">}</a>
<a name="ln937"> </a>
<a name="ln938">/*!</a>
<a name="ln939"> * \brief Convert an IP address (IPv4 or IPv6) to a string for logging</a>
<a name="ln940"> *</a>
<a name="ln941"> * \param[in]  sa  Socket address for IP</a>
<a name="ln942"> * \param[out] s   Storage for at least INET6_ADDRSTRLEN bytes</a>
<a name="ln943"> *</a>
<a name="ln944"> * \note sa The socket address can be a pointer to struct sockaddr_in (IPv4),</a>
<a name="ln945"> *          struct sockaddr_in6 (IPv6) or struct sockaddr_storage (either),</a>
<a name="ln946"> *          as long as its sa_family member is set correctly.</a>
<a name="ln947"> */</a>
<a name="ln948">void</a>
<a name="ln949">crm_sockaddr2str(void *sa, char *s)</a>
<a name="ln950">{</a>
<a name="ln951">    switch (((struct sockaddr*)sa)-&gt;sa_family) {</a>
<a name="ln952">        case AF_INET:</a>
<a name="ln953">            inet_ntop(AF_INET, &amp;(((struct sockaddr_in *)sa)-&gt;sin_addr),</a>
<a name="ln954">                      s, INET6_ADDRSTRLEN);</a>
<a name="ln955">            break;</a>
<a name="ln956"> </a>
<a name="ln957">        case AF_INET6:</a>
<a name="ln958">            inet_ntop(AF_INET6, &amp;(((struct sockaddr_in6 *)sa)-&gt;sin6_addr),</a>
<a name="ln959">                      s, INET6_ADDRSTRLEN);</a>
<a name="ln960">            break;</a>
<a name="ln961"> </a>
<a name="ln962">        default:</a>
<a name="ln963">            strcpy(s, &quot;&lt;invalid&gt;&quot;);</a>
<a name="ln964">    }</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967">int</a>
<a name="ln968">crm_remote_accept(int ssock)</a>
<a name="ln969">{</a>
<a name="ln970">    int csock = 0;</a>
<a name="ln971">    int rc = 0;</a>
<a name="ln972">    int flag = 0;</a>
<a name="ln973">    unsigned laddr = 0;</a>
<a name="ln974">    struct sockaddr_storage addr;</a>
<a name="ln975">    char addr_str[INET6_ADDRSTRLEN];</a>
<a name="ln976">#ifdef TCP_USER_TIMEOUT</a>
<a name="ln977">    int optval;</a>
<a name="ln978">    long sbd_timeout = crm_get_sbd_timeout();</a>
<a name="ln979">#endif</a>
<a name="ln980"> </a>
<a name="ln981">    /* accept the connection */</a>
<a name="ln982">    laddr = sizeof(addr);</a>
<a name="ln983">    memset(&amp;addr, 0, sizeof(addr));</a>
<a name="ln984">    csock = accept(ssock, (struct sockaddr *)&amp;addr, &amp;laddr);</a>
<a name="ln985">    crm_sockaddr2str(&amp;addr, addr_str);</a>
<a name="ln986">    crm_info(&quot;New remote connection from %s&quot;, addr_str);</a>
<a name="ln987"> </a>
<a name="ln988">    if (csock == -1) {</a>
<a name="ln989">        crm_err(&quot;accept socket failed&quot;);</a>
<a name="ln990">        return -1;</a>
<a name="ln991">    }</a>
<a name="ln992"> </a>
<a name="ln993">    if ((flag = fcntl(csock, F_GETFL)) &gt;= 0) {</a>
<a name="ln994">        if ((rc = fcntl(csock, F_SETFL, flag | O_NONBLOCK)) &lt; 0) {</a>
<a name="ln995">            crm_err(&quot;fcntl() write failed&quot;);</a>
<a name="ln996">            close(csock);</a>
<a name="ln997">            return rc;</a>
<a name="ln998">        }</a>
<a name="ln999">    } else {</a>
<a name="ln1000">        crm_err(&quot;fcntl() read failed&quot;);</a>
<a name="ln1001">        close(csock);</a>
<a name="ln1002">        return flag;</a>
<a name="ln1003">    }</a>
<a name="ln1004"> </a>
<a name="ln1005">#ifdef TCP_USER_TIMEOUT</a>
<a name="ln1006">    if (sbd_timeout &gt; 0) {</a>
<a name="ln1007">        optval = sbd_timeout / 2; /* time to fail and retry before watchdog */</a>
<a name="ln1008">        rc = setsockopt(csock, SOL_TCP, TCP_USER_TIMEOUT,</a>
<a name="ln1009">                        &amp;optval, sizeof(optval));</a>
<a name="ln1010">        if (rc &lt; 0) {</a>
<a name="ln1011">            crm_err(&quot;setting TCP_USER_TIMEOUT (%d) on client socket failed&quot;,</a>
<a name="ln1012">                    optval);</a>
<a name="ln1013">            close(csock);</a>
<a name="ln1014">            return rc;</a>
<a name="ln1015">        }</a>
<a name="ln1016">    }</a>
<a name="ln1017">#endif</a>
<a name="ln1018"> </a>
<a name="ln1019">    return csock;</a>
<a name="ln1020">}</a>

</code></pre>
<div class="balloon" rel="358"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'header'. Check lines: 358, 350.</p></div>
<div class="balloon" rel="402"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V769/" target="_blank">V769</a> The 'uncompressed' pointer in the 'uncompressed + header->payload_offset' expression could be nullptr. In such case, resulting value will be senseless and it should not be used. Check lines: 402, 397.</p></div>
<div class="balloon" rel="431"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V562/" target="_blank">V562</a> It's odd to compare 0 or 1 with a value of 0.</p></div>
<div class="balloon" rel="791"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'cb_data'. Check lines: 791, 790.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
