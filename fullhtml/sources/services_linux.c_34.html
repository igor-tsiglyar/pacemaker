
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (C) 2010-2016 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * This source code is licensed under the GNU Lesser General Public License</a>
<a name="ln9"> * version 2.1 or later (LGPLv2.1+) WITHOUT ANY WARRANTY.</a>
<a name="ln10"> */</a>
<a name="ln11"> </a>
<a name="ln12">#include &lt;crm_internal.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#ifndef _GNU_SOURCE</a>
<a name="ln15">#  define _GNU_SOURCE</a>
<a name="ln16">#endif</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;sys/types.h&gt;</a>
<a name="ln19">#include &lt;sys/stat.h&gt;</a>
<a name="ln20">#include &lt;sys/wait.h&gt;</a>
<a name="ln21">#include &lt;errno.h&gt;</a>
<a name="ln22">#include &lt;unistd.h&gt;</a>
<a name="ln23">#include &lt;dirent.h&gt;</a>
<a name="ln24">#include &lt;fcntl.h&gt;</a>
<a name="ln25">#include &lt;string.h&gt;</a>
<a name="ln26">#include &lt;sys/time.h&gt;</a>
<a name="ln27">#include &lt;sys/resource.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#ifdef HAVE_SYS_SIGNALFD_H</a>
<a name="ln30">#include &lt;sys/signalfd.h&gt;</a>
<a name="ln31">#endif</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;crm/crm.h&quot;</a>
<a name="ln34">#include &quot;crm/common/mainloop.h&quot;</a>
<a name="ln35">#include &quot;crm/services.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;services_private.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#if SUPPORT_CIBSECRETS</a>
<a name="ln40">#  include &quot;crm/common/cib_secrets.h&quot;</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">static inline void</a>
<a name="ln44">set_fd_opts(int fd, int opts)</a>
<a name="ln45">{</a>
<a name="ln46">    int flag;</a>
<a name="ln47"> </a>
<a name="ln48">    if ((flag = fcntl(fd, F_GETFL)) &gt;= 0) {</a>
<a name="ln49">        if (fcntl(fd, F_SETFL, flag | opts) &lt; 0) {</a>
<a name="ln50">            crm_err(&quot;fcntl() write failed&quot;);</a>
<a name="ln51">        }</a>
<a name="ln52">    } else {</a>
<a name="ln53">        crm_err(&quot;fcntl() read failed&quot;);</a>
<a name="ln54">    }</a>
<a name="ln55">}</a>
<a name="ln56"> </a>
<a name="ln57">static gboolean</a>
<a name="ln58">svc_read_output(int fd, svc_action_t * op, bool is_stderr)</a>
<a name="ln59">{</a>
<a name="ln60">    char *data = NULL;</a>
<a name="ln61">    int rc = 0, len = 0;</a>
<a name="ln62">    char buf[500];</a>
<a name="ln63">    static const size_t buf_read_len = sizeof(buf) - 1;</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66">    if (fd &lt; 0) {</a>
<a name="ln67">        crm_trace(&quot;No fd for %s&quot;, op-&gt;id);</a>
<a name="ln68">        return FALSE;</a>
<a name="ln69">    }</a>
<a name="ln70"> </a>
<a name="ln71">    if (is_stderr &amp;&amp; op-&gt;stderr_data) {</a>
<a name="ln72">        len = strlen(op-&gt;stderr_data);</a>
<a name="ln73">        data = op-&gt;stderr_data;</a>
<a name="ln74">        crm_trace(&quot;Reading %s stderr into offset %d&quot;, op-&gt;id, len);</a>
<a name="ln75"> </a>
<a name="ln76">    } else if (is_stderr == FALSE &amp;&amp; op-&gt;stdout_data) {</a>
<a name="ln77">        len = strlen(op-&gt;stdout_data);</a>
<a name="ln78">        data = op-&gt;stdout_data;</a>
<a name="ln79">        crm_trace(&quot;Reading %s stdout into offset %d&quot;, op-&gt;id, len);</a>
<a name="ln80"> </a>
<a name="ln81">    } else {</a>
<a name="ln82">        crm_trace(&quot;Reading %s %s into offset %d&quot;, op-&gt;id, is_stderr?&quot;stderr&quot;:&quot;stdout&quot;, len);</a>
<a name="ln83">    }</a>
<a name="ln84"> </a>
<a name="ln85">    do {</a>
<a name="ln86">        rc = read(fd, buf, buf_read_len);</a>
<a name="ln87">        if (rc &gt; 0) {</a>
<a name="ln88">            crm_trace(&quot;Got %d chars: %.80s&quot;, rc, buf);</a>
<a name="ln89">            buf[rc] = 0;</a>
<a name="ln90">            data = realloc_safe(data, len + rc + 1);</a>
<a name="ln91">            len += sprintf(data + len, &quot;%s&quot;, buf);</a>
<a name="ln92"> </a>
<a name="ln93">        } else if (errno != EINTR) {</a>
<a name="ln94">            /* error or EOF</a>
<a name="ln95">             * Cleanup happens in pipe_done()</a>
<a name="ln96">             */</a>
<a name="ln97">            rc = FALSE;</a>
<a name="ln98">            break;</a>
<a name="ln99">        }</a>
<a name="ln100"> </a>
<a name="ln101">    } while (rc == buf_read_len || rc &lt; 0);</a>
<a name="ln102"> </a>
<a name="ln103">    if (is_stderr) {</a>
<a name="ln104">        op-&gt;stderr_data = data;</a>
<a name="ln105">    } else {</a>
<a name="ln106">        op-&gt;stdout_data = data;</a>
<a name="ln107">    }</a>
<a name="ln108"> </a>
<a name="ln109">    return rc;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">static int</a>
<a name="ln113">dispatch_stdout(gpointer userdata)</a>
<a name="ln114">{</a>
<a name="ln115">    svc_action_t *op = (svc_action_t *) userdata;</a>
<a name="ln116"> </a>
<a name="ln117">    return svc_read_output(op-&gt;opaque-&gt;stdout_fd, op, FALSE);</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">static int</a>
<a name="ln121">dispatch_stderr(gpointer userdata)</a>
<a name="ln122">{</a>
<a name="ln123">    svc_action_t *op = (svc_action_t *) userdata;</a>
<a name="ln124"> </a>
<a name="ln125">    return svc_read_output(op-&gt;opaque-&gt;stderr_fd, op, TRUE);</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">static void</a>
<a name="ln129">pipe_out_done(gpointer user_data)</a>
<a name="ln130">{</a>
<a name="ln131">    svc_action_t *op = (svc_action_t *) user_data;</a>
<a name="ln132"> </a>
<a name="ln133">    crm_trace(&quot;%p&quot;, op);</a>
<a name="ln134"> </a>
<a name="ln135">    op-&gt;opaque-&gt;stdout_gsource = NULL;</a>
<a name="ln136">    if (op-&gt;opaque-&gt;stdout_fd &gt; STDOUT_FILENO) {</a>
<a name="ln137">        close(op-&gt;opaque-&gt;stdout_fd);</a>
<a name="ln138">    }</a>
<a name="ln139">    op-&gt;opaque-&gt;stdout_fd = -1;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">static void</a>
<a name="ln143">pipe_err_done(gpointer user_data)</a>
<a name="ln144">{</a>
<a name="ln145">    svc_action_t *op = (svc_action_t *) user_data;</a>
<a name="ln146"> </a>
<a name="ln147">    op-&gt;opaque-&gt;stderr_gsource = NULL;</a>
<a name="ln148">    if (op-&gt;opaque-&gt;stderr_fd &gt; STDERR_FILENO) {</a>
<a name="ln149">        close(op-&gt;opaque-&gt;stderr_fd);</a>
<a name="ln150">    }</a>
<a name="ln151">    op-&gt;opaque-&gt;stderr_fd = -1;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">static struct mainloop_fd_callbacks stdout_callbacks = {</a>
<a name="ln155">    .dispatch = dispatch_stdout,</a>
<a name="ln156">    .destroy = pipe_out_done,</a>
<a name="ln157">};</a>
<a name="ln158"> </a>
<a name="ln159">static struct mainloop_fd_callbacks stderr_callbacks = {</a>
<a name="ln160">    .dispatch = dispatch_stderr,</a>
<a name="ln161">    .destroy = pipe_err_done,</a>
<a name="ln162">};</a>
<a name="ln163"> </a>
<a name="ln164">static void</a>
<a name="ln165">set_ocf_env(const char *key, const char *value, gpointer user_data)</a>
<a name="ln166">{</a>
<a name="ln167">    if (setenv(key, value, 1) != 0) {</a>
<a name="ln168">        crm_perror(LOG_ERR, &quot;setenv failed for key:%s and value:%s&quot;, key, value);</a>
<a name="ln169">    }</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">static void</a>
<a name="ln173">set_ocf_env_with_prefix(gpointer key, gpointer value, gpointer user_data)</a>
<a name="ln174">{</a>
<a name="ln175">    char buffer[500];</a>
<a name="ln176"> </a>
<a name="ln177">    snprintf(buffer, sizeof(buffer), &quot;OCF_RESKEY_%s&quot;, (char *)key);</a>
<a name="ln178">    set_ocf_env(buffer, value, user_data);</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">static void</a>
<a name="ln182">add_OCF_env_vars(svc_action_t * op)</a>
<a name="ln183">{</a>
<a name="ln184">    if ((op-&gt;standard == NULL)</a>
<a name="ln185">        || (strcasecmp(PCMK_RESOURCE_CLASS_OCF, op-&gt;standard) != 0)) {</a>
<a name="ln186">        return;</a>
<a name="ln187">    }</a>
<a name="ln188"> </a>
<a name="ln189">    if (op-&gt;params) {</a>
<a name="ln190">        g_hash_table_foreach(op-&gt;params, set_ocf_env_with_prefix, NULL);</a>
<a name="ln191">    }</a>
<a name="ln192"> </a>
<a name="ln193">    set_ocf_env(&quot;OCF_RA_VERSION_MAJOR&quot;, &quot;1&quot;, NULL);</a>
<a name="ln194">    set_ocf_env(&quot;OCF_RA_VERSION_MINOR&quot;, &quot;0&quot;, NULL);</a>
<a name="ln195">    set_ocf_env(&quot;OCF_ROOT&quot;, OCF_ROOT_DIR, NULL);</a>
<a name="ln196">    set_ocf_env(&quot;OCF_EXIT_REASON_PREFIX&quot;, PCMK_OCF_REASON_PREFIX, NULL);</a>
<a name="ln197"> </a>
<a name="ln198">    if (op-&gt;rsc) {</a>
<a name="ln199">        set_ocf_env(&quot;OCF_RESOURCE_INSTANCE&quot;, op-&gt;rsc, NULL);</a>
<a name="ln200">    }</a>
<a name="ln201"> </a>
<a name="ln202">    if (op-&gt;agent != NULL) {</a>
<a name="ln203">        set_ocf_env(&quot;OCF_RESOURCE_TYPE&quot;, op-&gt;agent, NULL);</a>
<a name="ln204">    }</a>
<a name="ln205"> </a>
<a name="ln206">    /* Notes: this is not added to specification yet. Sept 10,2004 */</a>
<a name="ln207">    if (op-&gt;provider != NULL) {</a>
<a name="ln208">        set_ocf_env(&quot;OCF_RESOURCE_PROVIDER&quot;, op-&gt;provider, NULL);</a>
<a name="ln209">    }</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">gboolean</a>
<a name="ln213">recurring_action_timer(gpointer data)</a>
<a name="ln214">{</a>
<a name="ln215">    svc_action_t *op = data;</a>
<a name="ln216"> </a>
<a name="ln217">    crm_debug(&quot;Scheduling another invocation of %s&quot;, op-&gt;id);</a>
<a name="ln218"> </a>
<a name="ln219">    /* Clean out the old result */</a>
<a name="ln220">    free(op-&gt;stdout_data);</a>
<a name="ln221">    op-&gt;stdout_data = NULL;</a>
<a name="ln222">    free(op-&gt;stderr_data);</a>
<a name="ln223">    op-&gt;stderr_data = NULL;</a>
<a name="ln224">    op-&gt;opaque-&gt;repeat_timer = 0;</a>
<a name="ln225"> </a>
<a name="ln226">    services_action_async(op, NULL);</a>
<a name="ln227">    return FALSE;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">/* Returns FALSE if 'op' should be free'd by the caller */</a>
<a name="ln231">gboolean</a>
<a name="ln232">operation_finalize(svc_action_t * op)</a>
<a name="ln233">{</a>
<a name="ln234">    int recurring = 0;</a>
<a name="ln235"> </a>
<a name="ln236">    if (op-&gt;interval) {</a>
<a name="ln237">        if (op-&gt;cancel) {</a>
<a name="ln238">            op-&gt;status = PCMK_LRM_OP_CANCELLED;</a>
<a name="ln239">            cancel_recurring_action(op);</a>
<a name="ln240">        } else {</a>
<a name="ln241">            recurring = 1;</a>
<a name="ln242">            op-&gt;opaque-&gt;repeat_timer = g_timeout_add(op-&gt;interval,</a>
<a name="ln243">                                                     recurring_action_timer, (void *)op);</a>
<a name="ln244">        }</a>
<a name="ln245">    }</a>
<a name="ln246"> </a>
<a name="ln247">    if (op-&gt;opaque-&gt;callback) {</a>
<a name="ln248">        op-&gt;opaque-&gt;callback(op);</a>
<a name="ln249">    }</a>
<a name="ln250"> </a>
<a name="ln251">    op-&gt;pid = 0;</a>
<a name="ln252"> </a>
<a name="ln253">    services_untrack_op(op);</a>
<a name="ln254"> </a>
<a name="ln255">    if (!recurring &amp;&amp; op-&gt;synchronous == FALSE) {</a>
<a name="ln256">        /*</a>
<a name="ln257">         * If this is a recurring action, do not free explicitly.</a>
<a name="ln258">         * It will get freed whenever the action gets cancelled.</a>
<a name="ln259">         */</a>
<a name="ln260">        services_action_free(op);</a>
<a name="ln261">        return TRUE;</a>
<a name="ln262">    }</a>
<a name="ln263"> </a>
<a name="ln264">    services_action_cleanup(op);</a>
<a name="ln265">    return FALSE;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">static void</a>
<a name="ln269">operation_finished(mainloop_child_t * p, pid_t pid, int core, int signo, int exitcode)</a>
<a name="ln270">{</a>
<a name="ln271">    svc_action_t *op = mainloop_child_userdata(p);</a>
<a name="ln272">    char *prefix = crm_strdup_printf(&quot;%s:%d&quot;, op-&gt;id, op-&gt;pid);</a>
<a name="ln273"> </a>
<a name="ln274">    mainloop_clear_child_userdata(p);</a>
<a name="ln275">    op-&gt;status = PCMK_LRM_OP_DONE;</a>
<a name="ln276">    CRM_ASSERT(op-&gt;pid == pid);</a>
<a name="ln277"> </a>
<a name="ln278">    crm_trace(&quot;%s %p %p&quot;, prefix, op-&gt;opaque-&gt;stderr_gsource, op-&gt;opaque-&gt;stdout_gsource);</a>
<a name="ln279">    if (op-&gt;opaque-&gt;stderr_gsource) {</a>
<a name="ln280">        /* Make sure we have read everything from the buffer.</a>
<a name="ln281">         * Depending on the priority mainloop gives the fd, operation_finished</a>
<a name="ln282">         * could occur before all the reads are done.  Force the read now.*/</a>
<a name="ln283">        crm_trace(&quot;%s dispatching stderr&quot;, prefix);</a>
<a name="ln284">        dispatch_stderr(op);</a>
<a name="ln285">        crm_trace(&quot;%s: %p&quot;, op-&gt;id, op-&gt;stderr_data);</a>
<a name="ln286">        mainloop_del_fd(op-&gt;opaque-&gt;stderr_gsource);</a>
<a name="ln287">        op-&gt;opaque-&gt;stderr_gsource = NULL;</a>
<a name="ln288">    }</a>
<a name="ln289"> </a>
<a name="ln290">    if (op-&gt;opaque-&gt;stdout_gsource) {</a>
<a name="ln291">        /* Make sure we have read everything from the buffer.</a>
<a name="ln292">         * Depending on the priority mainloop gives the fd, operation_finished</a>
<a name="ln293">         * could occur before all the reads are done.  Force the read now.*/</a>
<a name="ln294">        crm_trace(&quot;%s dispatching stdout&quot;, prefix);</a>
<a name="ln295">        dispatch_stdout(op);</a>
<a name="ln296">        crm_trace(&quot;%s: %p&quot;, op-&gt;id, op-&gt;stdout_data);</a>
<a name="ln297">        mainloop_del_fd(op-&gt;opaque-&gt;stdout_gsource);</a>
<a name="ln298">        op-&gt;opaque-&gt;stdout_gsource = NULL;</a>
<a name="ln299">    }</a>
<a name="ln300"> </a>
<a name="ln301">    if (signo) {</a>
<a name="ln302">        if (mainloop_child_timeout(p)) {</a>
<a name="ln303">            crm_warn(&quot;%s - timed out after %dms&quot;, prefix, op-&gt;timeout);</a>
<a name="ln304">            op-&gt;status = PCMK_LRM_OP_TIMEOUT;</a>
<a name="ln305">            op-&gt;rc = PCMK_OCF_TIMEOUT;</a>
<a name="ln306"> </a>
<a name="ln307">        } else {</a>
<a name="ln308">            do_crm_log_unlikely((op-&gt;cancel) ? LOG_INFO : LOG_WARNING,</a>
<a name="ln309">                                &quot;%s - terminated with signal %d&quot;, prefix, signo);</a>
<a name="ln310">            op-&gt;status = PCMK_LRM_OP_ERROR;</a>
<a name="ln311">            op-&gt;rc = PCMK_OCF_SIGNAL;</a>
<a name="ln312">        }</a>
<a name="ln313"> </a>
<a name="ln314">    } else {</a>
<a name="ln315">        op-&gt;rc = exitcode;</a>
<a name="ln316">        crm_debug(&quot;%s - exited with rc=%d&quot;, prefix, exitcode);</a>
<a name="ln317">    }</a>
<a name="ln318"> </a>
<a name="ln319">    free(prefix);</a>
<a name="ln320">    prefix = crm_strdup_printf(&quot;%s:%d:stderr&quot;, op-&gt;id, op-&gt;pid);</a>
<a name="ln321">    crm_log_output(LOG_NOTICE, prefix, op-&gt;stderr_data);</a>
<a name="ln322"> </a>
<a name="ln323">    free(prefix);</a>
<a name="ln324">    prefix = crm_strdup_printf(&quot;%s:%d:stdout&quot;, op-&gt;id, op-&gt;pid);</a>
<a name="ln325">    crm_log_output(LOG_DEBUG, prefix, op-&gt;stdout_data);</a>
<a name="ln326"> </a>
<a name="ln327">    free(prefix);</a>
<a name="ln328">    operation_finalize(op);</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">/*!</a>
<a name="ln332"> * \internal</a>
<a name="ln333"> * \brief Set operation rc and status per errno from stat(), fork() or execvp()</a>
<a name="ln334"> *</a>
<a name="ln335"> * \param[in,out] op     Operation to set rc and status for</a>
<a name="ln336"> * \param[in]     error  Value of errno after system call</a>
<a name="ln337"> *</a>
<a name="ln338"> * \return void</a>
<a name="ln339"> */</a>
<a name="ln340">static void</a>
<a name="ln341">services_handle_exec_error(svc_action_t * op, int error)</a>
<a name="ln342">{</a>
<a name="ln343">    int rc_not_installed, rc_insufficient_priv, rc_exec_error;</a>
<a name="ln344"> </a>
<a name="ln345">    /* Mimic the return codes for each standard as that's what we'll convert back from in get_uniform_rc() */</a>
<a name="ln346">    if (safe_str_eq(op-&gt;standard, PCMK_RESOURCE_CLASS_LSB)</a>
<a name="ln347">        &amp;&amp; safe_str_eq(op-&gt;action, &quot;status&quot;)) {</a>
<a name="ln348"> </a>
<a name="ln349">        rc_not_installed = PCMK_LSB_STATUS_NOT_INSTALLED;</a>
<a name="ln350">        rc_insufficient_priv = PCMK_LSB_STATUS_INSUFFICIENT_PRIV;</a>
<a name="ln351">        rc_exec_error = PCMK_LSB_STATUS_UNKNOWN;</a>
<a name="ln352"> </a>
<a name="ln353">#if SUPPORT_NAGIOS</a>
<a name="ln354">    } else if (safe_str_eq(op-&gt;standard, PCMK_RESOURCE_CLASS_NAGIOS)) {</a>
<a name="ln355">        rc_not_installed = NAGIOS_NOT_INSTALLED;</a>
<a name="ln356">        rc_insufficient_priv = NAGIOS_INSUFFICIENT_PRIV;</a>
<a name="ln357">        rc_exec_error = PCMK_OCF_EXEC_ERROR;</a>
<a name="ln358">#endif</a>
<a name="ln359"> </a>
<a name="ln360">    } else {</a>
<a name="ln361">        rc_not_installed = PCMK_OCF_NOT_INSTALLED;</a>
<a name="ln362">        rc_insufficient_priv = PCMK_OCF_INSUFFICIENT_PRIV;</a>
<a name="ln363">        rc_exec_error = PCMK_OCF_EXEC_ERROR;</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">    switch (error) {   /* see execve(2), stat(2) and fork(2) */</a>
<a name="ln367">        case ENOENT:   /* No such file or directory */</a>
<a name="ln368">        case EISDIR:   /* Is a directory */</a>
<a name="ln369">        case ENOTDIR:  /* Path component is not a directory */</a>
<a name="ln370">        case EINVAL:   /* Invalid executable format */</a>
<a name="ln371">        case ENOEXEC:  /* Invalid executable format */</a>
<a name="ln372">            op-&gt;rc = rc_not_installed;</a>
<a name="ln373">            op-&gt;status = PCMK_LRM_OP_NOT_INSTALLED;</a>
<a name="ln374">            break;</a>
<a name="ln375">        case EACCES:   /* permission denied (various errors) */</a>
<a name="ln376">        case EPERM:    /* permission denied (various errors) */</a>
<a name="ln377">            op-&gt;rc = rc_insufficient_priv;</a>
<a name="ln378">            op-&gt;status = PCMK_LRM_OP_ERROR;</a>
<a name="ln379">            break;</a>
<a name="ln380">        default:</a>
<a name="ln381">            op-&gt;rc = rc_exec_error;</a>
<a name="ln382">            op-&gt;status = PCMK_LRM_OP_ERROR;</a>
<a name="ln383">    }</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">static void</a>
<a name="ln387">action_launch_child(svc_action_t *op)</a>
<a name="ln388">{</a>
<a name="ln389">    int lpc;</a>
<a name="ln390"> </a>
<a name="ln391">    /* SIGPIPE is ignored (which is different from signal blocking) by the gnutls library.</a>
<a name="ln392">     * Depending on the libqb version in use, libqb may set SIGPIPE to be ignored as well. </a>
<a name="ln393">     * We do not want this to be inherited by the child process. By resetting this the signal</a>
<a name="ln394">     * to the default behavior, we avoid some potential odd problems that occur during OCF</a>
<a name="ln395">     * scripts when SIGPIPE is ignored by the environment. */</a>
<a name="ln396">    signal(SIGPIPE, SIG_DFL);</a>
<a name="ln397"> </a>
<a name="ln398">#if defined(HAVE_SCHED_SETSCHEDULER)</a>
<a name="ln399">    if (sched_getscheduler(0) != SCHED_OTHER) {</a>
<a name="ln400">        struct sched_param sp;</a>
<a name="ln401"> </a>
<a name="ln402">        memset(&amp;sp, 0, sizeof(sp));</a>
<a name="ln403">        sp.sched_priority = 0;</a>
<a name="ln404"> </a>
<a name="ln405">        if (sched_setscheduler(0, SCHED_OTHER, &amp;sp) == -1) {</a>
<a name="ln406">            crm_perror(LOG_ERR, &quot;Could not reset scheduling policy to SCHED_OTHER for %s&quot;, op-&gt;id);</a>
<a name="ln407">        }</a>
<a name="ln408">    }</a>
<a name="ln409">#endif</a>
<a name="ln410">    if (setpriority(PRIO_PROCESS, 0, 0) == -1) {</a>
<a name="ln411">        crm_perror(LOG_ERR, &quot;Could not reset process priority to 0 for %s&quot;, op-&gt;id);</a>
<a name="ln412">    }</a>
<a name="ln413"> </a>
<a name="ln414">    /* Man: The call setpgrp() is equivalent to setpgid(0,0)</a>
<a name="ln415">     * _and_ compiles on BSD variants too</a>
<a name="ln416">     * need to investigate if it works the same too.</a>
<a name="ln417">     */</a>
<a name="ln418">    setpgid(0, 0);</a>
<a name="ln419"> </a>
<a name="ln420">    /* close all descriptors except stdin/out/err and channels to logd */</a>
<a name="ln421">    for (lpc = getdtablesize() - 1; lpc &gt; STDERR_FILENO; lpc--) {</a>
<a name="ln422">        close(lpc);</a>
<a name="ln423">    }</a>
<a name="ln424"> </a>
<a name="ln425">#if SUPPORT_CIBSECRETS</a>
<a name="ln426">    if (replace_secret_params(op-&gt;rsc, op-&gt;params) &lt; 0) {</a>
<a name="ln427">        /* replacing secrets failed! */</a>
<a name="ln428">        if (safe_str_eq(op-&gt;action,&quot;stop&quot;)) {</a>
<a name="ln429">            /* don't fail on stop! */</a>
<a name="ln430">            crm_info(&quot;proceeding with the stop operation for %s&quot;, op-&gt;rsc);</a>
<a name="ln431"> </a>
<a name="ln432">        } else {</a>
<a name="ln433">            crm_err(&quot;failed to get secrets for %s, &quot;</a>
<a name="ln434">                    &quot;considering resource not configured&quot;, op-&gt;rsc);</a>
<a name="ln435">            _exit(PCMK_OCF_NOT_CONFIGURED);</a>
<a name="ln436">        }</a>
<a name="ln437">    }</a>
<a name="ln438">#endif</a>
<a name="ln439">    /* Setup environment correctly */</a>
<a name="ln440">    add_OCF_env_vars(op);</a>
<a name="ln441"> </a>
<a name="ln442">    /* execute the RA */</a>
<a name="ln443">    execvp(op-&gt;opaque-&gt;exec, op-&gt;opaque-&gt;args);</a>
<a name="ln444"> </a>
<a name="ln445">    /* Most cases should have been already handled by stat() */</a>
<a name="ln446">    services_handle_exec_error(op, errno);</a>
<a name="ln447"> </a>
<a name="ln448">    _exit(op-&gt;rc);</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">#ifndef HAVE_SYS_SIGNALFD_H</a>
<a name="ln452">static int sigchld_pipe[2] = { -1, -1 };</a>
<a name="ln453"> </a>
<a name="ln454">static void</a>
<a name="ln455">sigchld_handler()</a>
<a name="ln456">{</a>
<a name="ln457">    if ((sigchld_pipe[1] &gt;= 0) &amp;&amp; (write(sigchld_pipe[1], &quot;&quot;, 1) == -1)) {</a>
<a name="ln458">        crm_perror(LOG_TRACE, &quot;Could not poke SIGCHLD self-pipe&quot;);</a>
<a name="ln459">    }</a>
<a name="ln460">}</a>
<a name="ln461">#endif</a>
<a name="ln462"> </a>
<a name="ln463">static void</a>
<a name="ln464">action_synced_wait(svc_action_t * op, sigset_t *mask)</a>
<a name="ln465">{</a>
<a name="ln466">    int status = 0;</a>
<a name="ln467">    int timeout = op-&gt;timeout;</a>
<a name="ln468">    int sfd = -1;</a>
<a name="ln469">    time_t start = -1;</a>
<a name="ln470">    struct pollfd fds[3];</a>
<a name="ln471">    int wait_rc = 0;</a>
<a name="ln472"> </a>
<a name="ln473">#ifdef HAVE_SYS_SIGNALFD_H</a>
<a name="ln474">    sfd = signalfd(-1, mask, SFD_NONBLOCK);</a>
<a name="ln475">    if (sfd &lt; 0) {</a>
<a name="ln476">        crm_perror(LOG_ERR, &quot;signalfd() failed&quot;);</a>
<a name="ln477">    }</a>
<a name="ln478">#else</a>
<a name="ln479">    sfd = sigchld_pipe[0];</a>
<a name="ln480">#endif</a>
<a name="ln481"> </a>
<a name="ln482">    fds[0].fd = op-&gt;opaque-&gt;stdout_fd;</a>
<a name="ln483">    fds[0].events = POLLIN;</a>
<a name="ln484">    fds[0].revents = 0;</a>
<a name="ln485"> </a>
<a name="ln486">    fds[1].fd = op-&gt;opaque-&gt;stderr_fd;</a>
<a name="ln487">    fds[1].events = POLLIN;</a>
<a name="ln488">    fds[1].revents = 0;</a>
<a name="ln489"> </a>
<a name="ln490">    fds[2].fd = sfd;</a>
<a name="ln491">    fds[2].events = POLLIN;</a>
<a name="ln492">    fds[2].revents = 0;</a>
<a name="ln493"> </a>
<a name="ln494">    crm_trace(&quot;Waiting for %d&quot;, op-&gt;pid);</a>
<a name="ln495">    start = time(NULL);</a>
<a name="ln496">    do {</a>
<a name="ln497">        int poll_rc = poll(fds, 3, timeout);</a>
<a name="ln498"> </a>
<a name="ln499">        if (poll_rc &gt; 0) {</a>
<a name="ln500">            if (fds[0].revents &amp; POLLIN) {</a>
<a name="ln501">                svc_read_output(op-&gt;opaque-&gt;stdout_fd, op, FALSE);</a>
<a name="ln502">            }</a>
<a name="ln503"> </a>
<a name="ln504">            if (fds[1].revents &amp; POLLIN) {</a>
<a name="ln505">                svc_read_output(op-&gt;opaque-&gt;stderr_fd, op, TRUE);</a>
<a name="ln506">            }</a>
<a name="ln507"> </a>
<a name="ln508">            if (fds[2].revents &amp; POLLIN) {</a>
<a name="ln509">#ifdef HAVE_SYS_SIGNALFD_H</a>
<a name="ln510">                struct signalfd_siginfo fdsi;</a>
<a name="ln511">                ssize_t s;</a>
<a name="ln512"> </a>
<a name="ln513">                s = read(sfd, &amp;fdsi, sizeof(struct signalfd_siginfo));</a>
<a name="ln514">                if (s != sizeof(struct signalfd_siginfo)) {</a>
<a name="ln515">                    crm_perror(LOG_ERR, &quot;Read from signal fd %d failed&quot;, sfd);</a>
<a name="ln516"> </a>
<a name="ln517">                } else if (fdsi.ssi_signo == SIGCHLD) {</a>
<a name="ln518">#else</a>
<a name="ln519">                if (1) {</a>
<a name="ln520">                    /* Clear out the sigchld pipe. */</a>
<a name="ln521">                    char ch;</a>
<a name="ln522">                    while (read(sfd, &amp;ch, 1) == 1) /*omit*/;</a>
<a name="ln523">#endif</a>
<a name="ln524">                    wait_rc = waitpid(op-&gt;pid, &amp;status, WNOHANG);</a>
<a name="ln525"> </a>
<a name="ln526">                    if (wait_rc &gt; 0) {</a>
<a name="ln527">                        break;</a>
<a name="ln528"> </a>
<a name="ln529">                    } else if (wait_rc &lt; 0){</a>
<a name="ln530">                        if (errno == ECHILD) {</a>
<a name="ln531">                                /* Here, don't dare to kill and bail out... */</a>
<a name="ln532">                                break;</a>
<a name="ln533"> </a>
<a name="ln534">                        } else {</a>
<a name="ln535">                                /* ...otherwise pretend process still runs. */</a>
<a name="ln536">                                wait_rc = 0;</a>
<a name="ln537">                        }</a>
<a name="ln538">                        crm_perror(LOG_ERR, &quot;waitpid() for %d failed&quot;, op-&gt;pid);</a>
<a name="ln539">                    }</a>
<a name="ln540">                }</a>
<a name="ln541">            }</a>
<a name="ln542"> </a>
<a name="ln543">        } else if (poll_rc == 0) {</a>
<a name="ln544">            timeout = 0;</a>
<a name="ln545">            break;</a>
<a name="ln546"> </a>
<a name="ln547">        } else if (poll_rc &lt; 0) {</a>
<a name="ln548">            if (errno != EINTR) {</a>
<a name="ln549">                crm_perror(LOG_ERR, &quot;poll() failed&quot;);</a>
<a name="ln550">                break;</a>
<a name="ln551">            }</a>
<a name="ln552">        }</a>
<a name="ln553"> </a>
<a name="ln554">        timeout = op-&gt;timeout - (time(NULL) - start) * 1000;</a>
<a name="ln555"> </a>
<a name="ln556">    } while ((op-&gt;timeout &lt; 0 || timeout &gt; 0));</a>
<a name="ln557"> </a>
<a name="ln558">    crm_trace(&quot;Child done: %d&quot;, op-&gt;pid);</a>
<a name="ln559">    if (wait_rc &lt;= 0) {</a>
<a name="ln560">        op-&gt;rc = PCMK_OCF_UNKNOWN_ERROR;</a>
<a name="ln561"> </a>
<a name="ln562">        if (op-&gt;timeout &gt; 0 &amp;&amp; timeout &lt;= 0) {</a>
<a name="ln563">            op-&gt;status = PCMK_LRM_OP_TIMEOUT;</a>
<a name="ln564">            crm_warn(&quot;%s:%d - timed out after %dms&quot;, op-&gt;id, op-&gt;pid, op-&gt;timeout);</a>
<a name="ln565"> </a>
<a name="ln566">        } else {</a>
<a name="ln567">            op-&gt;status = PCMK_LRM_OP_ERROR;</a>
<a name="ln568">        }</a>
<a name="ln569"> </a>
<a name="ln570">        /* If only child hasn't been successfully waited for, yet.</a>
<a name="ln571">           This is to limit killing wrong target a bit more. */</a>
<a name="ln572">        if (wait_rc == 0 &amp;&amp; waitpid(op-&gt;pid, &amp;status, WNOHANG) == 0) {</a>
<a name="ln573">            if (kill(op-&gt;pid, SIGKILL)) {</a>
<a name="ln574">                crm_err(&quot;kill(%d, KILL) failed: %d&quot;, op-&gt;pid, errno);</a>
<a name="ln575">            }</a>
<a name="ln576">            /* Safe to skip WNOHANG here as we sent non-ignorable signal. */</a>
<a name="ln577">            while (waitpid(op-&gt;pid, &amp;status, 0) == (pid_t) -1 &amp;&amp; errno == EINTR) /*omit*/;</a>
<a name="ln578">        }</a>
<a name="ln579"> </a>
<a name="ln580">    } else if (WIFEXITED(status)) {</a>
<a name="ln581">        op-&gt;status = PCMK_LRM_OP_DONE;</a>
<a name="ln582">        op-&gt;rc = WEXITSTATUS(status);</a>
<a name="ln583">        crm_info(&quot;Managed %s process %d exited with rc=%d&quot;, op-&gt;id, op-&gt;pid, op-&gt;rc);</a>
<a name="ln584"> </a>
<a name="ln585">    } else if (WIFSIGNALED(status)) {</a>
<a name="ln586">        int signo = WTERMSIG(status);</a>
<a name="ln587"> </a>
<a name="ln588">        op-&gt;status = PCMK_LRM_OP_ERROR;</a>
<a name="ln589">        crm_err(&quot;Managed %s process %d exited with signal=%d&quot;, op-&gt;id, op-&gt;pid, signo);</a>
<a name="ln590">    }</a>
<a name="ln591">#ifdef WCOREDUMP</a>
<a name="ln592">    if (WCOREDUMP(status)) {</a>
<a name="ln593">        crm_err(&quot;Managed %s process %d dumped core&quot;, op-&gt;id, op-&gt;pid);</a>
<a name="ln594">    }</a>
<a name="ln595">#endif</a>
<a name="ln596"> </a>
<a name="ln597">    svc_read_output(op-&gt;opaque-&gt;stdout_fd, op, FALSE);</a>
<a name="ln598">    svc_read_output(op-&gt;opaque-&gt;stderr_fd, op, TRUE);</a>
<a name="ln599"> </a>
<a name="ln600">    close(op-&gt;opaque-&gt;stdout_fd);</a>
<a name="ln601">    close(op-&gt;opaque-&gt;stderr_fd);</a>
<a name="ln602"> </a>
<a name="ln603">#ifdef HAVE_SYS_SIGNALFD_H</a>
<a name="ln604">    close(sfd);</a>
<a name="ln605">#endif</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">/* For an asynchronous 'op', returns FALSE if 'op' should be free'd by the caller */</a>
<a name="ln609">/* For a synchronous 'op', returns FALSE if 'op' fails */</a>
<a name="ln610">gboolean</a>
<a name="ln611">services_os_action_execute(svc_action_t * op)</a>
<a name="ln612">{</a>
<a name="ln613">    int stdout_fd[2];</a>
<a name="ln614">    int stderr_fd[2];</a>
<a name="ln615">    struct stat st;</a>
<a name="ln616">    sigset_t *pmask;</a>
<a name="ln617"> </a>
<a name="ln618">#ifdef HAVE_SYS_SIGNALFD_H</a>
<a name="ln619">    sigset_t mask;</a>
<a name="ln620">    sigset_t old_mask;</a>
<a name="ln621">#define sigchld_cleanup() do {                                                \</a>
<a name="ln622">    if (sigismember(&amp;old_mask, SIGCHLD) == 0) {                               \</a>
<a name="ln623">        if (sigprocmask(SIG_UNBLOCK, &amp;mask, NULL) &lt; 0) {                      \</a>
<a name="ln624">            crm_perror(LOG_ERR, &quot;sigprocmask() failed to unblock sigchld&quot;);   \</a>
<a name="ln625">        }                                                                     \</a>
<a name="ln626">    }                                                                         \</a>
<a name="ln627">} while (0)</a>
<a name="ln628">#else</a>
<a name="ln629">    struct sigaction sa;</a>
<a name="ln630">    struct sigaction old_sa;</a>
<a name="ln631">#define sigchld_cleanup() do {                                                \</a>
<a name="ln632">    if (sigaction(SIGCHLD, &amp;old_sa, NULL) &lt; 0) {                              \</a>
<a name="ln633">        crm_perror(LOG_ERR, &quot;sigaction() failed to remove sigchld handler&quot;);  \</a>
<a name="ln634">    }                                                                         \</a>
<a name="ln635">    close(sigchld_pipe[0]);                                                   \</a>
<a name="ln636">    close(sigchld_pipe[1]);                                                   \</a>
<a name="ln637">    sigchld_pipe[0] = sigchld_pipe[1] = -1;                                   \</a>
<a name="ln638">} while(0)</a>
<a name="ln639">#endif</a>
<a name="ln640"> </a>
<a name="ln641">    /* Fail fast */</a>
<a name="ln642">    if(stat(op-&gt;opaque-&gt;exec, &amp;st) != 0) {</a>
<a name="ln643">        int rc = errno;</a>
<a name="ln644">        crm_warn(&quot;Cannot execute '%s': %s (%d)&quot;, op-&gt;opaque-&gt;exec, pcmk_strerror(rc), rc);</a>
<a name="ln645">        services_handle_exec_error(op, rc);</a>
<a name="ln646">        if (!op-&gt;synchronous) {</a>
<a name="ln647">            return operation_finalize(op);</a>
<a name="ln648">        }</a>
<a name="ln649">        return FALSE;</a>
<a name="ln650">    }</a>
<a name="ln651"> </a>
<a name="ln652">    if (pipe(stdout_fd) &lt; 0) {</a>
<a name="ln653">        int rc = errno;</a>
<a name="ln654"> </a>
<a name="ln655">        crm_err(&quot;pipe(stdout_fd) failed. '%s': %s (%d)&quot;, op-&gt;opaque-&gt;exec, pcmk_strerror(rc), rc);</a>
<a name="ln656"> </a>
<a name="ln657">        services_handle_exec_error(op, rc);</a>
<a name="ln658">        if (!op-&gt;synchronous) {</a>
<a name="ln659">            return operation_finalize(op);</a>
<a name="ln660">        }</a>
<a name="ln661">        return FALSE;</a>
<a name="ln662">    }</a>
<a name="ln663"> </a>
<a name="ln664">    if (pipe(stderr_fd) &lt; 0) {</a>
<a name="ln665">        int rc = errno;</a>
<a name="ln666"> </a>
<a name="ln667">        close(stdout_fd[0]);</a>
<a name="ln668">        close(stdout_fd[1]);</a>
<a name="ln669"> </a>
<a name="ln670">        crm_err(&quot;pipe(stderr_fd) failed. '%s': %s (%d)&quot;, op-&gt;opaque-&gt;exec, pcmk_strerror(rc), rc);</a>
<a name="ln671"> </a>
<a name="ln672">        services_handle_exec_error(op, rc);</a>
<a name="ln673">        if (!op-&gt;synchronous) {</a>
<a name="ln674">            return operation_finalize(op);</a>
<a name="ln675">        }</a>
<a name="ln676">        return FALSE;</a>
<a name="ln677">    }</a>
<a name="ln678"> </a>
<a name="ln679">    if (op-&gt;synchronous) {</a>
<a name="ln680">#ifdef HAVE_SYS_SIGNALFD_H</a>
<a name="ln681">        sigemptyset(&amp;mask);</a>
<a name="ln682">        sigaddset(&amp;mask, SIGCHLD);</a>
<a name="ln683">        sigemptyset(&amp;old_mask);</a>
<a name="ln684"> </a>
<a name="ln685">        if (sigprocmask(SIG_BLOCK, &amp;mask, &amp;old_mask) &lt; 0) {</a>
<a name="ln686">            crm_perror(LOG_ERR, &quot;sigprocmask() failed to block sigchld&quot;);</a>
<a name="ln687">        }</a>
<a name="ln688"> </a>
<a name="ln689">        pmask = &amp;mask;</a>
<a name="ln690">#else</a>
<a name="ln691">        if(pipe(sigchld_pipe) == -1) {</a>
<a name="ln692">            crm_perror(LOG_ERR, &quot;pipe() failed&quot;);</a>
<a name="ln693">        }</a>
<a name="ln694"> </a>
<a name="ln695">        set_fd_opts(sigchld_pipe[0], O_NONBLOCK);</a>
<a name="ln696">        set_fd_opts(sigchld_pipe[1], O_NONBLOCK);</a>
<a name="ln697"> </a>
<a name="ln698">        sa.sa_handler = sigchld_handler;</a>
<a name="ln699">        sa.sa_flags = 0;</a>
<a name="ln700">        sigemptyset(&amp;sa.sa_mask);</a>
<a name="ln701">        if (sigaction(SIGCHLD, &amp;sa, &amp;old_sa) &lt; 0) {</a>
<a name="ln702">            crm_perror(LOG_ERR, &quot;sigaction() failed to set sigchld handler&quot;);</a>
<a name="ln703">        }</a>
<a name="ln704"> </a>
<a name="ln705">        pmask = NULL;</a>
<a name="ln706">#endif</a>
<a name="ln707">    }</a>
<a name="ln708"> </a>
<a name="ln709">    op-&gt;pid = fork();</a>
<a name="ln710">    switch (op-&gt;pid) {</a>
<a name="ln711">        case -1:</a>
<a name="ln712">            {</a>
<a name="ln713">                int rc = errno;</a>
<a name="ln714"> </a>
<a name="ln715">                close(stdout_fd[0]);</a>
<a name="ln716">                close(stdout_fd[1]);</a>
<a name="ln717">                close(stderr_fd[0]);</a>
<a name="ln718">                close(stderr_fd[1]);</a>
<a name="ln719"> </a>
<a name="ln720">                crm_err(&quot;Could not execute '%s': %s (%d)&quot;, op-&gt;opaque-&gt;exec, pcmk_strerror(rc), rc);</a>
<a name="ln721">                services_handle_exec_error(op, rc);</a>
<a name="ln722">                if (!op-&gt;synchronous) {</a>
<a name="ln723">                    return operation_finalize(op);</a>
<a name="ln724">                }</a>
<a name="ln725"> </a>
<a name="ln726">                sigchld_cleanup();</a>
<a name="ln727">                return FALSE;</a>
<a name="ln728">            }</a>
<a name="ln729">        case 0:                /* Child */</a>
<a name="ln730">            close(stdout_fd[0]);</a>
<a name="ln731">            close(stderr_fd[0]);</a>
<a name="ln732">            if (STDOUT_FILENO != stdout_fd[1]) {</a>
<a name="ln733">                if (dup2(stdout_fd[1], STDOUT_FILENO) != STDOUT_FILENO) {</a>
<a name="ln734">                    crm_err(&quot;dup2() failed (stdout)&quot;);</a>
<a name="ln735">                }</a>
<a name="ln736">                close(stdout_fd[1]);</a>
<a name="ln737">            }</a>
<a name="ln738">            if (STDERR_FILENO != stderr_fd[1]) {</a>
<a name="ln739">                if (dup2(stderr_fd[1], STDERR_FILENO) != STDERR_FILENO) {</a>
<a name="ln740">                    crm_err(&quot;dup2() failed (stderr)&quot;);</a>
<a name="ln741">                }</a>
<a name="ln742">                close(stderr_fd[1]);</a>
<a name="ln743">            }</a>
<a name="ln744"> </a>
<a name="ln745">            if (op-&gt;synchronous) {</a>
<a name="ln746">                sigchld_cleanup();</a>
<a name="ln747">            }</a>
<a name="ln748"> </a>
<a name="ln749">            action_launch_child(op);</a>
<a name="ln750">            CRM_ASSERT(0);  /* action_launch_child is effectively noreturn */</a>
<a name="ln751">    }</a>
<a name="ln752"> </a>
<a name="ln753">    /* Only the parent reaches here */</a>
<a name="ln754">    close(stdout_fd[1]);</a>
<a name="ln755">    close(stderr_fd[1]);</a>
<a name="ln756"> </a>
<a name="ln757">    op-&gt;opaque-&gt;stdout_fd = stdout_fd[0];</a>
<a name="ln758">    set_fd_opts(op-&gt;opaque-&gt;stdout_fd, O_NONBLOCK);</a>
<a name="ln759"> </a>
<a name="ln760">    op-&gt;opaque-&gt;stderr_fd = stderr_fd[0];</a>
<a name="ln761">    set_fd_opts(op-&gt;opaque-&gt;stderr_fd, O_NONBLOCK);</a>
<a name="ln762"> </a>
<a name="ln763">    if (op-&gt;synchronous) {</a>
<a name="ln764">        action_synced_wait(op, pmask);</a>
<a name="ln765">        sigchld_cleanup();</a>
<a name="ln766">    } else {</a>
<a name="ln767"> </a>
<a name="ln768">        crm_trace(&quot;Async waiting for %d - %s&quot;, op-&gt;pid, op-&gt;opaque-&gt;exec);</a>
<a name="ln769">        mainloop_child_add_with_flags(op-&gt;pid,</a>
<a name="ln770">                                      op-&gt;timeout,</a>
<a name="ln771">                                      op-&gt;id,</a>
<a name="ln772">                                      op,</a>
<a name="ln773">                                      (op-&gt;flags &amp; SVC_ACTION_LEAVE_GROUP) ? mainloop_leave_pid_group : 0,</a>
<a name="ln774">                                      operation_finished);</a>
<a name="ln775"> </a>
<a name="ln776"> </a>
<a name="ln777">        op-&gt;opaque-&gt;stdout_gsource = mainloop_add_fd(op-&gt;id,</a>
<a name="ln778">                                                     G_PRIORITY_LOW,</a>
<a name="ln779">                                                     op-&gt;opaque-&gt;stdout_fd, op, &amp;stdout_callbacks);</a>
<a name="ln780"> </a>
<a name="ln781">        op-&gt;opaque-&gt;stderr_gsource = mainloop_add_fd(op-&gt;id,</a>
<a name="ln782">                                                     G_PRIORITY_LOW,</a>
<a name="ln783">                                                     op-&gt;opaque-&gt;stderr_fd, op, &amp;stderr_callbacks);</a>
<a name="ln784"> </a>
<a name="ln785">        services_add_inflight_op(op);</a>
<a name="ln786">    }</a>
<a name="ln787"> </a>
<a name="ln788">    return TRUE;</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">GList *</a>
<a name="ln792">services_os_get_directory_list(const char *root, gboolean files, gboolean executable)</a>
<a name="ln793">{</a>
<a name="ln794">    GList *list = NULL;</a>
<a name="ln795">    struct dirent **namelist;</a>
<a name="ln796">    int entries = 0, lpc = 0;</a>
<a name="ln797">    char buffer[PATH_MAX];</a>
<a name="ln798"> </a>
<a name="ln799">    entries = scandir(root, &amp;namelist, NULL, alphasort);</a>
<a name="ln800">    if (entries &lt;= 0) {</a>
<a name="ln801">        return list;</a>
<a name="ln802">    }</a>
<a name="ln803"> </a>
<a name="ln804">    for (lpc = 0; lpc &lt; entries; lpc++) {</a>
<a name="ln805">        struct stat sb;</a>
<a name="ln806"> </a>
<a name="ln807">        if ('.' == namelist[lpc]-&gt;d_name[0]) {</a>
<a name="ln808">            free(namelist[lpc]);</a>
<a name="ln809">            continue;</a>
<a name="ln810">        }</a>
<a name="ln811"> </a>
<a name="ln812">        snprintf(buffer, sizeof(buffer), &quot;%s/%s&quot;, root, namelist[lpc]-&gt;d_name);</a>
<a name="ln813"> </a>
<a name="ln814">        if (stat(buffer, &amp;sb)) {</a>
<a name="ln815">            continue;</a>
<a name="ln816">        }</a>
<a name="ln817"> </a>
<a name="ln818">        if (S_ISDIR(sb.st_mode)) {</a>
<a name="ln819">            if (files) {</a>
<a name="ln820">                free(namelist[lpc]);</a>
<a name="ln821">                continue;</a>
<a name="ln822">            }</a>
<a name="ln823"> </a>
<a name="ln824">        } else if (S_ISREG(sb.st_mode)) {</a>
<a name="ln825">            if (files == FALSE) {</a>
<a name="ln826">                free(namelist[lpc]);</a>
<a name="ln827">                continue;</a>
<a name="ln828"> </a>
<a name="ln829">            } else if (executable</a>
<a name="ln830">                       &amp;&amp; (sb.st_mode &amp; S_IXUSR) == 0</a>
<a name="ln831">                       &amp;&amp; (sb.st_mode &amp; S_IXGRP) == 0 &amp;&amp; (sb.st_mode &amp; S_IXOTH) == 0) {</a>
<a name="ln832">                free(namelist[lpc]);</a>
<a name="ln833">                continue;</a>
<a name="ln834">            }</a>
<a name="ln835">        }</a>
<a name="ln836"> </a>
<a name="ln837">        list = g_list_append(list, strdup(namelist[lpc]-&gt;d_name));</a>
<a name="ln838"> </a>
<a name="ln839">        free(namelist[lpc]);</a>
<a name="ln840">    }</a>
<a name="ln841"> </a>
<a name="ln842">    free(namelist);</a>
<a name="ln843">    return list;</a>
<a name="ln844">}</a>
<a name="ln845"> </a>
<a name="ln846">GList *</a>
<a name="ln847">resources_os_list_lsb_agents(void)</a>
<a name="ln848">{</a>
<a name="ln849">    return get_directory_list(LSB_ROOT_DIR, TRUE, TRUE);</a>
<a name="ln850">}</a>
<a name="ln851"> </a>
<a name="ln852">GList *</a>
<a name="ln853">resources_os_list_ocf_providers(void)</a>
<a name="ln854">{</a>
<a name="ln855">    return get_directory_list(OCF_ROOT_DIR &quot;/resource.d&quot;, FALSE, TRUE);</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">GList *</a>
<a name="ln859">resources_os_list_ocf_agents(const char *provider)</a>
<a name="ln860">{</a>
<a name="ln861">    GList *gIter = NULL;</a>
<a name="ln862">    GList *result = NULL;</a>
<a name="ln863">    GList *providers = NULL;</a>
<a name="ln864"> </a>
<a name="ln865">    if (provider) {</a>
<a name="ln866">        char buffer[500];</a>
<a name="ln867"> </a>
<a name="ln868">        snprintf(buffer, sizeof(buffer), &quot;%s/resource.d/%s&quot;, OCF_ROOT_DIR, provider);</a>
<a name="ln869">        return get_directory_list(buffer, TRUE, TRUE);</a>
<a name="ln870">    }</a>
<a name="ln871"> </a>
<a name="ln872">    providers = resources_os_list_ocf_providers();</a>
<a name="ln873">    for (gIter = providers; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln874">        GList *tmp1 = result;</a>
<a name="ln875">        GList *tmp2 = resources_os_list_ocf_agents(gIter-&gt;data);</a>
<a name="ln876"> </a>
<a name="ln877">        if (tmp2) {</a>
<a name="ln878">            result = g_list_concat(tmp1, tmp2);</a>
<a name="ln879">        }</a>
<a name="ln880">    }</a>
<a name="ln881">    g_list_free_full(providers, free);</a>
<a name="ln882">    return result;</a>
<a name="ln883">}</a>
<a name="ln884"> </a>
<a name="ln885">#if SUPPORT_NAGIOS</a>
<a name="ln886">GList *</a>
<a name="ln887">resources_os_list_nagios_agents(void)</a>
<a name="ln888">{</a>
<a name="ln889">    GList *plugin_list = NULL;</a>
<a name="ln890">    GList *result = NULL;</a>
<a name="ln891">    GList *gIter = NULL;</a>
<a name="ln892"> </a>
<a name="ln893">    plugin_list = get_directory_list(NAGIOS_PLUGIN_DIR, TRUE, TRUE);</a>
<a name="ln894"> </a>
<a name="ln895">    /* Make sure both the plugin and its metadata exist */</a>
<a name="ln896">    for (gIter = plugin_list; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln897">        const char *plugin = gIter-&gt;data;</a>
<a name="ln898">        char *metadata = crm_strdup_printf(NAGIOS_METADATA_DIR &quot;/%s.xml&quot;, plugin);</a>
<a name="ln899">        struct stat st;</a>
<a name="ln900"> </a>
<a name="ln901">        if (stat(metadata, &amp;st) == 0) {</a>
<a name="ln902">            result = g_list_append(result, strdup(plugin));</a>
<a name="ln903">        }</a>
<a name="ln904"> </a>
<a name="ln905">        free(metadata);</a>
<a name="ln906">    }</a>
<a name="ln907">    g_list_free_full(plugin_list, free);</a>
<a name="ln908">    return result;</a>
<a name="ln909">}</a>
<a name="ln910">#endif</a>

</code></pre>
<div class="balloon" rel="547"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V547/" target="_blank">V547</a> Expression 'poll_rc < 0' is always true.</p></div>
<div class="balloon" rel="750"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V779/" target="_blank">V779</a> Unreachable code detected. It is possible that an error is present.</p></div>
<div class="balloon" rel="878"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The null pointer is passed into 'g_list_concat' function. Inspect the first argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
