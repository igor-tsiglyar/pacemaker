
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (c) 2004 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * This library is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU Lesser General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2.1 of the License, or (at your option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This library is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * Lesser General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU Lesser General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> *</a>
<a name="ln22"> */</a>
<a name="ln23">#include &lt;crm_internal.h&gt;</a>
<a name="ln24">#include &lt;unistd.h&gt;</a>
<a name="ln25">#include &lt;stdlib.h&gt;</a>
<a name="ln26">#include &lt;stdio.h&gt;</a>
<a name="ln27">#include &lt;stdarg.h&gt;</a>
<a name="ln28">#include &lt;string.h&gt;</a>
<a name="ln29">#include &lt;ctype.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &lt;sys/stat.h&gt;</a>
<a name="ln32">#include &lt;sys/types.h&gt;</a>
<a name="ln33">#include &lt;sys/wait.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#include &lt;glib.h&gt;</a>
<a name="ln36">#include &lt;dirent.h&gt;</a>
<a name="ln37">#include &lt;libgen.h&gt;             /* Add it for compiling on OSX */</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;crm/crm.h&gt;</a>
<a name="ln40">#include &lt;crm/stonith-ng.h&gt;</a>
<a name="ln41">#include &lt;crm/fencing/internal.h&gt;</a>
<a name="ln42">#include &lt;crm/msg_xml.h&gt;</a>
<a name="ln43">#include &lt;crm/common/xml.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">#ifdef HAVE_STONITH_STONITH_H</a>
<a name="ln46">#  include &lt;stonith/stonith.h&gt;</a>
<a name="ln47">#  define LHA_STONITH_LIBRARY &quot;libstonith.so.1&quot;</a>
<a name="ln48">static void *lha_agents_lib = NULL;</a>
<a name="ln49">#endif</a>
<a name="ln50"> </a>
<a name="ln51">#include &lt;crm/common/mainloop.h&gt;</a>
<a name="ln52"> </a>
<a name="ln53">CRM_TRACE_INIT_DATA(stonith);</a>
<a name="ln54"> </a>
<a name="ln55">struct stonith_action_s {</a>
<a name="ln56">    /*! user defined data */</a>
<a name="ln57">    char *agent;</a>
<a name="ln58">    char *action;</a>
<a name="ln59">    char *victim;</a>
<a name="ln60">    char *args;</a>
<a name="ln61">    int timeout;</a>
<a name="ln62">    int async;</a>
<a name="ln63">    void *userdata;</a>
<a name="ln64">    void (*done_cb) (GPid pid, gint status, const char *output, gpointer user_data);</a>
<a name="ln65"> </a>
<a name="ln66">    /*! internal async track data */</a>
<a name="ln67">    int fd_stdout;</a>
<a name="ln68">    int fd_stderr;</a>
<a name="ln69">    int last_timeout_signo;</a>
<a name="ln70"> </a>
<a name="ln71">    /*! internal timing information */</a>
<a name="ln72">    time_t initial_start_time;</a>
<a name="ln73">    int tries;</a>
<a name="ln74">    int remaining_timeout;</a>
<a name="ln75">    guint timer_sigterm;</a>
<a name="ln76">    guint timer_sigkill;</a>
<a name="ln77">    int max_retries;</a>
<a name="ln78"> </a>
<a name="ln79">    /* device output data */</a>
<a name="ln80">    GPid pid;</a>
<a name="ln81">    int rc;</a>
<a name="ln82">    char *output;</a>
<a name="ln83">    char *error;</a>
<a name="ln84">};</a>
<a name="ln85"> </a>
<a name="ln86">typedef struct stonith_private_s {</a>
<a name="ln87">    char *token;</a>
<a name="ln88">    crm_ipc_t *ipc;</a>
<a name="ln89">    mainloop_io_t *source;</a>
<a name="ln90">    GHashTable *stonith_op_callback_table;</a>
<a name="ln91">    GList *notify_list;</a>
<a name="ln92"> </a>
<a name="ln93">    void (*op_callback) (stonith_t * st, stonith_callback_data_t * data);</a>
<a name="ln94"> </a>
<a name="ln95">} stonith_private_t;</a>
<a name="ln96"> </a>
<a name="ln97">typedef struct stonith_notify_client_s {</a>
<a name="ln98">    const char *event;</a>
<a name="ln99">    const char *obj_id;         /* implement one day */</a>
<a name="ln100">    const char *obj_type;       /* implement one day */</a>
<a name="ln101">    void (*notify) (stonith_t * st, stonith_event_t * e);</a>
<a name="ln102"> </a>
<a name="ln103">} stonith_notify_client_t;</a>
<a name="ln104"> </a>
<a name="ln105">typedef struct stonith_callback_client_s {</a>
<a name="ln106">    void (*callback) (stonith_t * st, stonith_callback_data_t * data);</a>
<a name="ln107">    const char *id;</a>
<a name="ln108">    void *user_data;</a>
<a name="ln109">    gboolean only_success;</a>
<a name="ln110">    gboolean allow_timeout_updates;</a>
<a name="ln111">    struct timer_rec_s *timer;</a>
<a name="ln112"> </a>
<a name="ln113">} stonith_callback_client_t;</a>
<a name="ln114"> </a>
<a name="ln115">struct notify_blob_s {</a>
<a name="ln116">    stonith_t *stonith;</a>
<a name="ln117">    xmlNode *xml;</a>
<a name="ln118">};</a>
<a name="ln119"> </a>
<a name="ln120">struct timer_rec_s {</a>
<a name="ln121">    int call_id;</a>
<a name="ln122">    int timeout;</a>
<a name="ln123">    guint ref;</a>
<a name="ln124">    stonith_t *stonith;</a>
<a name="ln125">};</a>
<a name="ln126"> </a>
<a name="ln127">typedef int (*stonith_op_t) (const char *, int, const char *, xmlNode *,</a>
<a name="ln128">                             xmlNode *, xmlNode *, xmlNode **, xmlNode **);</a>
<a name="ln129"> </a>
<a name="ln130">#if HAVE_STONITH_STONITH_H</a>
<a name="ln131">static const char META_TEMPLATE[] =</a>
<a name="ln132">    &quot;&lt;?xml version=\&quot;1.0\&quot;?&gt;\n&quot;</a>
<a name="ln133">    &quot;&lt;!DOCTYPE resource-agent SYSTEM \&quot;ra-api-1.dtd\&quot;&gt;\n&quot;</a>
<a name="ln134">    &quot;&lt;resource-agent name=\&quot;%s\&quot;&gt;\n&quot;</a>
<a name="ln135">    &quot;  &lt;version&gt;1.0&lt;/version&gt;\n&quot;</a>
<a name="ln136">    &quot;  &lt;longdesc lang=\&quot;en\&quot;&gt;\n&quot;</a>
<a name="ln137">    &quot;%s\n&quot;</a>
<a name="ln138">    &quot;  &lt;/longdesc&gt;\n&quot;</a>
<a name="ln139">    &quot;  &lt;shortdesc lang=\&quot;en\&quot;&gt;%s&lt;/shortdesc&gt;\n&quot;</a>
<a name="ln140">    &quot;%s\n&quot;</a>
<a name="ln141">    &quot;  &lt;actions&gt;\n&quot;</a>
<a name="ln142">    &quot;    &lt;action name=\&quot;start\&quot;   timeout=\&quot;20\&quot; /&gt;\n&quot;</a>
<a name="ln143">    &quot;    &lt;action name=\&quot;stop\&quot;    timeout=\&quot;15\&quot; /&gt;\n&quot;</a>
<a name="ln144">    &quot;    &lt;action name=\&quot;status\&quot;  timeout=\&quot;20\&quot; /&gt;\n&quot;</a>
<a name="ln145">    &quot;    &lt;action name=\&quot;monitor\&quot; timeout=\&quot;20\&quot; interval=\&quot;3600\&quot;/&gt;\n&quot;</a>
<a name="ln146">    &quot;    &lt;action name=\&quot;meta-data\&quot;  timeout=\&quot;15\&quot; /&gt;\n&quot;</a>
<a name="ln147">    &quot;  &lt;/actions&gt;\n&quot;</a>
<a name="ln148">    &quot;  &lt;special tag=\&quot;heartbeat\&quot;&gt;\n&quot;</a>
<a name="ln149">    &quot;    &lt;version&gt;2.0&lt;/version&gt;\n&quot; &quot;  &lt;/special&gt;\n&quot; &quot;&lt;/resource-agent&gt;\n&quot;;</a>
<a name="ln150">#endif</a>
<a name="ln151"> </a>
<a name="ln152">bool stonith_dispatch(stonith_t * st);</a>
<a name="ln153">int stonith_dispatch_internal(const char *buffer, ssize_t length, gpointer userdata);</a>
<a name="ln154">void stonith_perform_callback(stonith_t * stonith, xmlNode * msg, int call_id, int rc);</a>
<a name="ln155">xmlNode *stonith_create_op(int call_id, const char *token, const char *op, xmlNode * data,</a>
<a name="ln156">                           int call_options);</a>
<a name="ln157">int stonith_send_command(stonith_t * stonith, const char *op, xmlNode * data,</a>
<a name="ln158">                         xmlNode ** output_data, int call_options, int timeout);</a>
<a name="ln159"> </a>
<a name="ln160">static void stonith_connection_destroy(gpointer user_data);</a>
<a name="ln161">static void stonith_send_notification(gpointer data, gpointer user_data);</a>
<a name="ln162">static int internal_stonith_action_execute(stonith_action_t * action);</a>
<a name="ln163">static void log_action(stonith_action_t *action, pid_t pid);</a>
<a name="ln164"> </a>
<a name="ln165">static void</a>
<a name="ln166">log_action(stonith_action_t *action, pid_t pid)</a>
<a name="ln167">{</a>
<a name="ln168">    if (action-&gt;output) {</a>
<a name="ln169">        /* Logging the whole string confuses syslog when the string is xml */</a>
<a name="ln170">        char *prefix = crm_strdup_printf(&quot;%s[%d] stdout:&quot;, action-&gt;agent, pid);</a>
<a name="ln171"> </a>
<a name="ln172">        crm_log_output(LOG_TRACE, prefix, action-&gt;output);</a>
<a name="ln173">        free(prefix);</a>
<a name="ln174">    }</a>
<a name="ln175"> </a>
<a name="ln176">    if (action-&gt;error) {</a>
<a name="ln177">        /* Logging the whole string confuses syslog when the string is xml */</a>
<a name="ln178">        char *prefix = crm_strdup_printf(&quot;%s[%d] stderr:&quot;, action-&gt;agent, pid);</a>
<a name="ln179"> </a>
<a name="ln180">        crm_log_output(LOG_WARNING, prefix, action-&gt;error);</a>
<a name="ln181">        free(prefix);</a>
<a name="ln182">    }</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">static void</a>
<a name="ln186">stonith_connection_destroy(gpointer user_data)</a>
<a name="ln187">{</a>
<a name="ln188">    stonith_t *stonith = user_data;</a>
<a name="ln189">    stonith_private_t *native = NULL;</a>
<a name="ln190">    struct notify_blob_s blob;</a>
<a name="ln191"> </a>
<a name="ln192">    crm_trace(&quot;Sending destroyed notification&quot;);</a>
<a name="ln193">    blob.stonith = stonith;</a>
<a name="ln194">    blob.xml = create_xml_node(NULL, &quot;notify&quot;);</a>
<a name="ln195"> </a>
<a name="ln196">    native = stonith-&gt;private;</a>
<a name="ln197">    native-&gt;ipc = NULL;</a>
<a name="ln198">    native-&gt;source = NULL;</a>
<a name="ln199"> </a>
<a name="ln200">    stonith-&gt;state = stonith_disconnected;</a>
<a name="ln201">    crm_xml_add(blob.xml, F_TYPE, T_STONITH_NOTIFY);</a>
<a name="ln202">    crm_xml_add(blob.xml, F_SUBTYPE, T_STONITH_NOTIFY_DISCONNECT);</a>
<a name="ln203"> </a>
<a name="ln204">    g_list_foreach(native-&gt;notify_list, stonith_send_notification, &amp;blob);</a>
<a name="ln205">    free_xml(blob.xml);</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">xmlNode *</a>
<a name="ln209">create_device_registration_xml(const char *id, const char *namespace, const char *agent,</a>
<a name="ln210">                               stonith_key_value_t * params, const char *rsc_provides)</a>
<a name="ln211">{</a>
<a name="ln212">    xmlNode *data = create_xml_node(NULL, F_STONITH_DEVICE);</a>
<a name="ln213">    xmlNode *args = create_xml_node(data, XML_TAG_ATTRS);</a>
<a name="ln214"> </a>
<a name="ln215">#if HAVE_STONITH_STONITH_H</a>
<a name="ln216">    namespace = get_stonith_provider(agent, namespace);</a>
<a name="ln217">    if (safe_str_eq(namespace, &quot;heartbeat&quot;)) {</a>
<a name="ln218">        hash2field((gpointer) &quot;plugin&quot;, (gpointer) agent, args);</a>
<a name="ln219">        agent = &quot;fence_legacy&quot;;</a>
<a name="ln220">    }</a>
<a name="ln221">#endif</a>
<a name="ln222"> </a>
<a name="ln223">    crm_xml_add(data, XML_ATTR_ID, id);</a>
<a name="ln224">    crm_xml_add(data, F_STONITH_ORIGIN, __FUNCTION__);</a>
<a name="ln225">    crm_xml_add(data, &quot;agent&quot;, agent);</a>
<a name="ln226">    crm_xml_add(data, &quot;namespace&quot;, namespace);</a>
<a name="ln227">    if (rsc_provides) {</a>
<a name="ln228">        crm_xml_add(data, &quot;rsc_provides&quot;, rsc_provides);</a>
<a name="ln229">    }</a>
<a name="ln230"> </a>
<a name="ln231">    for (; params; params = params-&gt;next) {</a>
<a name="ln232">        hash2field((gpointer) params-&gt;key, (gpointer) params-&gt;value, args);</a>
<a name="ln233">    }</a>
<a name="ln234"> </a>
<a name="ln235">    return data;</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">static int</a>
<a name="ln239">stonith_api_register_device(stonith_t * st, int call_options,</a>
<a name="ln240">                            const char *id, const char *namespace, const char *agent,</a>
<a name="ln241">                            stonith_key_value_t * params)</a>
<a name="ln242">{</a>
<a name="ln243">    int rc = 0;</a>
<a name="ln244">    xmlNode *data = NULL;</a>
<a name="ln245"> </a>
<a name="ln246">    data = create_device_registration_xml(id, namespace, agent, params, NULL);</a>
<a name="ln247"> </a>
<a name="ln248">    rc = stonith_send_command(st, STONITH_OP_DEVICE_ADD, data, NULL, call_options, 0);</a>
<a name="ln249">    free_xml(data);</a>
<a name="ln250"> </a>
<a name="ln251">    return rc;</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">static int</a>
<a name="ln255">stonith_api_remove_device(stonith_t * st, int call_options, const char *name)</a>
<a name="ln256">{</a>
<a name="ln257">    int rc = 0;</a>
<a name="ln258">    xmlNode *data = NULL;</a>
<a name="ln259"> </a>
<a name="ln260">    data = create_xml_node(NULL, F_STONITH_DEVICE);</a>
<a name="ln261">    crm_xml_add(data, F_STONITH_ORIGIN, __FUNCTION__);</a>
<a name="ln262">    crm_xml_add(data, XML_ATTR_ID, name);</a>
<a name="ln263">    rc = stonith_send_command(st, STONITH_OP_DEVICE_DEL, data, NULL, call_options, 0);</a>
<a name="ln264">    free_xml(data);</a>
<a name="ln265"> </a>
<a name="ln266">    return rc;</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">static int</a>
<a name="ln270">stonith_api_remove_level_full(stonith_t *st, int options,</a>
<a name="ln271">                              const char *node, const char *pattern,</a>
<a name="ln272">                              const char *attr, const char *value, int level)</a>
<a name="ln273">{</a>
<a name="ln274">    int rc = 0;</a>
<a name="ln275">    xmlNode *data = NULL;</a>
<a name="ln276"> </a>
<a name="ln277">    CRM_CHECK(node || pattern || (attr &amp;&amp; value), return -EINVAL);</a>
<a name="ln278"> </a>
<a name="ln279">    data = create_xml_node(NULL, XML_TAG_FENCING_LEVEL);</a>
<a name="ln280">    crm_xml_add(data, F_STONITH_ORIGIN, __FUNCTION__);</a>
<a name="ln281"> </a>
<a name="ln282">    if (node) {</a>
<a name="ln283">        crm_xml_add(data, XML_ATTR_STONITH_TARGET, node);</a>
<a name="ln284"> </a>
<a name="ln285">    } else if (pattern) {</a>
<a name="ln286">        crm_xml_add(data, XML_ATTR_STONITH_TARGET_PATTERN, pattern);</a>
<a name="ln287"> </a>
<a name="ln288">    } else {</a>
<a name="ln289">        crm_xml_add(data, XML_ATTR_STONITH_TARGET_ATTRIBUTE, attr);</a>
<a name="ln290">        crm_xml_add(data, XML_ATTR_STONITH_TARGET_VALUE, value);</a>
<a name="ln291">    }</a>
<a name="ln292"> </a>
<a name="ln293">    crm_xml_add_int(data, XML_ATTR_STONITH_INDEX, level);</a>
<a name="ln294">    rc = stonith_send_command(st, STONITH_OP_LEVEL_DEL, data, NULL, options, 0);</a>
<a name="ln295">    free_xml(data);</a>
<a name="ln296"> </a>
<a name="ln297">    return rc;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">static int</a>
<a name="ln301">stonith_api_remove_level(stonith_t * st, int options, const char *node, int level)</a>
<a name="ln302">{</a>
<a name="ln303">    return stonith_api_remove_level_full(st, options, node,</a>
<a name="ln304">                                         NULL, NULL, NULL, level);</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">/*!</a>
<a name="ln308"> * \internal</a>
<a name="ln309"> * \brief Create XML for stonithd topology level registration request</a>
<a name="ln310"> *</a>
<a name="ln311"> * \param[in] node        If not NULL, target level by this node name</a>
<a name="ln312"> * \param[in] pattern     If not NULL, target by node name using this regex</a>
<a name="ln313"> * \param[in] attr        If not NULL, target by this node attribute</a>
<a name="ln314"> * \param[in] value       If not NULL, target by this node attribute value</a>
<a name="ln315"> * \param[in] level       Index number of level to register</a>
<a name="ln316"> * \param[in] device_list List of devices in level</a>
<a name="ln317"> *</a>
<a name="ln318"> * \return Newly allocated XML tree on success, NULL otherwise</a>
<a name="ln319"> *</a>
<a name="ln320"> * \note The caller should set only one of node, pattern or attr/value.</a>
<a name="ln321"> */</a>
<a name="ln322">xmlNode *</a>
<a name="ln323">create_level_registration_xml(const char *node, const char *pattern,</a>
<a name="ln324">                              const char *attr, const char *value,</a>
<a name="ln325">                              int level, stonith_key_value_t *device_list)</a>
<a name="ln326">{</a>
<a name="ln327">    int len = 0;</a>
<a name="ln328">    char *list = NULL;</a>
<a name="ln329">    xmlNode *data;</a>
<a name="ln330"> </a>
<a name="ln331">    CRM_CHECK(node || pattern || (attr &amp;&amp; value), return NULL);</a>
<a name="ln332"> </a>
<a name="ln333">    data = create_xml_node(NULL, XML_TAG_FENCING_LEVEL);</a>
<a name="ln334">    CRM_CHECK(data, return NULL);</a>
<a name="ln335"> </a>
<a name="ln336">    crm_xml_add(data, F_STONITH_ORIGIN, __FUNCTION__);</a>
<a name="ln337">    crm_xml_add_int(data, XML_ATTR_ID, level);</a>
<a name="ln338">    crm_xml_add_int(data, XML_ATTR_STONITH_INDEX, level);</a>
<a name="ln339"> </a>
<a name="ln340">    if (node) {</a>
<a name="ln341">        crm_xml_add(data, XML_ATTR_STONITH_TARGET, node);</a>
<a name="ln342"> </a>
<a name="ln343">    } else if (pattern) {</a>
<a name="ln344">        crm_xml_add(data, XML_ATTR_STONITH_TARGET_PATTERN, pattern);</a>
<a name="ln345"> </a>
<a name="ln346">    } else {</a>
<a name="ln347">        crm_xml_add(data, XML_ATTR_STONITH_TARGET_ATTRIBUTE, attr);</a>
<a name="ln348">        crm_xml_add(data, XML_ATTR_STONITH_TARGET_VALUE, value);</a>
<a name="ln349">    }</a>
<a name="ln350"> </a>
<a name="ln351">    for (; device_list; device_list = device_list-&gt;next) {</a>
<a name="ln352"> </a>
<a name="ln353">        int adding = strlen(device_list-&gt;value);</a>
<a name="ln354">        if(list) {</a>
<a name="ln355">            adding++;                                      /* +1 space */</a>
<a name="ln356">        }</a>
<a name="ln357"> </a>
<a name="ln358">        crm_trace(&quot;Adding %s (%dc) at offset %d&quot;, device_list-&gt;value, adding, len);</a>
<a name="ln359">        list = realloc_safe(list, len + adding + 1);       /* +1 EOS */</a>
<a name="ln360">        if (list == NULL) {</a>
<a name="ln361">            crm_perror(LOG_CRIT, &quot;Could not create device list&quot;);</a>
<a name="ln362">            free_xml(data);</a>
<a name="ln363">            return NULL;</a>
<a name="ln364">        }</a>
<a name="ln365">        sprintf(list + len, &quot;%s%s&quot;, len?&quot;,&quot;:&quot;&quot;, device_list-&gt;value);</a>
<a name="ln366">        len += adding;</a>
<a name="ln367">    }</a>
<a name="ln368"> </a>
<a name="ln369">    crm_xml_add(data, XML_ATTR_STONITH_DEVICES, list);</a>
<a name="ln370"> </a>
<a name="ln371">    free(list);</a>
<a name="ln372">    return data;</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">static int</a>
<a name="ln376">stonith_api_register_level_full(stonith_t * st, int options, const char *node,</a>
<a name="ln377">                                const char *pattern,</a>
<a name="ln378">                                const char *attr, const char *value,</a>
<a name="ln379">                                int level, stonith_key_value_t *device_list)</a>
<a name="ln380">{</a>
<a name="ln381">    int rc = 0;</a>
<a name="ln382">    xmlNode *data = create_level_registration_xml(node, pattern, attr, value,</a>
<a name="ln383">                                                  level, device_list);</a>
<a name="ln384">    CRM_CHECK(data != NULL, return -EINVAL);</a>
<a name="ln385"> </a>
<a name="ln386">    rc = stonith_send_command(st, STONITH_OP_LEVEL_ADD, data, NULL, options, 0);</a>
<a name="ln387">    free_xml(data);</a>
<a name="ln388"> </a>
<a name="ln389">    return rc;</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">static int</a>
<a name="ln393">stonith_api_register_level(stonith_t * st, int options, const char *node, int level,</a>
<a name="ln394">                           stonith_key_value_t * device_list)</a>
<a name="ln395">{</a>
<a name="ln396">    return stonith_api_register_level_full(st, options, node, NULL, NULL, NULL,</a>
<a name="ln397">                                           level, device_list);</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">static void</a>
<a name="ln401">append_arg(const char *key, const char *value, char **args)</a>
<a name="ln402">{</a>
<a name="ln403">    int len = 3;                /* =, \n, \0 */</a>
<a name="ln404">    int last = 0;</a>
<a name="ln405"> </a>
<a name="ln406">    CRM_CHECK(key != NULL, return);</a>
<a name="ln407">    CRM_CHECK(value != NULL, return);</a>
<a name="ln408"> </a>
<a name="ln409">    if (strstr(key, &quot;pcmk_&quot;)) {</a>
<a name="ln410">        return;</a>
<a name="ln411">    } else if (strstr(key, CRM_META)) {</a>
<a name="ln412">        return;</a>
<a name="ln413">    } else if (safe_str_eq(key, &quot;crm_feature_set&quot;)) {</a>
<a name="ln414">        return;</a>
<a name="ln415">    }</a>
<a name="ln416"> </a>
<a name="ln417">    len += strlen(key);</a>
<a name="ln418">    len += strlen(value);</a>
<a name="ln419">    if (*args != NULL) {</a>
<a name="ln420">        last = strlen(*args);</a>
<a name="ln421">    }</a>
<a name="ln422"> </a>
<a name="ln423">    *args = realloc_safe(*args, last + len);</a>
<a name="ln424">    crm_trace(&quot;Appending: %s=%s&quot;, key, value);</a>
<a name="ln425">    sprintf((*args) + last, &quot;%s=%s\n&quot;, key, value);</a>
<a name="ln426">}</a>
<a name="ln427"> </a>
<a name="ln428">static void</a>
<a name="ln429">append_config_arg(gpointer key, gpointer value, gpointer user_data)</a>
<a name="ln430">{</a>
<a name="ln431">    /* stonithd will filter action out when it registers the device,</a>
<a name="ln432">     * but ignore it here just in case any other library callers</a>
<a name="ln433">     * fail to do so.</a>
<a name="ln434">     */</a>
<a name="ln435">    if (safe_str_neq(key, STONITH_ATTR_ACTION_OP)) {</a>
<a name="ln436">        append_arg(key, value, user_data);</a>
<a name="ln437">        return;</a>
<a name="ln438">    }</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">static void</a>
<a name="ln442">append_host_specific_args(const char *victim, const char *map, GHashTable * params, char **arg_list)</a>
<a name="ln443">{</a>
<a name="ln444">    char *name = NULL;</a>
<a name="ln445">    int last = 0, lpc = 0, max = 0;</a>
<a name="ln446"> </a>
<a name="ln447">    if (map == NULL) {</a>
<a name="ln448">        /* The best default there is for now... */</a>
<a name="ln449">        crm_debug(&quot;Using default arg map: port=uname&quot;);</a>
<a name="ln450">        append_arg(&quot;port&quot;, victim, arg_list);</a>
<a name="ln451">        return;</a>
<a name="ln452">    }</a>
<a name="ln453"> </a>
<a name="ln454">    max = strlen(map);</a>
<a name="ln455">    crm_debug(&quot;Processing arg map: %s&quot;, map);</a>
<a name="ln456">    for (; lpc &lt; max + 1; lpc++) {</a>
<a name="ln457">        if (isalpha(map[lpc])) {</a>
<a name="ln458">            /* keep going */</a>
<a name="ln459"> </a>
<a name="ln460">        } else if (map[lpc] == '=' || map[lpc] == ':') {</a>
<a name="ln461">            free(name);</a>
<a name="ln462">            name = calloc(1, 1 + lpc - last);</a>
<a name="ln463">            memcpy(name, map + last, lpc - last);</a>
<a name="ln464">            crm_debug(&quot;Got name: %s&quot;, name);</a>
<a name="ln465">            last = lpc + 1;</a>
<a name="ln466"> </a>
<a name="ln467">        } else if (map[lpc] == 0 || map[lpc] == ',' || isspace(map[lpc])) {</a>
<a name="ln468">            char *param = NULL;</a>
<a name="ln469">            const char *value = NULL;</a>
<a name="ln470"> </a>
<a name="ln471">            param = calloc(1, 1 + lpc - last);</a>
<a name="ln472">            memcpy(param, map + last, lpc - last);</a>
<a name="ln473">            last = lpc + 1;</a>
<a name="ln474"> </a>
<a name="ln475">            crm_debug(&quot;Got key: %s&quot;, param);</a>
<a name="ln476">            if (name == NULL) {</a>
<a name="ln477">                crm_err(&quot;Misparsed '%s', found '%s' without a name&quot;, map, param);</a>
<a name="ln478">                free(param);</a>
<a name="ln479">                continue;</a>
<a name="ln480">            }</a>
<a name="ln481"> </a>
<a name="ln482">            if (safe_str_eq(param, &quot;uname&quot;)) {</a>
<a name="ln483">                value = victim;</a>
<a name="ln484">            } else {</a>
<a name="ln485">                char *key = crm_meta_name(param);</a>
<a name="ln486"> </a>
<a name="ln487">                value = g_hash_table_lookup(params, key);</a>
<a name="ln488">                free(key);</a>
<a name="ln489">            }</a>
<a name="ln490"> </a>
<a name="ln491">            if (value) {</a>
<a name="ln492">                crm_debug(&quot;Setting '%s'='%s' (%s) for %s&quot;, name, value, param, victim);</a>
<a name="ln493">                append_arg(name, value, arg_list);</a>
<a name="ln494"> </a>
<a name="ln495">            } else {</a>
<a name="ln496">                crm_err(&quot;No node attribute '%s' for '%s'&quot;, name, victim);</a>
<a name="ln497">            }</a>
<a name="ln498"> </a>
<a name="ln499">            free(name);</a>
<a name="ln500">            name = NULL;</a>
<a name="ln501">            free(param);</a>
<a name="ln502">            if (map[lpc] == 0) {</a>
<a name="ln503">                break;</a>
<a name="ln504">            }</a>
<a name="ln505"> </a>
<a name="ln506">        } else if (isspace(map[lpc])) {</a>
<a name="ln507">            last = lpc;</a>
<a name="ln508">        }</a>
<a name="ln509">    }</a>
<a name="ln510">    free(name);</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513">static char *</a>
<a name="ln514">make_args(const char *agent, const char *action, const char *victim, uint32_t victim_nodeid, GHashTable * device_args,</a>
<a name="ln515">          GHashTable * port_map)</a>
<a name="ln516">{</a>
<a name="ln517">    char buffer[512];</a>
<a name="ln518">    char *arg_list = NULL;</a>
<a name="ln519">    const char *value = NULL;</a>
<a name="ln520"> </a>
<a name="ln521">    CRM_CHECK(action != NULL, return NULL);</a>
<a name="ln522"> </a>
<a name="ln523">    buffer[511] = 0;</a>
<a name="ln524">    snprintf(buffer, 511, &quot;pcmk_%s_action&quot;, action);</a>
<a name="ln525">    if (device_args) {</a>
<a name="ln526">        value = g_hash_table_lookup(device_args, buffer);</a>
<a name="ln527">    }</a>
<a name="ln528"> </a>
<a name="ln529">    if (value == NULL &amp;&amp; device_args) {</a>
<a name="ln530">        /* Legacy support for early 1.1 releases - Remove for 1.4 */</a>
<a name="ln531">        snprintf(buffer, 511, &quot;pcmk_%s_cmd&quot;, action);</a>
<a name="ln532">        value = g_hash_table_lookup(device_args, buffer);</a>
<a name="ln533">    }</a>
<a name="ln534"> </a>
<a name="ln535">    if (value == NULL &amp;&amp; device_args &amp;&amp; safe_str_eq(action, &quot;off&quot;)) {</a>
<a name="ln536">        /* Legacy support for late 1.1 releases - Remove for 1.4 */</a>
<a name="ln537">        value = g_hash_table_lookup(device_args, &quot;pcmk_poweroff_action&quot;);</a>
<a name="ln538">    }</a>
<a name="ln539"> </a>
<a name="ln540">    if (value) {</a>
<a name="ln541">        crm_info(&quot;Substituting action '%s' for requested operation '%s'&quot;, value, action);</a>
<a name="ln542">        action = value;</a>
<a name="ln543">    }</a>
<a name="ln544"> </a>
<a name="ln545">    append_arg(STONITH_ATTR_ACTION_OP, action, &amp;arg_list);</a>
<a name="ln546">    if (victim &amp;&amp; device_args) {</a>
<a name="ln547">        const char *alias = victim;</a>
<a name="ln548">        const char *param = g_hash_table_lookup(device_args, STONITH_ATTR_HOSTARG);</a>
<a name="ln549"> </a>
<a name="ln550">        if (port_map &amp;&amp; g_hash_table_lookup(port_map, victim)) {</a>
<a name="ln551">            alias = g_hash_table_lookup(port_map, victim);</a>
<a name="ln552">        }</a>
<a name="ln553"> </a>
<a name="ln554">        /* Always supply the node's name too:</a>
<a name="ln555">         *    https://fedorahosted.org/cluster/wiki/FenceAgentAPI</a>
<a name="ln556">         */</a>
<a name="ln557">        append_arg(&quot;nodename&quot;, victim, &amp;arg_list);</a>
<a name="ln558">        if (victim_nodeid) {</a>
<a name="ln559">            char nodeid_str[33] = { 0, };</a>
<a name="ln560">            if (snprintf(nodeid_str, 33, &quot;%u&quot;, (unsigned int)victim_nodeid)) {</a>
<a name="ln561">                crm_info(&quot;For stonith action (%s) for victim %s, adding nodeid (%s) to parameters&quot;,</a>
<a name="ln562">                         action, victim, nodeid_str);</a>
<a name="ln563">                append_arg(&quot;nodeid&quot;, nodeid_str, &amp;arg_list);</a>
<a name="ln564">            }</a>
<a name="ln565">        }</a>
<a name="ln566"> </a>
<a name="ln567">        /* Check if we need to supply the victim in any other form */</a>
<a name="ln568">        if(safe_str_eq(agent, &quot;fence_legacy&quot;)) {</a>
<a name="ln569">            value = agent;</a>
<a name="ln570"> </a>
<a name="ln571">        } else if (param == NULL) {</a>
<a name="ln572">            const char *map = g_hash_table_lookup(device_args, STONITH_ATTR_ARGMAP);</a>
<a name="ln573"> </a>
<a name="ln574">            if (map == NULL) {</a>
<a name="ln575">                param = &quot;port&quot;;</a>
<a name="ln576">                value = g_hash_table_lookup(device_args, param);</a>
<a name="ln577"> </a>
<a name="ln578">            } else {</a>
<a name="ln579">                /* Legacy handling */</a>
<a name="ln580">                append_host_specific_args(alias, map, device_args, &amp;arg_list);</a>
<a name="ln581">                value = map;    /* Nothing more to do */</a>
<a name="ln582">            }</a>
<a name="ln583"> </a>
<a name="ln584">        } else if (safe_str_eq(param, &quot;none&quot;)) {</a>
<a name="ln585">            value = param;      /* Nothing more to do */</a>
<a name="ln586"> </a>
<a name="ln587">        } else {</a>
<a name="ln588">            value = g_hash_table_lookup(device_args, param);</a>
<a name="ln589">        }</a>
<a name="ln590"> </a>
<a name="ln591">        /* Don't overwrite explictly set values for $param */</a>
<a name="ln592">        if (value == NULL || safe_str_eq(value, &quot;dynamic&quot;)) {</a>
<a name="ln593">            crm_debug(&quot;Performing %s action for node '%s' as '%s=%s'&quot;, action, victim, param,</a>
<a name="ln594">                      alias);</a>
<a name="ln595">            append_arg(param, alias, &amp;arg_list);</a>
<a name="ln596">        }</a>
<a name="ln597">    }</a>
<a name="ln598"> </a>
<a name="ln599">    if (device_args) {</a>
<a name="ln600">        g_hash_table_foreach(device_args, append_config_arg, &amp;arg_list);</a>
<a name="ln601">    }</a>
<a name="ln602"> </a>
<a name="ln603">    return arg_list;</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">static gboolean</a>
<a name="ln607">st_child_term(gpointer data)</a>
<a name="ln608">{</a>
<a name="ln609">    int rc = 0;</a>
<a name="ln610">    stonith_action_t *track = data;</a>
<a name="ln611"> </a>
<a name="ln612">    crm_info(&quot;Child %d timed out, sending SIGTERM&quot;, track-&gt;pid);</a>
<a name="ln613">    track-&gt;timer_sigterm = 0;</a>
<a name="ln614">    track-&gt;last_timeout_signo = SIGTERM;</a>
<a name="ln615">    rc = kill(-track-&gt;pid, SIGTERM);</a>
<a name="ln616">    if (rc &lt; 0) {</a>
<a name="ln617">        crm_perror(LOG_ERR, &quot;Couldn't send SIGTERM to %d&quot;, track-&gt;pid);</a>
<a name="ln618">    }</a>
<a name="ln619">    return FALSE;</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">static gboolean</a>
<a name="ln623">st_child_kill(gpointer data)</a>
<a name="ln624">{</a>
<a name="ln625">    int rc = 0;</a>
<a name="ln626">    stonith_action_t *track = data;</a>
<a name="ln627"> </a>
<a name="ln628">    crm_info(&quot;Child %d timed out, sending SIGKILL&quot;, track-&gt;pid);</a>
<a name="ln629">    track-&gt;timer_sigkill = 0;</a>
<a name="ln630">    track-&gt;last_timeout_signo = SIGKILL;</a>
<a name="ln631">    rc = kill(-track-&gt;pid, SIGKILL);</a>
<a name="ln632">    if (rc &lt; 0) {</a>
<a name="ln633">        crm_perror(LOG_ERR, &quot;Couldn't send SIGKILL to %d&quot;, track-&gt;pid);</a>
<a name="ln634">    }</a>
<a name="ln635">    return FALSE;</a>
<a name="ln636">}</a>
<a name="ln637"> </a>
<a name="ln638">static void</a>
<a name="ln639">stonith_action_clear_tracking_data(stonith_action_t * action)</a>
<a name="ln640">{</a>
<a name="ln641">    if (action-&gt;timer_sigterm &gt; 0) {</a>
<a name="ln642">        g_source_remove(action-&gt;timer_sigterm);</a>
<a name="ln643">        action-&gt;timer_sigterm = 0;</a>
<a name="ln644">    }</a>
<a name="ln645">    if (action-&gt;timer_sigkill &gt; 0) {</a>
<a name="ln646">        g_source_remove(action-&gt;timer_sigkill);</a>
<a name="ln647">        action-&gt;timer_sigkill = 0;</a>
<a name="ln648">    }</a>
<a name="ln649">    if (action-&gt;fd_stdout) {</a>
<a name="ln650">        close(action-&gt;fd_stdout);</a>
<a name="ln651">        action-&gt;fd_stdout = 0;</a>
<a name="ln652">    }</a>
<a name="ln653">    if (action-&gt;fd_stderr) {</a>
<a name="ln654">        close(action-&gt;fd_stderr);</a>
<a name="ln655">        action-&gt;fd_stderr = 0;</a>
<a name="ln656">    }</a>
<a name="ln657">    free(action-&gt;output);</a>
<a name="ln658">    action-&gt;output = NULL;</a>
<a name="ln659">    free(action-&gt;error);</a>
<a name="ln660">    action-&gt;error = NULL;</a>
<a name="ln661">    action-&gt;rc = 0;</a>
<a name="ln662">    action-&gt;pid = 0;</a>
<a name="ln663">    action-&gt;last_timeout_signo = 0;</a>
<a name="ln664">}</a>
<a name="ln665"> </a>
<a name="ln666">static void</a>
<a name="ln667">stonith_action_destroy(stonith_action_t * action)</a>
<a name="ln668">{</a>
<a name="ln669">    stonith_action_clear_tracking_data(action);</a>
<a name="ln670">    free(action-&gt;agent);</a>
<a name="ln671">    free(action-&gt;args);</a>
<a name="ln672">    free(action-&gt;action);</a>
<a name="ln673">    free(action-&gt;victim);</a>
<a name="ln674">    free(action);</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677">#define FAILURE_MAX_RETRIES 2</a>
<a name="ln678">stonith_action_t *</a>
<a name="ln679">stonith_action_create(const char *agent,</a>
<a name="ln680">                      const char *_action,</a>
<a name="ln681">                      const char *victim,</a>
<a name="ln682">                      uint32_t victim_nodeid,</a>
<a name="ln683">                      int timeout, GHashTable * device_args, GHashTable * port_map)</a>
<a name="ln684">{</a>
<a name="ln685">    stonith_action_t *action;</a>
<a name="ln686"> </a>
<a name="ln687">    action = calloc(1, sizeof(stonith_action_t));</a>
<a name="ln688">    crm_debug(&quot;Initiating action %s for agent %s (target=%s)&quot;, _action, agent, victim);</a>
<a name="ln689">    action-&gt;args = make_args(agent, _action, victim, victim_nodeid, device_args, port_map);</a>
<a name="ln690">    action-&gt;agent = strdup(agent);</a>
<a name="ln691">    action-&gt;action = strdup(_action);</a>
<a name="ln692">    if (victim) {</a>
<a name="ln693">        action-&gt;victim = strdup(victim);</a>
<a name="ln694">    }</a>
<a name="ln695">    action-&gt;timeout = action-&gt;remaining_timeout = timeout;</a>
<a name="ln696">    action-&gt;max_retries = FAILURE_MAX_RETRIES;</a>
<a name="ln697"> </a>
<a name="ln698">    if (device_args) {</a>
<a name="ln699">        char buffer[512];</a>
<a name="ln700">        const char *value = NULL;</a>
<a name="ln701"> </a>
<a name="ln702">        snprintf(buffer, 511, &quot;pcmk_%s_retries&quot;, _action);</a>
<a name="ln703">        value = g_hash_table_lookup(device_args, buffer);</a>
<a name="ln704"> </a>
<a name="ln705">        if (value) {</a>
<a name="ln706">            action-&gt;max_retries = atoi(value);</a>
<a name="ln707">        }</a>
<a name="ln708">    }</a>
<a name="ln709"> </a>
<a name="ln710">    return action;</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">#define READ_MAX 500</a>
<a name="ln714">static char *</a>
<a name="ln715">read_output(int fd)</a>
<a name="ln716">{</a>
<a name="ln717">    char buffer[READ_MAX];</a>
<a name="ln718">    char *output = NULL;</a>
<a name="ln719">    int len = 0;</a>
<a name="ln720">    int more = 0;</a>
<a name="ln721"> </a>
<a name="ln722">    if (!fd) {</a>
<a name="ln723">        return NULL;</a>
<a name="ln724">    }</a>
<a name="ln725"> </a>
<a name="ln726">    do {</a>
<a name="ln727">        errno = 0;</a>
<a name="ln728">        memset(&amp;buffer, 0, READ_MAX);</a>
<a name="ln729">        more = read(fd, buffer, READ_MAX - 1);</a>
<a name="ln730"> </a>
<a name="ln731">        if (more &gt; 0) {</a>
<a name="ln732">            buffer[more] = 0; /* Make sure it's nul-terminated for logging</a>
<a name="ln733">                              * 'more' is always less than our buffer size</a>
<a name="ln734">                              */</a>
<a name="ln735">            output = realloc_safe(output, len + more + 1);</a>
<a name="ln736">            snprintf(output + len, more + 1, &quot;%s&quot;, buffer);</a>
<a name="ln737">            len += more;</a>
<a name="ln738">        }</a>
<a name="ln739"> </a>
<a name="ln740">    } while (more == (READ_MAX - 1) || (more &lt; 0 &amp;&amp; errno == EINTR));</a>
<a name="ln741"> </a>
<a name="ln742">    return output;</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745">static gboolean</a>
<a name="ln746">update_remaining_timeout(stonith_action_t * action)</a>
<a name="ln747">{</a>
<a name="ln748">    int diff = time(NULL) - action-&gt;initial_start_time;</a>
<a name="ln749"> </a>
<a name="ln750">    if (action-&gt;tries &gt;= action-&gt;max_retries) {</a>
<a name="ln751">        crm_info(&quot;Attempted to execute agent %s (%s) the maximum number of times (%d) allowed&quot;,</a>
<a name="ln752">                 action-&gt;agent, action-&gt;action, action-&gt;max_retries);</a>
<a name="ln753">        action-&gt;remaining_timeout = 0;</a>
<a name="ln754">    } else if ((action-&gt;rc != -ETIME) &amp;&amp; diff &lt; (action-&gt;timeout * 0.7)) {</a>
<a name="ln755">        /* only set remaining timeout period if there is 30%</a>
<a name="ln756">         * or greater of the original timeout period left */</a>
<a name="ln757">        action-&gt;remaining_timeout = action-&gt;timeout - diff;</a>
<a name="ln758">    } else {</a>
<a name="ln759">        action-&gt;remaining_timeout = 0;</a>
<a name="ln760">    }</a>
<a name="ln761">    return action-&gt;remaining_timeout ? TRUE : FALSE;</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">static void</a>
<a name="ln765">stonith_action_async_done(mainloop_child_t * p, pid_t pid, int core, int signo, int exitcode)</a>
<a name="ln766">{</a>
<a name="ln767">    stonith_action_t *action = mainloop_child_userdata(p);</a>
<a name="ln768"> </a>
<a name="ln769">    if (action-&gt;timer_sigterm &gt; 0) {</a>
<a name="ln770">        g_source_remove(action-&gt;timer_sigterm);</a>
<a name="ln771">        action-&gt;timer_sigterm = 0;</a>
<a name="ln772">    }</a>
<a name="ln773">    if (action-&gt;timer_sigkill &gt; 0) {</a>
<a name="ln774">        g_source_remove(action-&gt;timer_sigkill);</a>
<a name="ln775">        action-&gt;timer_sigkill = 0;</a>
<a name="ln776">    }</a>
<a name="ln777"> </a>
<a name="ln778">    action-&gt;output = read_output(action-&gt;fd_stdout);</a>
<a name="ln779">    action-&gt;error = read_output(action-&gt;fd_stderr);</a>
<a name="ln780"> </a>
<a name="ln781">    if (action-&gt;last_timeout_signo) {</a>
<a name="ln782">        action-&gt;rc = -ETIME;</a>
<a name="ln783">        crm_notice(&quot;Child process %d performing action '%s' timed out with signal %d&quot;,</a>
<a name="ln784">                   pid, action-&gt;action, action-&gt;last_timeout_signo);</a>
<a name="ln785"> </a>
<a name="ln786">    } else if (signo) {</a>
<a name="ln787">        action-&gt;rc = -ECONNABORTED;</a>
<a name="ln788">        crm_notice(&quot;Child process %d performing action '%s' timed out with signal %d&quot;,</a>
<a name="ln789">                   pid, action-&gt;action, signo);</a>
<a name="ln790"> </a>
<a name="ln791">    } else {</a>
<a name="ln792">        crm_debug(&quot;Child process %d performing action '%s' exited with rc %d&quot;,</a>
<a name="ln793">                  pid, action-&gt;action, exitcode);</a>
<a name="ln794">        if (exitcode &gt; 0) {</a>
<a name="ln795">            /* Try to provide a useful error code based on the fence agent's</a>
<a name="ln796">             * error output.</a>
<a name="ln797">             */</a>
<a name="ln798">            if (action-&gt;error == NULL) {</a>
<a name="ln799">                exitcode = -ENODATA;</a>
<a name="ln800"> </a>
<a name="ln801">            } else if (strstr(action-&gt;error, &quot;imed out&quot;)) {</a>
<a name="ln802">                /* Some agents have their own internal timeouts */</a>
<a name="ln803">                exitcode = -ETIMEDOUT;</a>
<a name="ln804"> </a>
<a name="ln805">            } else if (strstr(action-&gt;error, &quot;Unrecognised action&quot;)) {</a>
<a name="ln806">                exitcode = -EOPNOTSUPP;</a>
<a name="ln807"> </a>
<a name="ln808">            } else {</a>
<a name="ln809">                exitcode = -pcmk_err_generic;</a>
<a name="ln810">            }</a>
<a name="ln811">        }</a>
<a name="ln812">        action-&gt;rc = exitcode;</a>
<a name="ln813">    }</a>
<a name="ln814"> </a>
<a name="ln815">    log_action(action, pid);</a>
<a name="ln816"> </a>
<a name="ln817">    if (action-&gt;rc != pcmk_ok &amp;&amp; update_remaining_timeout(action)) {</a>
<a name="ln818">        int rc = internal_stonith_action_execute(action);</a>
<a name="ln819">        if (rc == pcmk_ok) {</a>
<a name="ln820">            return;</a>
<a name="ln821">        }</a>
<a name="ln822">    }</a>
<a name="ln823"> </a>
<a name="ln824">    if (action-&gt;done_cb) {</a>
<a name="ln825">        action-&gt;done_cb(pid, action-&gt;rc, action-&gt;output, action-&gt;userdata);</a>
<a name="ln826">    }</a>
<a name="ln827"> </a>
<a name="ln828">    stonith_action_destroy(action);</a>
<a name="ln829">}</a>
<a name="ln830"> </a>
<a name="ln831">static int</a>
<a name="ln832">internal_stonith_action_execute(stonith_action_t * action)</a>
<a name="ln833">{</a>
<a name="ln834">    int pid, status = 0, len, rc = -EPROTO;</a>
<a name="ln835">    int ret;</a>
<a name="ln836">    int total = 0;</a>
<a name="ln837">    int p_read_fd, p_write_fd;  /* parent read/write file descriptors */</a>
<a name="ln838">    int c_read_fd, c_write_fd;  /* child read/write file descriptors */</a>
<a name="ln839">    int c_stderr_fd, p_stderr_fd; /* parent/child side file descriptors for stderr */</a>
<a name="ln840">    int fd1[2];</a>
<a name="ln841">    int fd2[2];</a>
<a name="ln842">    int fd3[2];</a>
<a name="ln843">    int is_retry = 0;</a>
<a name="ln844"> </a>
<a name="ln845">    /* clear any previous tracking data */</a>
<a name="ln846">    stonith_action_clear_tracking_data(action);</a>
<a name="ln847"> </a>
<a name="ln848">    if (!action-&gt;tries) {</a>
<a name="ln849">        action-&gt;initial_start_time = time(NULL);</a>
<a name="ln850">    }</a>
<a name="ln851">    action-&gt;tries++;</a>
<a name="ln852"> </a>
<a name="ln853">    if (action-&gt;tries &gt; 1) {</a>
<a name="ln854">        crm_info(&quot;Attempt %d to execute %s (%s). remaining timeout is %d&quot;,</a>
<a name="ln855">                 action-&gt;tries, action-&gt;agent, action-&gt;action, action-&gt;remaining_timeout);</a>
<a name="ln856">        is_retry = 1;</a>
<a name="ln857">    }</a>
<a name="ln858"> </a>
<a name="ln859">    c_read_fd = c_write_fd = p_read_fd = p_write_fd = c_stderr_fd = p_stderr_fd = -1;</a>
<a name="ln860"> </a>
<a name="ln861">    if (action-&gt;args == NULL || action-&gt;agent == NULL)</a>
<a name="ln862">        goto fail;</a>
<a name="ln863">    len = strlen(action-&gt;args);</a>
<a name="ln864"> </a>
<a name="ln865">    if (pipe(fd1))</a>
<a name="ln866">        goto fail;</a>
<a name="ln867">    p_read_fd = fd1[0];</a>
<a name="ln868">    c_write_fd = fd1[1];</a>
<a name="ln869"> </a>
<a name="ln870">    if (pipe(fd2))</a>
<a name="ln871">        goto fail;</a>
<a name="ln872">    c_read_fd = fd2[0];</a>
<a name="ln873">    p_write_fd = fd2[1];</a>
<a name="ln874"> </a>
<a name="ln875">    if (pipe(fd3))</a>
<a name="ln876">        goto fail;</a>
<a name="ln877">    p_stderr_fd = fd3[0];</a>
<a name="ln878">    c_stderr_fd = fd3[1];</a>
<a name="ln879"> </a>
<a name="ln880">    crm_debug(&quot;forking&quot;);</a>
<a name="ln881">    pid = fork();</a>
<a name="ln882">    if (pid &lt; 0) {</a>
<a name="ln883">        rc = -ECHILD;</a>
<a name="ln884">        goto fail;</a>
<a name="ln885">    }</a>
<a name="ln886"> </a>
<a name="ln887">    if (!pid) {</a>
<a name="ln888">        /* child */</a>
<a name="ln889">        setpgid(0, 0);</a>
<a name="ln890"> </a>
<a name="ln891">        close(1);</a>
<a name="ln892">        /* coverity[leaked_handle] False positive */</a>
<a name="ln893">        if (dup(c_write_fd) &lt; 0)</a>
<a name="ln894">            goto fail;</a>
<a name="ln895">        close(2);</a>
<a name="ln896">        /* coverity[leaked_handle] False positive */</a>
<a name="ln897">        if (dup(c_stderr_fd) &lt; 0)</a>
<a name="ln898">            goto fail;</a>
<a name="ln899">        close(0);</a>
<a name="ln900">        /* coverity[leaked_handle] False positive */</a>
<a name="ln901">        if (dup(c_read_fd) &lt; 0)</a>
<a name="ln902">            goto fail;</a>
<a name="ln903"> </a>
<a name="ln904">        /* keep c_stderr_fd open so parent can report all errors. */</a>
<a name="ln905">        /* keep c_write_fd open so hostlist can be sent to parent. */</a>
<a name="ln906">        close(c_read_fd);</a>
<a name="ln907">        close(p_read_fd);</a>
<a name="ln908">        close(p_write_fd);</a>
<a name="ln909">        close(p_stderr_fd);</a>
<a name="ln910"> </a>
<a name="ln911">        /* keep retries from executing out of control */</a>
<a name="ln912">        if (is_retry) {</a>
<a name="ln913">            sleep(1);</a>
<a name="ln914">        }</a>
<a name="ln915">        execlp(action-&gt;agent, action-&gt;agent, NULL);</a>
<a name="ln916">        exit(EXIT_FAILURE);</a>
<a name="ln917">    }</a>
<a name="ln918"> </a>
<a name="ln919">    /* parent */</a>
<a name="ln920">    action-&gt;pid = pid;</a>
<a name="ln921">    ret = fcntl(p_read_fd, F_SETFL, fcntl(p_read_fd, F_GETFL, 0) | O_NONBLOCK);</a>
<a name="ln922">    if (ret &lt; 0) {</a>
<a name="ln923">        crm_perror(LOG_NOTICE, &quot;Could not change the output of %s to be non-blocking&quot;,</a>
<a name="ln924">                   action-&gt;agent);</a>
<a name="ln925">    }</a>
<a name="ln926">    ret = fcntl(p_stderr_fd, F_SETFL, fcntl(p_stderr_fd, F_GETFL, 0) | O_NONBLOCK);</a>
<a name="ln927">    if (ret &lt; 0) {</a>
<a name="ln928">        crm_perror(LOG_NOTICE, &quot;Could not change the stderr of %s to be non-blocking&quot;,</a>
<a name="ln929">                   action-&gt;agent);</a>
<a name="ln930">    }</a>
<a name="ln931"> </a>
<a name="ln932">    do {</a>
<a name="ln933">        crm_debug(&quot;sending args&quot;);</a>
<a name="ln934">        ret = write(p_write_fd, action-&gt;args + total, len - total);</a>
<a name="ln935">        if (ret &gt; 0) {</a>
<a name="ln936">            total += ret;</a>
<a name="ln937">        }</a>
<a name="ln938"> </a>
<a name="ln939">    } while (errno == EINTR &amp;&amp; total &lt; len);</a>
<a name="ln940"> </a>
<a name="ln941">    if (total != len) {</a>
<a name="ln942">        crm_perror(LOG_ERR, &quot;Sent %d not %d bytes&quot;, total, len);</a>
<a name="ln943">        if (ret &gt;= 0) {</a>
<a name="ln944">            rc = -ECOMM;</a>
<a name="ln945">        }</a>
<a name="ln946">        goto fail;</a>
<a name="ln947">    }</a>
<a name="ln948"> </a>
<a name="ln949">    close(p_write_fd); p_write_fd = -1;</a>
<a name="ln950"> </a>
<a name="ln951">    /* async */</a>
<a name="ln952">    if (action-&gt;async) {</a>
<a name="ln953">        action-&gt;fd_stdout = p_read_fd;</a>
<a name="ln954">        action-&gt;fd_stderr = p_stderr_fd;</a>
<a name="ln955">        mainloop_child_add(pid, 0/* Move the timeout here? */, action-&gt;action, action, stonith_action_async_done);</a>
<a name="ln956">        crm_trace(&quot;Op: %s on %s, pid: %d, timeout: %ds&quot;, action-&gt;action, action-&gt;agent, pid,</a>
<a name="ln957">                  action-&gt;remaining_timeout);</a>
<a name="ln958">        action-&gt;last_timeout_signo = 0;</a>
<a name="ln959">        if (action-&gt;remaining_timeout) {</a>
<a name="ln960">            action-&gt;timer_sigterm =</a>
<a name="ln961">                g_timeout_add(1000 * action-&gt;remaining_timeout, st_child_term, action);</a>
<a name="ln962">            action-&gt;timer_sigkill =</a>
<a name="ln963">                g_timeout_add(1000 * (action-&gt;remaining_timeout + 5), st_child_kill, action);</a>
<a name="ln964">        } else {</a>
<a name="ln965">            crm_err(&quot;No timeout set for stonith operation %s with device %s&quot;,</a>
<a name="ln966">                    action-&gt;action, action-&gt;agent);</a>
<a name="ln967">        }</a>
<a name="ln968"> </a>
<a name="ln969">        close(c_write_fd);</a>
<a name="ln970">        close(c_read_fd);</a>
<a name="ln971">        close(c_stderr_fd);</a>
<a name="ln972">        return 0;</a>
<a name="ln973"> </a>
<a name="ln974">    } else {</a>
<a name="ln975">        /* sync */</a>
<a name="ln976">        int timeout = action-&gt;remaining_timeout + 1;</a>
<a name="ln977">        pid_t p = 0;</a>
<a name="ln978"> </a>
<a name="ln979">        while (action-&gt;remaining_timeout &lt; 0 || timeout &gt; 0) {</a>
<a name="ln980">            p = waitpid(pid, &amp;status, WNOHANG);</a>
<a name="ln981">            if (p &gt; 0) {</a>
<a name="ln982">                break;</a>
<a name="ln983">            }</a>
<a name="ln984">            sleep(1);</a>
<a name="ln985">            timeout--;</a>
<a name="ln986">        }</a>
<a name="ln987"> </a>
<a name="ln988">        if (timeout == 0) {</a>
<a name="ln989">            int killrc = kill(-pid, SIGKILL);</a>
<a name="ln990"> </a>
<a name="ln991">            if (killrc &amp;&amp; errno != ESRCH) {</a>
<a name="ln992">                crm_err(&quot;kill(%d, KILL) failed: %s (%d)&quot;, pid, pcmk_strerror(errno), errno);</a>
<a name="ln993">            }</a>
<a name="ln994">            /*</a>
<a name="ln995">             * From sigprocmask(2):</a>
<a name="ln996">             * It is not possible to block SIGKILL or SIGSTOP.  Attempts to do so are silently ignored.</a>
<a name="ln997">             *</a>
<a name="ln998">             * This makes it safe to skip WNOHANG here</a>
<a name="ln999">             */</a>
<a name="ln1000">            p = waitpid(pid, &amp;status, 0);</a>
<a name="ln1001">        }</a>
<a name="ln1002"> </a>
<a name="ln1003">        if (p &lt;= 0) {</a>
<a name="ln1004">            crm_perror(LOG_ERR, &quot;waitpid(%d)&quot;, pid);</a>
<a name="ln1005"> </a>
<a name="ln1006">        } else if (p != pid) {</a>
<a name="ln1007">            crm_err(&quot;Waited for %d, got %d&quot;, pid, p);</a>
<a name="ln1008">        }</a>
<a name="ln1009"> </a>
<a name="ln1010">        action-&gt;output = read_output(p_read_fd);</a>
<a name="ln1011">        action-&gt;error = read_output(p_stderr_fd);</a>
<a name="ln1012"> </a>
<a name="ln1013">        action-&gt;rc = -ECONNABORTED;</a>
<a name="ln1014"> </a>
<a name="ln1015">        log_action(action, pid);</a>
<a name="ln1016"> </a>
<a name="ln1017">        rc = action-&gt;rc;</a>
<a name="ln1018">        if (timeout == 0) {</a>
<a name="ln1019">            action-&gt;rc = -ETIME;</a>
<a name="ln1020">        } else if (WIFEXITED(status)) {</a>
<a name="ln1021">            crm_debug(&quot;result = %d&quot;, WEXITSTATUS(status));</a>
<a name="ln1022">            action-&gt;rc = -WEXITSTATUS(status);</a>
<a name="ln1023">            rc = 0;</a>
<a name="ln1024"> </a>
<a name="ln1025">        } else if (WIFSIGNALED(status)) {</a>
<a name="ln1026">            crm_err(&quot;call %s for %s exited due to signal %d&quot;, action-&gt;action, action-&gt;agent,</a>
<a name="ln1027">                    WTERMSIG(status));</a>
<a name="ln1028"> </a>
<a name="ln1029">        } else {</a>
<a name="ln1030">            crm_err(&quot;call %s for %s returned unexpected status %#x&quot;,</a>
<a name="ln1031">                    action-&gt;action, action-&gt;agent, status);</a>
<a name="ln1032">        }</a>
<a name="ln1033">    }</a>
<a name="ln1034"> </a>
<a name="ln1035">  fail:</a>
<a name="ln1036"> </a>
<a name="ln1037">    if (p_read_fd &gt;= 0) {</a>
<a name="ln1038">        close(p_read_fd);</a>
<a name="ln1039">    }</a>
<a name="ln1040">    if (p_write_fd &gt;= 0) {</a>
<a name="ln1041">        close(p_write_fd);</a>
<a name="ln1042">    }</a>
<a name="ln1043">    if (p_stderr_fd &gt;= 0) {</a>
<a name="ln1044">        close(p_stderr_fd);</a>
<a name="ln1045">    }</a>
<a name="ln1046"> </a>
<a name="ln1047">    if (c_read_fd &gt;= 0) {</a>
<a name="ln1048">        close(c_read_fd);</a>
<a name="ln1049">    }</a>
<a name="ln1050">    if (c_write_fd &gt;= 0) {</a>
<a name="ln1051">        close(c_write_fd);</a>
<a name="ln1052">    }</a>
<a name="ln1053">    if (c_stderr_fd &gt;= 0) {</a>
<a name="ln1054">        close(c_stderr_fd);</a>
<a name="ln1055">    }</a>
<a name="ln1056"> </a>
<a name="ln1057">    return rc;</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060">GPid</a>
<a name="ln1061">stonith_action_execute_async(stonith_action_t * action,</a>
<a name="ln1062">                             void *userdata,</a>
<a name="ln1063">                             void (*done) (GPid pid, int rc, const char *output,</a>
<a name="ln1064">                                           gpointer user_data))</a>
<a name="ln1065">{</a>
<a name="ln1066">    int rc = 0;</a>
<a name="ln1067"> </a>
<a name="ln1068">    if (!action) {</a>
<a name="ln1069">        return -1;</a>
<a name="ln1070">    }</a>
<a name="ln1071"> </a>
<a name="ln1072">    action-&gt;userdata = userdata;</a>
<a name="ln1073">    action-&gt;done_cb = done;</a>
<a name="ln1074">    action-&gt;async = 1;</a>
<a name="ln1075"> </a>
<a name="ln1076">    rc = internal_stonith_action_execute(action);</a>
<a name="ln1077"> </a>
<a name="ln1078">    return rc &lt; 0 ? rc : action-&gt;pid;</a>
<a name="ln1079">}</a>
<a name="ln1080"> </a>
<a name="ln1081">int</a>
<a name="ln1082">stonith_action_execute(stonith_action_t * action, int *agent_result, char **output)</a>
<a name="ln1083">{</a>
<a name="ln1084">    int rc = 0;</a>
<a name="ln1085"> </a>
<a name="ln1086">    if (!action) {</a>
<a name="ln1087">        return -1;</a>
<a name="ln1088">    }</a>
<a name="ln1089"> </a>
<a name="ln1090">    do {</a>
<a name="ln1091">        rc = internal_stonith_action_execute(action);</a>
<a name="ln1092">        if (rc == pcmk_ok) {</a>
<a name="ln1093">            /* success! */</a>
<a name="ln1094">            break;</a>
<a name="ln1095">        }</a>
<a name="ln1096">        /* keep retrying while we have time left */</a>
<a name="ln1097">    } while (update_remaining_timeout(action));</a>
<a name="ln1098"> </a>
<a name="ln1099">    if (rc) {</a>
<a name="ln1100">        /* error */</a>
<a name="ln1101">        return rc;</a>
<a name="ln1102">    }</a>
<a name="ln1103"> </a>
<a name="ln1104">    if (agent_result) {</a>
<a name="ln1105">        *agent_result = action-&gt;rc;</a>
<a name="ln1106">    }</a>
<a name="ln1107">    if (output) {</a>
<a name="ln1108">        *output = action-&gt;output;</a>
<a name="ln1109">        action-&gt;output = NULL;  /* handed it off, do not free */</a>
<a name="ln1110">    }</a>
<a name="ln1111"> </a>
<a name="ln1112">    stonith_action_destroy(action);</a>
<a name="ln1113">    return rc;</a>
<a name="ln1114">}</a>
<a name="ln1115"> </a>
<a name="ln1116">static int</a>
<a name="ln1117">stonith_api_device_list(stonith_t * stonith, int call_options, const char *namespace,</a>
<a name="ln1118">                        stonith_key_value_t ** devices, int timeout)</a>
<a name="ln1119">{</a>
<a name="ln1120">    int count = 0;</a>
<a name="ln1121"> </a>
<a name="ln1122">    if (devices == NULL) {</a>
<a name="ln1123">        crm_err(&quot;Parameter error: stonith_api_device_list&quot;);</a>
<a name="ln1124">        return -EFAULT;</a>
<a name="ln1125">    }</a>
<a name="ln1126"> </a>
<a name="ln1127">    /* Include Heartbeat agents */</a>
<a name="ln1128">    if (namespace == NULL || safe_str_eq(&quot;heartbeat&quot;, namespace)) {</a>
<a name="ln1129">#if HAVE_STONITH_STONITH_H</a>
<a name="ln1130">        static gboolean need_init = TRUE;</a>
<a name="ln1131"> </a>
<a name="ln1132">        char **entry = NULL;</a>
<a name="ln1133">        char **type_list = NULL;</a>
<a name="ln1134">        static char **(*type_list_fn) (void) = NULL;</a>
<a name="ln1135">        static void (*type_free_fn) (char **) = NULL;</a>
<a name="ln1136"> </a>
<a name="ln1137">        if (need_init) {</a>
<a name="ln1138">            need_init = FALSE;</a>
<a name="ln1139">            type_list_fn =</a>
<a name="ln1140">                find_library_function(&amp;lha_agents_lib, LHA_STONITH_LIBRARY, &quot;stonith_types&quot;, FALSE);</a>
<a name="ln1141">            type_free_fn =</a>
<a name="ln1142">                find_library_function(&amp;lha_agents_lib, LHA_STONITH_LIBRARY, &quot;stonith_free_hostlist&quot;,</a>
<a name="ln1143">                                      FALSE);</a>
<a name="ln1144">        }</a>
<a name="ln1145"> </a>
<a name="ln1146">        if (type_list_fn) {</a>
<a name="ln1147">            type_list = (*type_list_fn) ();</a>
<a name="ln1148">        }</a>
<a name="ln1149"> </a>
<a name="ln1150">        for (entry = type_list; entry != NULL &amp;&amp; *entry; ++entry) {</a>
<a name="ln1151">            crm_trace(&quot;Added: %s&quot;, *entry);</a>
<a name="ln1152">            *devices = stonith_key_value_add(*devices, NULL, *entry);</a>
<a name="ln1153">            count++;</a>
<a name="ln1154">        }</a>
<a name="ln1155">        if (type_list &amp;&amp; type_free_fn) {</a>
<a name="ln1156">            (*type_free_fn) (type_list);</a>
<a name="ln1157">        }</a>
<a name="ln1158">#else</a>
<a name="ln1159">        if (namespace != NULL) {</a>
<a name="ln1160">            return -EINVAL;     /* Heartbeat agents not supported */</a>
<a name="ln1161">        }</a>
<a name="ln1162">#endif</a>
<a name="ln1163">    }</a>
<a name="ln1164"> </a>
<a name="ln1165">    /* Include Red Hat agents, basically: ls -1 @sbin_dir@/fence_* */</a>
<a name="ln1166">    if (namespace == NULL || safe_str_eq(&quot;redhat&quot;, namespace)) {</a>
<a name="ln1167">        struct dirent **namelist;</a>
<a name="ln1168">        int file_num = scandir(RH_STONITH_DIR, &amp;namelist, 0, alphasort);</a>
<a name="ln1169"> </a>
<a name="ln1170">        if (file_num &gt; 0) {</a>
<a name="ln1171">            struct stat prop;</a>
<a name="ln1172">            char buffer[FILENAME_MAX + 1];</a>
<a name="ln1173"> </a>
<a name="ln1174">            while (file_num--) {</a>
<a name="ln1175">                if ('.' == namelist[file_num]-&gt;d_name[0]) {</a>
<a name="ln1176">                    free(namelist[file_num]);</a>
<a name="ln1177">                    continue;</a>
<a name="ln1178"> </a>
<a name="ln1179">                } else if (0 != strncmp(RH_STONITH_PREFIX,</a>
<a name="ln1180">                                        namelist[file_num]-&gt;d_name, strlen(RH_STONITH_PREFIX))) {</a>
<a name="ln1181">                    free(namelist[file_num]);</a>
<a name="ln1182">                    continue;</a>
<a name="ln1183">                }</a>
<a name="ln1184"> </a>
<a name="ln1185">                snprintf(buffer, FILENAME_MAX, &quot;%s/%s&quot;, RH_STONITH_DIR, namelist[file_num]-&gt;d_name);</a>
<a name="ln1186">                if (stat(buffer, &amp;prop) == 0 &amp;&amp; S_ISREG(prop.st_mode)) {</a>
<a name="ln1187">                    *devices = stonith_key_value_add(*devices, NULL, namelist[file_num]-&gt;d_name);</a>
<a name="ln1188">                    count++;</a>
<a name="ln1189">                }</a>
<a name="ln1190"> </a>
<a name="ln1191">                free(namelist[file_num]);</a>
<a name="ln1192">            }</a>
<a name="ln1193">            free(namelist);</a>
<a name="ln1194">        }</a>
<a name="ln1195">    }</a>
<a name="ln1196"> </a>
<a name="ln1197">    return count;</a>
<a name="ln1198">}</a>
<a name="ln1199"> </a>
<a name="ln1200">#if HAVE_STONITH_STONITH_H</a>
<a name="ln1201">static inline char *</a>
<a name="ln1202">strdup_null(const char *val)</a>
<a name="ln1203">{</a>
<a name="ln1204">    if (val) {</a>
<a name="ln1205">        return strdup(val);</a>
<a name="ln1206">    }</a>
<a name="ln1207">    return NULL;</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210">static void</a>
<a name="ln1211">stonith_plugin(int priority, const char *fmt, ...) __attribute__((__format__ (__printf__, 2, 3)));</a>
<a name="ln1212"> </a>
<a name="ln1213">static void</a>
<a name="ln1214">stonith_plugin(int priority, const char *format, ...)</a>
<a name="ln1215">{</a>
<a name="ln1216">    int err = errno;</a>
<a name="ln1217"> </a>
<a name="ln1218">    va_list ap;</a>
<a name="ln1219">    int len = 0;</a>
<a name="ln1220">    char *string = NULL;</a>
<a name="ln1221"> </a>
<a name="ln1222">    va_start(ap, format);</a>
<a name="ln1223"> </a>
<a name="ln1224">    len = vasprintf (&amp;string, format, ap);</a>
<a name="ln1225">    CRM_ASSERT(len &gt; 0);</a>
<a name="ln1226"> </a>
<a name="ln1227">    do_crm_log_alias(priority, __FILE__, __func__, __LINE__, &quot;%s&quot;, string);</a>
<a name="ln1228"> </a>
<a name="ln1229">    free(string);</a>
<a name="ln1230">    errno = err;</a>
<a name="ln1231">}</a>
<a name="ln1232">#endif</a>
<a name="ln1233"> </a>
<a name="ln1234">static int</a>
<a name="ln1235">stonith_api_device_metadata(stonith_t * stonith, int call_options, const char *agent,</a>
<a name="ln1236">                            const char *namespace, char **output, int timeout)</a>
<a name="ln1237">{</a>
<a name="ln1238">    int rc = 0;</a>
<a name="ln1239">    char *buffer = NULL;</a>
<a name="ln1240">    const char *provider = get_stonith_provider(agent, namespace);</a>
<a name="ln1241"> </a>
<a name="ln1242">    crm_trace(&quot;looking up %s/%s metadata&quot;, agent, provider);</a>
<a name="ln1243"> </a>
<a name="ln1244">    /* By having this in a library, we can access it from stonith_admin</a>
<a name="ln1245">     *  when neither lrmd or stonith-ng are running</a>
<a name="ln1246">     * Important for the crm shell's validations...</a>
<a name="ln1247">     */</a>
<a name="ln1248"> </a>
<a name="ln1249">    if (safe_str_eq(provider, &quot;redhat&quot;)) {</a>
<a name="ln1250">        stonith_action_t *action = stonith_action_create(agent, &quot;metadata&quot;, NULL, 0, 5, NULL, NULL);</a>
<a name="ln1251">        int exec_rc = stonith_action_execute(action, &amp;rc, &amp;buffer);</a>
<a name="ln1252">        xmlNode *xml = NULL;</a>
<a name="ln1253">        xmlNode *actions = NULL;</a>
<a name="ln1254">        xmlXPathObject *xpathObj = NULL;</a>
<a name="ln1255"> </a>
<a name="ln1256">        if (exec_rc &lt; 0 || rc != 0 || buffer == NULL) {</a>
<a name="ln1257">            crm_warn(&quot;Could not obtain metadata for %s&quot;, agent);</a>
<a name="ln1258">            crm_debug(&quot;Query failed: %d %d: %s&quot;, exec_rc, rc, crm_str(buffer));</a>
<a name="ln1259">            free(buffer);       /* Just in case */</a>
<a name="ln1260">            return -EINVAL;</a>
<a name="ln1261">        }</a>
<a name="ln1262"> </a>
<a name="ln1263">        xml = string2xml(buffer);</a>
<a name="ln1264">        if(xml == NULL) {</a>
<a name="ln1265">            crm_warn(&quot;Metadata for %s is invalid&quot;, agent);</a>
<a name="ln1266">            free(buffer);</a>
<a name="ln1267">            return -EINVAL;</a>
<a name="ln1268">        }</a>
<a name="ln1269"> </a>
<a name="ln1270">        xpathObj = xpath_search(xml, &quot;//actions&quot;);</a>
<a name="ln1271">        if (numXpathResults(xpathObj) &gt; 0) {</a>
<a name="ln1272">            actions = getXpathResult(xpathObj, 0);</a>
<a name="ln1273">        }</a>
<a name="ln1274"> </a>
<a name="ln1275">        freeXpathObject(xpathObj);</a>
<a name="ln1276"> </a>
<a name="ln1277">        /* Now fudge the metadata so that the start/stop actions appear */</a>
<a name="ln1278">        xpathObj = xpath_search(xml, &quot;//action[@name='stop']&quot;);</a>
<a name="ln1279">        if (numXpathResults(xpathObj) &lt;= 0) {</a>
<a name="ln1280">            xmlNode *tmp = NULL;</a>
<a name="ln1281"> </a>
<a name="ln1282">            tmp = create_xml_node(actions, &quot;action&quot;);</a>
<a name="ln1283">            crm_xml_add(tmp, &quot;name&quot;, &quot;stop&quot;);</a>
<a name="ln1284">            crm_xml_add(tmp, &quot;timeout&quot;, &quot;20s&quot;);</a>
<a name="ln1285"> </a>
<a name="ln1286">            tmp = create_xml_node(actions, &quot;action&quot;);</a>
<a name="ln1287">            crm_xml_add(tmp, &quot;name&quot;, &quot;start&quot;);</a>
<a name="ln1288">            crm_xml_add(tmp, &quot;timeout&quot;, &quot;20s&quot;);</a>
<a name="ln1289">        }</a>
<a name="ln1290"> </a>
<a name="ln1291">        freeXpathObject(xpathObj);</a>
<a name="ln1292"> </a>
<a name="ln1293">        /* Now fudge the metadata so that the port isn't required in the configuration */</a>
<a name="ln1294">        xpathObj = xpath_search(xml, &quot;//parameter[@name='port']&quot;);</a>
<a name="ln1295">        if (numXpathResults(xpathObj) &gt; 0) {</a>
<a name="ln1296">            /* We'll fill this in */</a>
<a name="ln1297">            xmlNode *tmp = getXpathResult(xpathObj, 0);</a>
<a name="ln1298"> </a>
<a name="ln1299">            crm_xml_add(tmp, &quot;required&quot;, &quot;0&quot;);</a>
<a name="ln1300">        }</a>
<a name="ln1301"> </a>
<a name="ln1302">        freeXpathObject(xpathObj);</a>
<a name="ln1303">        free(buffer);</a>
<a name="ln1304">        buffer = dump_xml_formatted_with_text(xml);</a>
<a name="ln1305">        free_xml(xml);</a>
<a name="ln1306">        if (!buffer) {</a>
<a name="ln1307">            return -EINVAL;</a>
<a name="ln1308">        }</a>
<a name="ln1309"> </a>
<a name="ln1310">    } else {</a>
<a name="ln1311">#if !HAVE_STONITH_STONITH_H</a>
<a name="ln1312">        return -EINVAL;         /* Heartbeat agents not supported */</a>
<a name="ln1313">#else</a>
<a name="ln1314">        int bufferlen = 0;</a>
<a name="ln1315">        static const char *no_parameter_info = &quot;&lt;!-- no value --&gt;&quot;;</a>
<a name="ln1316"> </a>
<a name="ln1317">        Stonith *stonith_obj = NULL;</a>
<a name="ln1318"> </a>
<a name="ln1319">        static gboolean need_init = TRUE;</a>
<a name="ln1320">        static Stonith *(*st_new_fn) (const char *) = NULL;</a>
<a name="ln1321">        static const char *(*st_info_fn) (Stonith *, int) = NULL;</a>
<a name="ln1322">        static void (*st_del_fn) (Stonith *) = NULL;</a>
<a name="ln1323">        static void (*st_log_fn) (Stonith *, PILLogFun) = NULL;</a>
<a name="ln1324"> </a>
<a name="ln1325">        if (need_init) {</a>
<a name="ln1326">            need_init = FALSE;</a>
<a name="ln1327">            st_new_fn =</a>
<a name="ln1328">                find_library_function(&amp;lha_agents_lib, LHA_STONITH_LIBRARY, &quot;stonith_new&quot;, FALSE);</a>
<a name="ln1329">            st_del_fn =</a>
<a name="ln1330">                find_library_function(&amp;lha_agents_lib, LHA_STONITH_LIBRARY, &quot;stonith_delete&quot;,</a>
<a name="ln1331">                                      FALSE);</a>
<a name="ln1332">            st_log_fn =</a>
<a name="ln1333">                find_library_function(&amp;lha_agents_lib, LHA_STONITH_LIBRARY, &quot;stonith_set_log&quot;,</a>
<a name="ln1334">                                      FALSE);</a>
<a name="ln1335">            st_info_fn =</a>
<a name="ln1336">                find_library_function(&amp;lha_agents_lib, LHA_STONITH_LIBRARY, &quot;stonith_get_info&quot;,</a>
<a name="ln1337">                                      FALSE);</a>
<a name="ln1338">        }</a>
<a name="ln1339"> </a>
<a name="ln1340">        if (lha_agents_lib &amp;&amp; st_new_fn &amp;&amp; st_del_fn &amp;&amp; st_info_fn &amp;&amp; st_log_fn) {</a>
<a name="ln1341">            char *xml_meta_longdesc = NULL;</a>
<a name="ln1342">            char *xml_meta_shortdesc = NULL;</a>
<a name="ln1343"> </a>
<a name="ln1344">            char *meta_param = NULL;</a>
<a name="ln1345">            char *meta_longdesc = NULL;</a>
<a name="ln1346">            char *meta_shortdesc = NULL;</a>
<a name="ln1347"> </a>
<a name="ln1348">            stonith_obj = (*st_new_fn) (agent);</a>
<a name="ln1349">            if (stonith_obj) {</a>
<a name="ln1350">                (*st_log_fn) (stonith_obj, (PILLogFun) &amp; stonith_plugin);</a>
<a name="ln1351">                meta_longdesc = strdup_null((*st_info_fn) (stonith_obj, ST_DEVICEDESCR));</a>
<a name="ln1352">                if (meta_longdesc == NULL) {</a>
<a name="ln1353">                    crm_warn(&quot;no long description in %s's metadata.&quot;, agent);</a>
<a name="ln1354">                    meta_longdesc = strdup(no_parameter_info);</a>
<a name="ln1355">                }</a>
<a name="ln1356"> </a>
<a name="ln1357">                meta_shortdesc = strdup_null((*st_info_fn) (stonith_obj, ST_DEVICEID));</a>
<a name="ln1358">                if (meta_shortdesc == NULL) {</a>
<a name="ln1359">                    crm_warn(&quot;no short description in %s's metadata.&quot;, agent);</a>
<a name="ln1360">                    meta_shortdesc = strdup(no_parameter_info);</a>
<a name="ln1361">                }</a>
<a name="ln1362"> </a>
<a name="ln1363">                meta_param = strdup_null((*st_info_fn) (stonith_obj, ST_CONF_XML));</a>
<a name="ln1364">                if (meta_param == NULL) {</a>
<a name="ln1365">                    crm_warn(&quot;no list of parameters in %s's metadata.&quot;, agent);</a>
<a name="ln1366">                    meta_param = strdup(no_parameter_info);</a>
<a name="ln1367">                }</a>
<a name="ln1368">                (*st_del_fn) (stonith_obj);</a>
<a name="ln1369">            } else {</a>
<a name="ln1370">                return -EINVAL; /* Heartbeat agents not supported */</a>
<a name="ln1371">            }</a>
<a name="ln1372"> </a>
<a name="ln1373">            xml_meta_longdesc =</a>
<a name="ln1374">                (char *)xmlEncodeEntitiesReentrant(NULL, (const unsigned char *)meta_longdesc);</a>
<a name="ln1375">            xml_meta_shortdesc =</a>
<a name="ln1376">                (char *)xmlEncodeEntitiesReentrant(NULL, (const unsigned char *)meta_shortdesc);</a>
<a name="ln1377"> </a>
<a name="ln1378">            bufferlen = strlen(META_TEMPLATE) + strlen(agent)</a>
<a name="ln1379">                + strlen(xml_meta_longdesc) + strlen(xml_meta_shortdesc)</a>
<a name="ln1380">                + strlen(meta_param) + 1;</a>
<a name="ln1381"> </a>
<a name="ln1382">            buffer = calloc(1, bufferlen);</a>
<a name="ln1383">            snprintf(buffer, bufferlen - 1, META_TEMPLATE,</a>
<a name="ln1384">                     agent, xml_meta_longdesc, xml_meta_shortdesc, meta_param);</a>
<a name="ln1385"> </a>
<a name="ln1386">            xmlFree(xml_meta_longdesc);</a>
<a name="ln1387">            xmlFree(xml_meta_shortdesc);</a>
<a name="ln1388"> </a>
<a name="ln1389">            free(meta_shortdesc);</a>
<a name="ln1390">            free(meta_longdesc);</a>
<a name="ln1391">            free(meta_param);</a>
<a name="ln1392">        }</a>
<a name="ln1393">#endif</a>
<a name="ln1394">    }</a>
<a name="ln1395"> </a>
<a name="ln1396">    if (output) {</a>
<a name="ln1397">        *output = buffer;</a>
<a name="ln1398"> </a>
<a name="ln1399">    } else {</a>
<a name="ln1400">        free(buffer);</a>
<a name="ln1401">    }</a>
<a name="ln1402"> </a>
<a name="ln1403">    return rc;</a>
<a name="ln1404">}</a>
<a name="ln1405"> </a>
<a name="ln1406">static int</a>
<a name="ln1407">stonith_api_query(stonith_t * stonith, int call_options, const char *target,</a>
<a name="ln1408">                  stonith_key_value_t ** devices, int timeout)</a>
<a name="ln1409">{</a>
<a name="ln1410">    int rc = 0, lpc = 0, max = 0;</a>
<a name="ln1411"> </a>
<a name="ln1412">    xmlNode *data = NULL;</a>
<a name="ln1413">    xmlNode *output = NULL;</a>
<a name="ln1414">    xmlXPathObjectPtr xpathObj = NULL;</a>
<a name="ln1415"> </a>
<a name="ln1416">    CRM_CHECK(devices != NULL, return -EINVAL);</a>
<a name="ln1417"> </a>
<a name="ln1418">    data = create_xml_node(NULL, F_STONITH_DEVICE);</a>
<a name="ln1419">    crm_xml_add(data, F_STONITH_ORIGIN, __FUNCTION__);</a>
<a name="ln1420">    crm_xml_add(data, F_STONITH_TARGET, target);</a>
<a name="ln1421">    crm_xml_add(data, F_STONITH_ACTION, &quot;off&quot;);</a>
<a name="ln1422">    rc = stonith_send_command(stonith, STONITH_OP_QUERY, data, &amp;output, call_options, timeout);</a>
<a name="ln1423"> </a>
<a name="ln1424">    if (rc &lt; 0) {</a>
<a name="ln1425">        return rc;</a>
<a name="ln1426">    }</a>
<a name="ln1427"> </a>
<a name="ln1428">    xpathObj = xpath_search(output, &quot;//@agent&quot;);</a>
<a name="ln1429">    if (xpathObj) {</a>
<a name="ln1430">        max = numXpathResults(xpathObj);</a>
<a name="ln1431"> </a>
<a name="ln1432">        for (lpc = 0; lpc &lt; max; lpc++) {</a>
<a name="ln1433">            xmlNode *match = getXpathResult(xpathObj, lpc);</a>
<a name="ln1434"> </a>
<a name="ln1435">            CRM_LOG_ASSERT(match != NULL);</a>
<a name="ln1436">            if(match != NULL) {</a>
<a name="ln1437">                xmlChar *match_path = xmlGetNodePath(match);</a>
<a name="ln1438"> </a>
<a name="ln1439">                crm_info(&quot;%s[%d] = %s&quot;, &quot;//@agent&quot;, lpc, match_path);</a>
<a name="ln1440">                free(match_path);</a>
<a name="ln1441">                *devices = stonith_key_value_add(*devices, NULL, crm_element_value(match, XML_ATTR_ID));</a>
<a name="ln1442">            }</a>
<a name="ln1443">        }</a>
<a name="ln1444"> </a>
<a name="ln1445">        freeXpathObject(xpathObj);</a>
<a name="ln1446">    }</a>
<a name="ln1447"> </a>
<a name="ln1448">    free_xml(output);</a>
<a name="ln1449">    free_xml(data);</a>
<a name="ln1450">    return max;</a>
<a name="ln1451">}</a>
<a name="ln1452"> </a>
<a name="ln1453">static int</a>
<a name="ln1454">stonith_api_call(stonith_t * stonith,</a>
<a name="ln1455">                 int call_options,</a>
<a name="ln1456">                 const char *id,</a>
<a name="ln1457">                 const char *action, const char *victim, int timeout, xmlNode ** output)</a>
<a name="ln1458">{</a>
<a name="ln1459">    int rc = 0;</a>
<a name="ln1460">    xmlNode *data = NULL;</a>
<a name="ln1461"> </a>
<a name="ln1462">    data = create_xml_node(NULL, F_STONITH_DEVICE);</a>
<a name="ln1463">    crm_xml_add(data, F_STONITH_ORIGIN, __FUNCTION__);</a>
<a name="ln1464">    crm_xml_add(data, F_STONITH_DEVICE, id);</a>
<a name="ln1465">    crm_xml_add(data, F_STONITH_ACTION, action);</a>
<a name="ln1466">    crm_xml_add(data, F_STONITH_TARGET, victim);</a>
<a name="ln1467"> </a>
<a name="ln1468">    rc = stonith_send_command(stonith, STONITH_OP_EXEC, data, output, call_options, timeout);</a>
<a name="ln1469">    free_xml(data);</a>
<a name="ln1470"> </a>
<a name="ln1471">    return rc;</a>
<a name="ln1472">}</a>
<a name="ln1473"> </a>
<a name="ln1474">static int</a>
<a name="ln1475">stonith_api_list(stonith_t * stonith, int call_options, const char *id, char **list_info,</a>
<a name="ln1476">                 int timeout)</a>
<a name="ln1477">{</a>
<a name="ln1478">    int rc;</a>
<a name="ln1479">    xmlNode *output = NULL;</a>
<a name="ln1480"> </a>
<a name="ln1481">    rc = stonith_api_call(stonith, call_options, id, &quot;list&quot;, NULL, timeout, &amp;output);</a>
<a name="ln1482"> </a>
<a name="ln1483">    if (output &amp;&amp; list_info) {</a>
<a name="ln1484">        const char *list_str;</a>
<a name="ln1485"> </a>
<a name="ln1486">        list_str = crm_element_value(output, &quot;st_output&quot;);</a>
<a name="ln1487"> </a>
<a name="ln1488">        if (list_str) {</a>
<a name="ln1489">            *list_info = strdup(list_str);</a>
<a name="ln1490">        }</a>
<a name="ln1491">    }</a>
<a name="ln1492"> </a>
<a name="ln1493">    if (output) {</a>
<a name="ln1494">        free_xml(output);</a>
<a name="ln1495">    }</a>
<a name="ln1496"> </a>
<a name="ln1497">    return rc;</a>
<a name="ln1498">}</a>
<a name="ln1499"> </a>
<a name="ln1500">static int</a>
<a name="ln1501">stonith_api_monitor(stonith_t * stonith, int call_options, const char *id, int timeout)</a>
<a name="ln1502">{</a>
<a name="ln1503">    return stonith_api_call(stonith, call_options, id, &quot;monitor&quot;, NULL, timeout, NULL);</a>
<a name="ln1504">}</a>
<a name="ln1505"> </a>
<a name="ln1506">static int</a>
<a name="ln1507">stonith_api_status(stonith_t * stonith, int call_options, const char *id, const char *port,</a>
<a name="ln1508">                   int timeout)</a>
<a name="ln1509">{</a>
<a name="ln1510">    return stonith_api_call(stonith, call_options, id, &quot;status&quot;, port, timeout, NULL);</a>
<a name="ln1511">}</a>
<a name="ln1512"> </a>
<a name="ln1513">static int</a>
<a name="ln1514">stonith_api_fence(stonith_t * stonith, int call_options, const char *node, const char *action,</a>
<a name="ln1515">                  int timeout, int tolerance)</a>
<a name="ln1516">{</a>
<a name="ln1517">    int rc = 0;</a>
<a name="ln1518">    xmlNode *data = NULL;</a>
<a name="ln1519"> </a>
<a name="ln1520">    data = create_xml_node(NULL, __FUNCTION__);</a>
<a name="ln1521">    crm_xml_add(data, F_STONITH_TARGET, node);</a>
<a name="ln1522">    crm_xml_add(data, F_STONITH_ACTION, action);</a>
<a name="ln1523">    crm_xml_add_int(data, F_STONITH_TIMEOUT, timeout);</a>
<a name="ln1524">    crm_xml_add_int(data, F_STONITH_TOLERANCE, tolerance);</a>
<a name="ln1525"> </a>
<a name="ln1526">    rc = stonith_send_command(stonith, STONITH_OP_FENCE, data, NULL, call_options, timeout);</a>
<a name="ln1527">    free_xml(data);</a>
<a name="ln1528"> </a>
<a name="ln1529">    return rc;</a>
<a name="ln1530">}</a>
<a name="ln1531"> </a>
<a name="ln1532">static int</a>
<a name="ln1533">stonith_api_confirm(stonith_t * stonith, int call_options, const char *target)</a>
<a name="ln1534">{</a>
<a name="ln1535">    return stonith_api_fence(stonith, call_options | st_opt_manual_ack, target, &quot;off&quot;, 0, 0);</a>
<a name="ln1536">}</a>
<a name="ln1537"> </a>
<a name="ln1538">static int</a>
<a name="ln1539">stonith_api_history(stonith_t * stonith, int call_options, const char *node,</a>
<a name="ln1540">                    stonith_history_t ** history, int timeout)</a>
<a name="ln1541">{</a>
<a name="ln1542">    int rc = 0;</a>
<a name="ln1543">    xmlNode *data = NULL;</a>
<a name="ln1544">    xmlNode *output = NULL;</a>
<a name="ln1545">    stonith_history_t *last = NULL;</a>
<a name="ln1546"> </a>
<a name="ln1547">    *history = NULL;</a>
<a name="ln1548"> </a>
<a name="ln1549">    if (node) {</a>
<a name="ln1550">        data = create_xml_node(NULL, __FUNCTION__);</a>
<a name="ln1551">        crm_xml_add(data, F_STONITH_TARGET, node);</a>
<a name="ln1552">    }</a>
<a name="ln1553"> </a>
<a name="ln1554">    rc = stonith_send_command(stonith, STONITH_OP_FENCE_HISTORY, data, &amp;output,</a>
<a name="ln1555">                              call_options | st_opt_sync_call, timeout);</a>
<a name="ln1556">    free_xml(data);</a>
<a name="ln1557"> </a>
<a name="ln1558">    if (rc == 0) {</a>
<a name="ln1559">        xmlNode *op = NULL;</a>
<a name="ln1560">        xmlNode *reply = get_xpath_object(&quot;//&quot; F_STONITH_HISTORY_LIST, output, LOG_ERR);</a>
<a name="ln1561"> </a>
<a name="ln1562">        for (op = __xml_first_child(reply); op != NULL; op = __xml_next(op)) {</a>
<a name="ln1563">            stonith_history_t *kvp;</a>
<a name="ln1564"> </a>
<a name="ln1565">            kvp = calloc(1, sizeof(stonith_history_t));</a>
<a name="ln1566">            kvp-&gt;target = crm_element_value_copy(op, F_STONITH_TARGET);</a>
<a name="ln1567">            kvp-&gt;action = crm_element_value_copy(op, F_STONITH_ACTION);</a>
<a name="ln1568">            kvp-&gt;origin = crm_element_value_copy(op, F_STONITH_ORIGIN);</a>
<a name="ln1569">            kvp-&gt;delegate = crm_element_value_copy(op, F_STONITH_DELEGATE);</a>
<a name="ln1570">            kvp-&gt;client = crm_element_value_copy(op, F_STONITH_CLIENTNAME);</a>
<a name="ln1571">            crm_element_value_int(op, F_STONITH_DATE, &amp;kvp-&gt;completed);</a>
<a name="ln1572">            crm_element_value_int(op, F_STONITH_STATE, &amp;kvp-&gt;state);</a>
<a name="ln1573"> </a>
<a name="ln1574">            if (last) {</a>
<a name="ln1575">                last-&gt;next = kvp;</a>
<a name="ln1576">            } else {</a>
<a name="ln1577">                *history = kvp;</a>
<a name="ln1578">            }</a>
<a name="ln1579">            last = kvp;</a>
<a name="ln1580">        }</a>
<a name="ln1581">    }</a>
<a name="ln1582">    return rc;</a>
<a name="ln1583">}</a>
<a name="ln1584"> </a>
<a name="ln1585">gboolean</a>
<a name="ln1586">is_redhat_agent(const char *agent)</a>
<a name="ln1587">{</a>
<a name="ln1588">    int rc = 0;</a>
<a name="ln1589">    struct stat prop;</a>
<a name="ln1590">    char buffer[FILENAME_MAX + 1];</a>
<a name="ln1591"> </a>
<a name="ln1592">    snprintf(buffer, FILENAME_MAX, &quot;%s/%s&quot;, RH_STONITH_DIR, agent);</a>
<a name="ln1593">    rc = stat(buffer, &amp;prop);</a>
<a name="ln1594">    if (rc &gt;= 0 &amp;&amp; S_ISREG(prop.st_mode)) {</a>
<a name="ln1595">        return TRUE;</a>
<a name="ln1596">    }</a>
<a name="ln1597">    return FALSE;</a>
<a name="ln1598">}</a>
<a name="ln1599"> </a>
<a name="ln1600">const char *</a>
<a name="ln1601">get_stonith_provider(const char *agent, const char *provider)</a>
<a name="ln1602">{</a>
<a name="ln1603">    /* This function sucks */</a>
<a name="ln1604">    if (is_redhat_agent(agent)) {</a>
<a name="ln1605">        return &quot;redhat&quot;;</a>
<a name="ln1606"> </a>
<a name="ln1607">#if HAVE_STONITH_STONITH_H</a>
<a name="ln1608">    } else {</a>
<a name="ln1609">        Stonith *stonith_obj = NULL;</a>
<a name="ln1610"> </a>
<a name="ln1611">        static gboolean need_init = TRUE;</a>
<a name="ln1612">        static Stonith *(*st_new_fn) (const char *) = NULL;</a>
<a name="ln1613">        static void (*st_del_fn) (Stonith *) = NULL;</a>
<a name="ln1614"> </a>
<a name="ln1615">        if (need_init) {</a>
<a name="ln1616">            need_init = FALSE;</a>
<a name="ln1617">            st_new_fn =</a>
<a name="ln1618">                find_library_function(&amp;lha_agents_lib, LHA_STONITH_LIBRARY, &quot;stonith_new&quot;, FALSE);</a>
<a name="ln1619">            st_del_fn =</a>
<a name="ln1620">                find_library_function(&amp;lha_agents_lib, LHA_STONITH_LIBRARY, &quot;stonith_delete&quot;,</a>
<a name="ln1621">                                      FALSE);</a>
<a name="ln1622">        }</a>
<a name="ln1623"> </a>
<a name="ln1624">        if (lha_agents_lib &amp;&amp; st_new_fn &amp;&amp; st_del_fn) {</a>
<a name="ln1625">            stonith_obj = (*st_new_fn) (agent);</a>
<a name="ln1626">            if (stonith_obj) {</a>
<a name="ln1627">                (*st_del_fn) (stonith_obj);</a>
<a name="ln1628">                return &quot;heartbeat&quot;;</a>
<a name="ln1629">            }</a>
<a name="ln1630">        }</a>
<a name="ln1631">#endif</a>
<a name="ln1632">    }</a>
<a name="ln1633"> </a>
<a name="ln1634">    if (safe_str_eq(provider, &quot;internal&quot;)) {</a>
<a name="ln1635">        return provider;</a>
<a name="ln1636"> </a>
<a name="ln1637">    } else {</a>
<a name="ln1638">        crm_err(&quot;No such device: %s&quot;, agent);</a>
<a name="ln1639">        return NULL;</a>
<a name="ln1640">    }</a>
<a name="ln1641">}</a>
<a name="ln1642"> </a>
<a name="ln1643">static gint</a>
<a name="ln1644">stonithlib_GCompareFunc(gconstpointer a, gconstpointer b)</a>
<a name="ln1645">{</a>
<a name="ln1646">    int rc = 0;</a>
<a name="ln1647">    const stonith_notify_client_t *a_client = a;</a>
<a name="ln1648">    const stonith_notify_client_t *b_client = b;</a>
<a name="ln1649"> </a>
<a name="ln1650">    CRM_CHECK(a_client-&gt;event != NULL &amp;&amp; b_client-&gt;event != NULL, return 0);</a>
<a name="ln1651">    rc = strcmp(a_client-&gt;event, b_client-&gt;event);</a>
<a name="ln1652">    if (rc == 0) {</a>
<a name="ln1653">        if (a_client-&gt;notify == NULL || b_client-&gt;notify == NULL) {</a>
<a name="ln1654">            return 0;</a>
<a name="ln1655"> </a>
<a name="ln1656">        } else if (a_client-&gt;notify == b_client-&gt;notify) {</a>
<a name="ln1657">            return 0;</a>
<a name="ln1658"> </a>
<a name="ln1659">        } else if (((long)a_client-&gt;notify) &lt; ((long)b_client-&gt;notify)) {</a>
<a name="ln1660">            crm_err(&quot;callbacks for %s are not equal: %p vs. %p&quot;,</a>
<a name="ln1661">                    a_client-&gt;event, a_client-&gt;notify, b_client-&gt;notify);</a>
<a name="ln1662">            return -1;</a>
<a name="ln1663">        }</a>
<a name="ln1664">        crm_err(&quot;callbacks for %s are not equal: %p vs. %p&quot;,</a>
<a name="ln1665">                a_client-&gt;event, a_client-&gt;notify, b_client-&gt;notify);</a>
<a name="ln1666">        return 1;</a>
<a name="ln1667">    }</a>
<a name="ln1668">    return rc;</a>
<a name="ln1669">}</a>
<a name="ln1670"> </a>
<a name="ln1671">xmlNode *</a>
<a name="ln1672">stonith_create_op(int call_id, const char *token, const char *op, xmlNode * data, int call_options)</a>
<a name="ln1673">{</a>
<a name="ln1674">    xmlNode *op_msg = create_xml_node(NULL, &quot;stonith_command&quot;);</a>
<a name="ln1675"> </a>
<a name="ln1676">    CRM_CHECK(op_msg != NULL, return NULL);</a>
<a name="ln1677">    CRM_CHECK(token != NULL, return NULL);</a>
<a name="ln1678"> </a>
<a name="ln1679">    crm_xml_add(op_msg, F_XML_TAGNAME, &quot;stonith_command&quot;);</a>
<a name="ln1680"> </a>
<a name="ln1681">    crm_xml_add(op_msg, F_TYPE, T_STONITH_NG);</a>
<a name="ln1682">    crm_xml_add(op_msg, F_STONITH_CALLBACK_TOKEN, token);</a>
<a name="ln1683">    crm_xml_add(op_msg, F_STONITH_OPERATION, op);</a>
<a name="ln1684">    crm_xml_add_int(op_msg, F_STONITH_CALLID, call_id);</a>
<a name="ln1685">    crm_trace(&quot;Sending call options: %.8lx, %d&quot;, (long)call_options, call_options);</a>
<a name="ln1686">    crm_xml_add_int(op_msg, F_STONITH_CALLOPTS, call_options);</a>
<a name="ln1687"> </a>
<a name="ln1688">    if (data != NULL) {</a>
<a name="ln1689">        add_message_xml(op_msg, F_STONITH_CALLDATA, data);</a>
<a name="ln1690">    }</a>
<a name="ln1691"> </a>
<a name="ln1692">    return op_msg;</a>
<a name="ln1693">}</a>
<a name="ln1694"> </a>
<a name="ln1695">static void</a>
<a name="ln1696">stonith_destroy_op_callback(gpointer data)</a>
<a name="ln1697">{</a>
<a name="ln1698">    stonith_callback_client_t *blob = data;</a>
<a name="ln1699"> </a>
<a name="ln1700">    if (blob-&gt;timer &amp;&amp; blob-&gt;timer-&gt;ref &gt; 0) {</a>
<a name="ln1701">        g_source_remove(blob-&gt;timer-&gt;ref);</a>
<a name="ln1702">    }</a>
<a name="ln1703">    free(blob-&gt;timer);</a>
<a name="ln1704">    free(blob);</a>
<a name="ln1705">}</a>
<a name="ln1706"> </a>
<a name="ln1707">static int</a>
<a name="ln1708">stonith_api_signoff(stonith_t * stonith)</a>
<a name="ln1709">{</a>
<a name="ln1710">    stonith_private_t *native = stonith-&gt;private;</a>
<a name="ln1711"> </a>
<a name="ln1712">    crm_debug(&quot;Signing out of the STONITH Service&quot;);</a>
<a name="ln1713"> </a>
<a name="ln1714">    if (native-&gt;source != NULL) {</a>
<a name="ln1715">        /* Attached to mainloop */</a>
<a name="ln1716">        mainloop_del_ipc_client(native-&gt;source);</a>
<a name="ln1717">        native-&gt;source = NULL;</a>
<a name="ln1718">        native-&gt;ipc = NULL;</a>
<a name="ln1719"> </a>
<a name="ln1720">    } else if (native-&gt;ipc) {</a>
<a name="ln1721">        /* Not attached to mainloop */</a>
<a name="ln1722">        crm_ipc_t *ipc = native-&gt;ipc;</a>
<a name="ln1723"> </a>
<a name="ln1724">        native-&gt;ipc = NULL;</a>
<a name="ln1725">        crm_ipc_close(ipc);</a>
<a name="ln1726">        crm_ipc_destroy(ipc);</a>
<a name="ln1727">    }</a>
<a name="ln1728"> </a>
<a name="ln1729">    free(native-&gt;token); native-&gt;token = NULL;</a>
<a name="ln1730">    stonith-&gt;state = stonith_disconnected;</a>
<a name="ln1731">    return pcmk_ok;</a>
<a name="ln1732">}</a>
<a name="ln1733"> </a>
<a name="ln1734">static int</a>
<a name="ln1735">stonith_api_signon(stonith_t * stonith, const char *name, int *stonith_fd)</a>
<a name="ln1736">{</a>
<a name="ln1737">    int rc = pcmk_ok;</a>
<a name="ln1738">    stonith_private_t *native = stonith-&gt;private;</a>
<a name="ln1739"> </a>
<a name="ln1740">    static struct ipc_client_callbacks st_callbacks = {</a>
<a name="ln1741">        .dispatch = stonith_dispatch_internal,</a>
<a name="ln1742">        .destroy = stonith_connection_destroy</a>
<a name="ln1743">    };</a>
<a name="ln1744"> </a>
<a name="ln1745">    crm_trace(&quot;Connecting command channel&quot;);</a>
<a name="ln1746"> </a>
<a name="ln1747">    stonith-&gt;state = stonith_connected_command;</a>
<a name="ln1748">    if (stonith_fd) {</a>
<a name="ln1749">        /* No mainloop */</a>
<a name="ln1750">        native-&gt;ipc = crm_ipc_new(&quot;stonith-ng&quot;, 0);</a>
<a name="ln1751"> </a>
<a name="ln1752">        if (native-&gt;ipc &amp;&amp; crm_ipc_connect(native-&gt;ipc)) {</a>
<a name="ln1753">            *stonith_fd = crm_ipc_get_fd(native-&gt;ipc);</a>
<a name="ln1754">        } else if (native-&gt;ipc) {</a>
<a name="ln1755">            crm_perror(LOG_ERR, &quot;Connection to STONITH manager failed&quot;);</a>
<a name="ln1756">            rc = -ENOTCONN;</a>
<a name="ln1757">        }</a>
<a name="ln1758"> </a>
<a name="ln1759">    } else {</a>
<a name="ln1760">        /* With mainloop */</a>
<a name="ln1761">        native-&gt;source =</a>
<a name="ln1762">            mainloop_add_ipc_client(&quot;stonith-ng&quot;, G_PRIORITY_MEDIUM, 0, stonith, &amp;st_callbacks);</a>
<a name="ln1763">        native-&gt;ipc = mainloop_get_ipc_client(native-&gt;source);</a>
<a name="ln1764">    }</a>
<a name="ln1765"> </a>
<a name="ln1766">    if (native-&gt;ipc == NULL) {</a>
<a name="ln1767">        crm_debug(&quot;Could not connect to the Stonith API&quot;);</a>
<a name="ln1768">        rc = -ENOTCONN;</a>
<a name="ln1769">    }</a>
<a name="ln1770"> </a>
<a name="ln1771">    if (rc == pcmk_ok) {</a>
<a name="ln1772">        xmlNode *reply = NULL;</a>
<a name="ln1773">        xmlNode *hello = create_xml_node(NULL, &quot;stonith_command&quot;);</a>
<a name="ln1774"> </a>
<a name="ln1775">        crm_xml_add(hello, F_TYPE, T_STONITH_NG);</a>
<a name="ln1776">        crm_xml_add(hello, F_STONITH_OPERATION, CRM_OP_REGISTER);</a>
<a name="ln1777">        crm_xml_add(hello, F_STONITH_CLIENTNAME, name);</a>
<a name="ln1778">        rc = crm_ipc_send(native-&gt;ipc, hello, crm_ipc_client_response, -1, &amp;reply);</a>
<a name="ln1779"> </a>
<a name="ln1780">        if (rc &lt; 0) {</a>
<a name="ln1781">            crm_perror(LOG_DEBUG, &quot;Couldn't complete registration with the fencing API: %d&quot;, rc);</a>
<a name="ln1782">            rc = -ECOMM;</a>
<a name="ln1783"> </a>
<a name="ln1784">        } else if (reply == NULL) {</a>
<a name="ln1785">            crm_err(&quot;Did not receive registration reply&quot;);</a>
<a name="ln1786">            rc = -EPROTO;</a>
<a name="ln1787"> </a>
<a name="ln1788">        } else {</a>
<a name="ln1789">            const char *msg_type = crm_element_value(reply, F_STONITH_OPERATION);</a>
<a name="ln1790">            const char *tmp_ticket = crm_element_value(reply, F_STONITH_CLIENTID);</a>
<a name="ln1791"> </a>
<a name="ln1792">            if (safe_str_neq(msg_type, CRM_OP_REGISTER)) {</a>
<a name="ln1793">                crm_err(&quot;Invalid registration message: %s&quot;, msg_type);</a>
<a name="ln1794">                crm_log_xml_err(reply, &quot;Bad reply&quot;);</a>
<a name="ln1795">                rc = -EPROTO;</a>
<a name="ln1796"> </a>
<a name="ln1797">            } else if (tmp_ticket == NULL) {</a>
<a name="ln1798">                crm_err(&quot;No registration token provided&quot;);</a>
<a name="ln1799">                crm_log_xml_err(reply, &quot;Bad reply&quot;);</a>
<a name="ln1800">                rc = -EPROTO;</a>
<a name="ln1801"> </a>
<a name="ln1802">            } else {</a>
<a name="ln1803">                crm_trace(&quot;Obtained registration token: %s&quot;, tmp_ticket);</a>
<a name="ln1804">                native-&gt;token = strdup(tmp_ticket);</a>
<a name="ln1805">                rc = pcmk_ok;</a>
<a name="ln1806">            }</a>
<a name="ln1807">        }</a>
<a name="ln1808"> </a>
<a name="ln1809">        free_xml(reply);</a>
<a name="ln1810">        free_xml(hello);</a>
<a name="ln1811">    }</a>
<a name="ln1812"> </a>
<a name="ln1813">    if (rc == pcmk_ok) {</a>
<a name="ln1814">#if HAVE_MSGFROMIPC_TIMEOUT</a>
<a name="ln1815">        stonith-&gt;call_timeout = MAX_IPC_DELAY;</a>
<a name="ln1816">#endif</a>
<a name="ln1817">        crm_debug(&quot;Connection to STONITH successful&quot;);</a>
<a name="ln1818">        return pcmk_ok;</a>
<a name="ln1819">    }</a>
<a name="ln1820"> </a>
<a name="ln1821">    crm_debug(&quot;Connection to STONITH failed: %s&quot;, pcmk_strerror(rc));</a>
<a name="ln1822">    stonith-&gt;cmds-&gt;disconnect(stonith);</a>
<a name="ln1823">    return rc;</a>
<a name="ln1824">}</a>
<a name="ln1825"> </a>
<a name="ln1826">static int</a>
<a name="ln1827">stonith_set_notification(stonith_t * stonith, const char *callback, int enabled)</a>
<a name="ln1828">{</a>
<a name="ln1829">    int rc = pcmk_ok;</a>
<a name="ln1830">    xmlNode *notify_msg = create_xml_node(NULL, __FUNCTION__);</a>
<a name="ln1831">    stonith_private_t *native = stonith-&gt;private;</a>
<a name="ln1832"> </a>
<a name="ln1833">    if (stonith-&gt;state != stonith_disconnected) {</a>
<a name="ln1834"> </a>
<a name="ln1835">        crm_xml_add(notify_msg, F_STONITH_OPERATION, T_STONITH_NOTIFY);</a>
<a name="ln1836">        if (enabled) {</a>
<a name="ln1837">            crm_xml_add(notify_msg, F_STONITH_NOTIFY_ACTIVATE, callback);</a>
<a name="ln1838">        } else {</a>
<a name="ln1839">            crm_xml_add(notify_msg, F_STONITH_NOTIFY_DEACTIVATE, callback);</a>
<a name="ln1840">        }</a>
<a name="ln1841"> </a>
<a name="ln1842">        rc = crm_ipc_send(native-&gt;ipc, notify_msg, crm_ipc_client_response, -1, NULL);</a>
<a name="ln1843">        if (rc &lt; 0) {</a>
<a name="ln1844">            crm_perror(LOG_DEBUG, &quot;Couldn't register for fencing notifications: %d&quot;, rc);</a>
<a name="ln1845">            rc = -ECOMM;</a>
<a name="ln1846">        } else {</a>
<a name="ln1847">            rc = pcmk_ok;</a>
<a name="ln1848">        }</a>
<a name="ln1849">    }</a>
<a name="ln1850"> </a>
<a name="ln1851">    free_xml(notify_msg);</a>
<a name="ln1852">    return rc;</a>
<a name="ln1853">}</a>
<a name="ln1854"> </a>
<a name="ln1855">static int</a>
<a name="ln1856">stonith_api_add_notification(stonith_t * stonith, const char *event,</a>
<a name="ln1857">                             void (*callback) (stonith_t * stonith, stonith_event_t * e))</a>
<a name="ln1858">{</a>
<a name="ln1859">    GList *list_item = NULL;</a>
<a name="ln1860">    stonith_notify_client_t *new_client = NULL;</a>
<a name="ln1861">    stonith_private_t *private = NULL;</a>
<a name="ln1862"> </a>
<a name="ln1863">    private = stonith-&gt;private;</a>
<a name="ln1864">    crm_trace(&quot;Adding callback for %s events (%d)&quot;, event, g_list_length(private-&gt;notify_list));</a>
<a name="ln1865"> </a>
<a name="ln1866">    new_client = calloc(1, sizeof(stonith_notify_client_t));</a>
<a name="ln1867">    new_client-&gt;event = event;</a>
<a name="ln1868">    new_client-&gt;notify = callback;</a>
<a name="ln1869"> </a>
<a name="ln1870">    list_item = g_list_find_custom(private-&gt;notify_list, new_client, stonithlib_GCompareFunc);</a>
<a name="ln1871"> </a>
<a name="ln1872">    if (list_item != NULL) {</a>
<a name="ln1873">        crm_warn(&quot;Callback already present&quot;);</a>
<a name="ln1874">        free(new_client);</a>
<a name="ln1875">        return -ENOTUNIQ;</a>
<a name="ln1876"> </a>
<a name="ln1877">    } else {</a>
<a name="ln1878">        private-&gt;notify_list = g_list_append(private-&gt;notify_list, new_client);</a>
<a name="ln1879"> </a>
<a name="ln1880">        stonith_set_notification(stonith, event, 1);</a>
<a name="ln1881"> </a>
<a name="ln1882">        crm_trace(&quot;Callback added (%d)&quot;, g_list_length(private-&gt;notify_list));</a>
<a name="ln1883">    }</a>
<a name="ln1884">    return pcmk_ok;</a>
<a name="ln1885">}</a>
<a name="ln1886"> </a>
<a name="ln1887">static int</a>
<a name="ln1888">stonith_api_del_notification(stonith_t * stonith, const char *event)</a>
<a name="ln1889">{</a>
<a name="ln1890">    GList *list_item = NULL;</a>
<a name="ln1891">    stonith_notify_client_t *new_client = NULL;</a>
<a name="ln1892">    stonith_private_t *private = NULL;</a>
<a name="ln1893"> </a>
<a name="ln1894">    crm_debug(&quot;Removing callback for %s events&quot;, event);</a>
<a name="ln1895"> </a>
<a name="ln1896">    private = stonith-&gt;private;</a>
<a name="ln1897">    new_client = calloc(1, sizeof(stonith_notify_client_t));</a>
<a name="ln1898">    new_client-&gt;event = event;</a>
<a name="ln1899">    new_client-&gt;notify = NULL;</a>
<a name="ln1900"> </a>
<a name="ln1901">    list_item = g_list_find_custom(private-&gt;notify_list, new_client, stonithlib_GCompareFunc);</a>
<a name="ln1902"> </a>
<a name="ln1903">    stonith_set_notification(stonith, event, 0);</a>
<a name="ln1904"> </a>
<a name="ln1905">    if (list_item != NULL) {</a>
<a name="ln1906">        stonith_notify_client_t *list_client = list_item-&gt;data;</a>
<a name="ln1907"> </a>
<a name="ln1908">        private-&gt;notify_list = g_list_remove(private-&gt;notify_list, list_client);</a>
<a name="ln1909">        free(list_client);</a>
<a name="ln1910"> </a>
<a name="ln1911">        crm_trace(&quot;Removed callback&quot;);</a>
<a name="ln1912"> </a>
<a name="ln1913">    } else {</a>
<a name="ln1914">        crm_trace(&quot;Callback not present&quot;);</a>
<a name="ln1915">    }</a>
<a name="ln1916">    free(new_client);</a>
<a name="ln1917">    return pcmk_ok;</a>
<a name="ln1918">}</a>
<a name="ln1919"> </a>
<a name="ln1920">static gboolean</a>
<a name="ln1921">stonith_async_timeout_handler(gpointer data)</a>
<a name="ln1922">{</a>
<a name="ln1923">    struct timer_rec_s *timer = data;</a>
<a name="ln1924"> </a>
<a name="ln1925">    crm_err(&quot;Async call %d timed out after %dms&quot;, timer-&gt;call_id, timer-&gt;timeout);</a>
<a name="ln1926">    stonith_perform_callback(timer-&gt;stonith, NULL, timer-&gt;call_id, -ETIME);</a>
<a name="ln1927"> </a>
<a name="ln1928">    /* Always return TRUE, never remove the handler</a>
<a name="ln1929">     * We do that in stonith_del_callback()</a>
<a name="ln1930">     */</a>
<a name="ln1931">    return TRUE;</a>
<a name="ln1932">}</a>
<a name="ln1933"> </a>
<a name="ln1934">static void</a>
<a name="ln1935">set_callback_timeout(stonith_callback_client_t * callback, stonith_t * stonith, int call_id,</a>
<a name="ln1936">                     int timeout)</a>
<a name="ln1937">{</a>
<a name="ln1938">    struct timer_rec_s *async_timer = callback-&gt;timer;</a>
<a name="ln1939"> </a>
<a name="ln1940">    if (timeout &lt;= 0) {</a>
<a name="ln1941">        return;</a>
<a name="ln1942">    }</a>
<a name="ln1943"> </a>
<a name="ln1944">    if (!async_timer) {</a>
<a name="ln1945">        async_timer = calloc(1, sizeof(struct timer_rec_s));</a>
<a name="ln1946">        callback-&gt;timer = async_timer;</a>
<a name="ln1947">    }</a>
<a name="ln1948"> </a>
<a name="ln1949">    async_timer-&gt;stonith = stonith;</a>
<a name="ln1950">    async_timer-&gt;call_id = call_id;</a>
<a name="ln1951">    /* Allow a fair bit of grace to allow the server to tell us of a timeout</a>
<a name="ln1952">     * This is only a fallback</a>
<a name="ln1953">     */</a>
<a name="ln1954">    async_timer-&gt;timeout = (timeout + 60) * 1000;</a>
<a name="ln1955">    if (async_timer-&gt;ref) {</a>
<a name="ln1956">        g_source_remove(async_timer-&gt;ref);</a>
<a name="ln1957">    }</a>
<a name="ln1958">    async_timer-&gt;ref =</a>
<a name="ln1959">        g_timeout_add(async_timer-&gt;timeout, stonith_async_timeout_handler, async_timer);</a>
<a name="ln1960">}</a>
<a name="ln1961"> </a>
<a name="ln1962">static void</a>
<a name="ln1963">update_callback_timeout(int call_id, int timeout, stonith_t * st)</a>
<a name="ln1964">{</a>
<a name="ln1965">    stonith_callback_client_t *callback = NULL;</a>
<a name="ln1966">    stonith_private_t *private = st-&gt;private;</a>
<a name="ln1967"> </a>
<a name="ln1968">    callback = g_hash_table_lookup(private-&gt;stonith_op_callback_table, GINT_TO_POINTER(call_id));</a>
<a name="ln1969">    if (!callback || !callback-&gt;allow_timeout_updates) {</a>
<a name="ln1970">        return;</a>
<a name="ln1971">    }</a>
<a name="ln1972"> </a>
<a name="ln1973">    set_callback_timeout(callback, st, call_id, timeout);</a>
<a name="ln1974">}</a>
<a name="ln1975"> </a>
<a name="ln1976">static void</a>
<a name="ln1977">invoke_callback(stonith_t * st, int call_id, int rc, void *userdata,</a>
<a name="ln1978">                void (*callback) (stonith_t * st, stonith_callback_data_t * data))</a>
<a name="ln1979">{</a>
<a name="ln1980">    stonith_callback_data_t data = { 0, };</a>
<a name="ln1981"> </a>
<a name="ln1982">    data.call_id = call_id;</a>
<a name="ln1983">    data.rc = rc;</a>
<a name="ln1984">    data.userdata = userdata;</a>
<a name="ln1985"> </a>
<a name="ln1986">    callback(st, &amp;data);</a>
<a name="ln1987">}</a>
<a name="ln1988"> </a>
<a name="ln1989">static int</a>
<a name="ln1990">stonith_api_add_callback(stonith_t * stonith, int call_id, int timeout, int options,</a>
<a name="ln1991">                         void *user_data, const char *callback_name,</a>
<a name="ln1992">                         void (*callback) (stonith_t * st, stonith_callback_data_t * data))</a>
<a name="ln1993">{</a>
<a name="ln1994">    stonith_callback_client_t *blob = NULL;</a>
<a name="ln1995">    stonith_private_t *private = NULL;</a>
<a name="ln1996"> </a>
<a name="ln1997">    CRM_CHECK(stonith != NULL, return -EINVAL);</a>
<a name="ln1998">    CRM_CHECK(stonith-&gt;private != NULL, return -EINVAL);</a>
<a name="ln1999">    private = stonith-&gt;private;</a>
<a name="ln2000"> </a>
<a name="ln2001">    if (call_id == 0) {</a>
<a name="ln2002">        private-&gt;op_callback = callback;</a>
<a name="ln2003"> </a>
<a name="ln2004">    } else if (call_id &lt; 0) {</a>
<a name="ln2005">        if (!(options &amp; st_opt_report_only_success)) {</a>
<a name="ln2006">            crm_trace(&quot;Call failed, calling %s: %s&quot;, callback_name, pcmk_strerror(call_id));</a>
<a name="ln2007">            invoke_callback(stonith, call_id, call_id, user_data, callback);</a>
<a name="ln2008">        } else {</a>
<a name="ln2009">            crm_warn(&quot;STONITH call failed: %s&quot;, pcmk_strerror(call_id));</a>
<a name="ln2010">        }</a>
<a name="ln2011">        return FALSE;</a>
<a name="ln2012">    }</a>
<a name="ln2013"> </a>
<a name="ln2014">    blob = calloc(1, sizeof(stonith_callback_client_t));</a>
<a name="ln2015">    blob-&gt;id = callback_name;</a>
<a name="ln2016">    blob-&gt;only_success = (options &amp; st_opt_report_only_success) ? TRUE : FALSE;</a>
<a name="ln2017">    blob-&gt;user_data = user_data;</a>
<a name="ln2018">    blob-&gt;callback = callback;</a>
<a name="ln2019">    blob-&gt;allow_timeout_updates = (options &amp; st_opt_timeout_updates) ? TRUE : FALSE;</a>
<a name="ln2020"> </a>
<a name="ln2021">    if (timeout &gt; 0) {</a>
<a name="ln2022">        set_callback_timeout(blob, stonith, call_id, timeout);</a>
<a name="ln2023">    }</a>
<a name="ln2024"> </a>
<a name="ln2025">    g_hash_table_insert(private-&gt;stonith_op_callback_table, GINT_TO_POINTER(call_id), blob);</a>
<a name="ln2026">    crm_trace(&quot;Added callback to %s for call %d&quot;, callback_name, call_id);</a>
<a name="ln2027"> </a>
<a name="ln2028">    return TRUE;</a>
<a name="ln2029">}</a>
<a name="ln2030"> </a>
<a name="ln2031">static int</a>
<a name="ln2032">stonith_api_del_callback(stonith_t * stonith, int call_id, bool all_callbacks)</a>
<a name="ln2033">{</a>
<a name="ln2034">    stonith_private_t *private = stonith-&gt;private;</a>
<a name="ln2035"> </a>
<a name="ln2036">    if (all_callbacks) {</a>
<a name="ln2037">        private-&gt;op_callback = NULL;</a>
<a name="ln2038">        g_hash_table_destroy(private-&gt;stonith_op_callback_table);</a>
<a name="ln2039">        private-&gt;stonith_op_callback_table = g_hash_table_new_full(g_direct_hash, g_direct_equal,</a>
<a name="ln2040">                                                                   NULL,</a>
<a name="ln2041">                                                                   stonith_destroy_op_callback);</a>
<a name="ln2042"> </a>
<a name="ln2043">    } else if (call_id == 0) {</a>
<a name="ln2044">        private-&gt;op_callback = NULL;</a>
<a name="ln2045"> </a>
<a name="ln2046">    } else {</a>
<a name="ln2047">        g_hash_table_remove(private-&gt;stonith_op_callback_table, GINT_TO_POINTER(call_id));</a>
<a name="ln2048">    }</a>
<a name="ln2049">    return pcmk_ok;</a>
<a name="ln2050">}</a>
<a name="ln2051"> </a>
<a name="ln2052">static void</a>
<a name="ln2053">stonith_dump_pending_op(gpointer key, gpointer value, gpointer user_data)</a>
<a name="ln2054">{</a>
<a name="ln2055">    int call = GPOINTER_TO_INT(key);</a>
<a name="ln2056">    stonith_callback_client_t *blob = value;</a>
<a name="ln2057"> </a>
<a name="ln2058">    crm_debug(&quot;Call %d (%s): pending&quot;, call, crm_str(blob-&gt;id));</a>
<a name="ln2059">}</a>
<a name="ln2060"> </a>
<a name="ln2061">void</a>
<a name="ln2062">stonith_dump_pending_callbacks(stonith_t * stonith)</a>
<a name="ln2063">{</a>
<a name="ln2064">    stonith_private_t *private = stonith-&gt;private;</a>
<a name="ln2065"> </a>
<a name="ln2066">    if (private-&gt;stonith_op_callback_table == NULL) {</a>
<a name="ln2067">        return;</a>
<a name="ln2068">    }</a>
<a name="ln2069">    return g_hash_table_foreach(private-&gt;stonith_op_callback_table, stonith_dump_pending_op, NULL);</a>
<a name="ln2070">}</a>
<a name="ln2071"> </a>
<a name="ln2072">void</a>
<a name="ln2073">stonith_perform_callback(stonith_t * stonith, xmlNode * msg, int call_id, int rc)</a>
<a name="ln2074">{</a>
<a name="ln2075">    stonith_private_t *private = NULL;</a>
<a name="ln2076">    stonith_callback_client_t *blob = NULL;</a>
<a name="ln2077">    stonith_callback_client_t local_blob;</a>
<a name="ln2078"> </a>
<a name="ln2079">    CRM_CHECK(stonith != NULL, return);</a>
<a name="ln2080">    CRM_CHECK(stonith-&gt;private != NULL, return);</a>
<a name="ln2081"> </a>
<a name="ln2082">    private = stonith-&gt;private;</a>
<a name="ln2083"> </a>
<a name="ln2084">    local_blob.id = NULL;</a>
<a name="ln2085">    local_blob.callback = NULL;</a>
<a name="ln2086">    local_blob.user_data = NULL;</a>
<a name="ln2087">    local_blob.only_success = FALSE;</a>
<a name="ln2088"> </a>
<a name="ln2089">    if (msg != NULL) {</a>
<a name="ln2090">        crm_element_value_int(msg, F_STONITH_RC, &amp;rc);</a>
<a name="ln2091">        crm_element_value_int(msg, F_STONITH_CALLID, &amp;call_id);</a>
<a name="ln2092">    }</a>
<a name="ln2093"> </a>
<a name="ln2094">    CRM_CHECK(call_id &gt; 0, crm_log_xml_err(msg, &quot;Bad result&quot;));</a>
<a name="ln2095"> </a>
<a name="ln2096">    blob = g_hash_table_lookup(private-&gt;stonith_op_callback_table, GINT_TO_POINTER(call_id));</a>
<a name="ln2097"> </a>
<a name="ln2098">    if (blob != NULL) {</a>
<a name="ln2099">        local_blob = *blob;</a>
<a name="ln2100">        blob = NULL;</a>
<a name="ln2101"> </a>
<a name="ln2102">        stonith_api_del_callback(stonith, call_id, FALSE);</a>
<a name="ln2103"> </a>
<a name="ln2104">    } else {</a>
<a name="ln2105">        crm_trace(&quot;No callback found for call %d&quot;, call_id);</a>
<a name="ln2106">        local_blob.callback = NULL;</a>
<a name="ln2107">    }</a>
<a name="ln2108"> </a>
<a name="ln2109">    if (local_blob.callback != NULL &amp;&amp; (rc == pcmk_ok || local_blob.only_success == FALSE)) {</a>
<a name="ln2110">        crm_trace(&quot;Invoking callback %s for call %d&quot;, crm_str(local_blob.id), call_id);</a>
<a name="ln2111">        invoke_callback(stonith, call_id, rc, local_blob.user_data, local_blob.callback);</a>
<a name="ln2112"> </a>
<a name="ln2113">    } else if (private-&gt;op_callback == NULL &amp;&amp; rc != pcmk_ok) {</a>
<a name="ln2114">        crm_warn(&quot;STONITH command failed: %s&quot;, pcmk_strerror(rc));</a>
<a name="ln2115">        crm_log_xml_debug(msg, &quot;Failed STONITH Update&quot;);</a>
<a name="ln2116">    }</a>
<a name="ln2117"> </a>
<a name="ln2118">    if (private-&gt;op_callback != NULL) {</a>
<a name="ln2119">        crm_trace(&quot;Invoking global callback for call %d&quot;, call_id);</a>
<a name="ln2120">        invoke_callback(stonith, call_id, rc, NULL, private-&gt;op_callback);</a>
<a name="ln2121">    }</a>
<a name="ln2122">    crm_trace(&quot;OP callback activated.&quot;);</a>
<a name="ln2123">}</a>
<a name="ln2124"> </a>
<a name="ln2125">/*</a>
<a name="ln2126"> &lt;notify t=&quot;st_notify&quot; subt=&quot;st_device_register&quot; st_op=&quot;st_device_register&quot; st_rc=&quot;0&quot; &gt;</a>
<a name="ln2127">   &lt;st_calldata &gt;</a>
<a name="ln2128">     &lt;stonith_command t=&quot;stonith-ng&quot; st_async_id=&quot;088fb640-431a-48b9-b2fc-c4ff78d0a2d9&quot; st_op=&quot;st_device_register&quot; st_callid=&quot;2&quot; st_callopt=&quot;4096&quot; st_timeout=&quot;0&quot; st_clientid=&quot;088fb640-431a-48b9-b2fc-c4ff78d0a2d9&quot; st_clientname=&quot;stonith-test&quot; &gt;</a>
<a name="ln2129">       &lt;st_calldata &gt;</a>
<a name="ln2130">         &lt;st_device_id id=&quot;test-id&quot; origin=&quot;create_device_registration_xml&quot; agent=&quot;fence_virsh&quot; namespace=&quot;stonith-ng&quot; &gt;</a>
<a name="ln2131">           &lt;attributes ipaddr=&quot;localhost&quot; pcmk-portmal=&quot;some-host=pcmk-1 pcmk-3=3,4&quot; login=&quot;root&quot; identity_file=&quot;/root/.ssh/id_dsa&quot; /&gt;</a>
<a name="ln2132">         &lt;/st_device_id&gt;</a>
<a name="ln2133">       &lt;/st_calldata&gt;</a>
<a name="ln2134">     &lt;/stonith_command&gt;</a>
<a name="ln2135">   &lt;/st_calldata&gt;</a>
<a name="ln2136"> &lt;/notify&gt;</a>
<a name="ln2137"> </a>
<a name="ln2138"> &lt;notify t=&quot;st_notify&quot; subt=&quot;st_notify_fence&quot; st_op=&quot;st_notify_fence&quot; st_rc=&quot;0&quot; &gt;</a>
<a name="ln2139">   &lt;st_calldata &gt;</a>
<a name="ln2140">     &lt;st_notify_fence st_rc=&quot;0&quot; st_target=&quot;some-host&quot; st_op=&quot;st_fence&quot; st_delegate=&quot;test-id&quot; st_origin=&quot;61dd7759-e229-4be7-b1f8-ef49dd14d9f0&quot; /&gt;</a>
<a name="ln2141">   &lt;/st_calldata&gt;</a>
<a name="ln2142"> &lt;/notify&gt;</a>
<a name="ln2143">*/</a>
<a name="ln2144">static stonith_event_t *</a>
<a name="ln2145">xml_to_event(xmlNode * msg)</a>
<a name="ln2146">{</a>
<a name="ln2147">    stonith_event_t *event = calloc(1, sizeof(stonith_event_t));</a>
<a name="ln2148">    const char *ntype = crm_element_value(msg, F_SUBTYPE);</a>
<a name="ln2149">    char *data_addr = crm_strdup_printf(&quot;//%s&quot;, ntype);</a>
<a name="ln2150">    xmlNode *data = get_xpath_object(data_addr, msg, LOG_DEBUG);</a>
<a name="ln2151"> </a>
<a name="ln2152">    crm_log_xml_trace(msg, &quot;stonith_notify&quot;);</a>
<a name="ln2153"> </a>
<a name="ln2154">    crm_element_value_int(msg, F_STONITH_RC, &amp;(event-&gt;result));</a>
<a name="ln2155"> </a>
<a name="ln2156">    if (safe_str_eq(ntype, T_STONITH_NOTIFY_FENCE)) {</a>
<a name="ln2157">        event-&gt;operation = crm_element_value_copy(msg, F_STONITH_OPERATION);</a>
<a name="ln2158"> </a>
<a name="ln2159">        if (data) {</a>
<a name="ln2160">            event-&gt;origin = crm_element_value_copy(data, F_STONITH_ORIGIN);</a>
<a name="ln2161">            event-&gt;action = crm_element_value_copy(data, F_STONITH_ACTION);</a>
<a name="ln2162">            event-&gt;target = crm_element_value_copy(data, F_STONITH_TARGET);</a>
<a name="ln2163">            event-&gt;executioner = crm_element_value_copy(data, F_STONITH_DELEGATE);</a>
<a name="ln2164">            event-&gt;id = crm_element_value_copy(data, F_STONITH_REMOTE_OP_ID);</a>
<a name="ln2165">            event-&gt;client_origin = crm_element_value_copy(data, F_STONITH_CLIENTNAME);</a>
<a name="ln2166">            event-&gt;device = crm_element_value_copy(data, F_STONITH_DEVICE);</a>
<a name="ln2167"> </a>
<a name="ln2168">        } else {</a>
<a name="ln2169">            crm_err(&quot;No data for %s event&quot;, ntype);</a>
<a name="ln2170">            crm_log_xml_notice(msg, &quot;BadEvent&quot;);</a>
<a name="ln2171">        }</a>
<a name="ln2172">    }</a>
<a name="ln2173"> </a>
<a name="ln2174">    free(data_addr);</a>
<a name="ln2175">    return event;</a>
<a name="ln2176">}</a>
<a name="ln2177"> </a>
<a name="ln2178">static void</a>
<a name="ln2179">event_free(stonith_event_t * event)</a>
<a name="ln2180">{</a>
<a name="ln2181">    free(event-&gt;id);</a>
<a name="ln2182">    free(event-&gt;type);</a>
<a name="ln2183">    free(event-&gt;message);</a>
<a name="ln2184">    free(event-&gt;operation);</a>
<a name="ln2185">    free(event-&gt;origin);</a>
<a name="ln2186">    free(event-&gt;action);</a>
<a name="ln2187">    free(event-&gt;target);</a>
<a name="ln2188">    free(event-&gt;executioner);</a>
<a name="ln2189">    free(event-&gt;device);</a>
<a name="ln2190">    free(event-&gt;client_origin);</a>
<a name="ln2191">    free(event);</a>
<a name="ln2192">}</a>
<a name="ln2193"> </a>
<a name="ln2194">static void</a>
<a name="ln2195">stonith_send_notification(gpointer data, gpointer user_data)</a>
<a name="ln2196">{</a>
<a name="ln2197">    struct notify_blob_s *blob = user_data;</a>
<a name="ln2198">    stonith_notify_client_t *entry = data;</a>
<a name="ln2199">    stonith_event_t *st_event = NULL;</a>
<a name="ln2200">    const char *event = NULL;</a>
<a name="ln2201"> </a>
<a name="ln2202">    if (blob-&gt;xml == NULL) {</a>
<a name="ln2203">        crm_warn(&quot;Skipping callback - NULL message&quot;);</a>
<a name="ln2204">        return;</a>
<a name="ln2205">    }</a>
<a name="ln2206"> </a>
<a name="ln2207">    event = crm_element_value(blob-&gt;xml, F_SUBTYPE);</a>
<a name="ln2208"> </a>
<a name="ln2209">    if (entry == NULL) {</a>
<a name="ln2210">        crm_warn(&quot;Skipping callback - NULL callback client&quot;);</a>
<a name="ln2211">        return;</a>
<a name="ln2212"> </a>
<a name="ln2213">    } else if (entry-&gt;notify == NULL) {</a>
<a name="ln2214">        crm_warn(&quot;Skipping callback - NULL callback&quot;);</a>
<a name="ln2215">        return;</a>
<a name="ln2216"> </a>
<a name="ln2217">    } else if (safe_str_neq(entry-&gt;event, event)) {</a>
<a name="ln2218">        crm_trace(&quot;Skipping callback - event mismatch %p/%s vs. %s&quot;, entry, entry-&gt;event, event);</a>
<a name="ln2219">        return;</a>
<a name="ln2220">    }</a>
<a name="ln2221"> </a>
<a name="ln2222">    st_event = xml_to_event(blob-&gt;xml);</a>
<a name="ln2223"> </a>
<a name="ln2224">    crm_trace(&quot;Invoking callback for %p/%s event...&quot;, entry, event);</a>
<a name="ln2225">    entry-&gt;notify(blob-&gt;stonith, st_event);</a>
<a name="ln2226">    crm_trace(&quot;Callback invoked...&quot;);</a>
<a name="ln2227"> </a>
<a name="ln2228">    event_free(st_event);</a>
<a name="ln2229">}</a>
<a name="ln2230"> </a>
<a name="ln2231">int</a>
<a name="ln2232">stonith_send_command(stonith_t * stonith, const char *op, xmlNode * data, xmlNode ** output_data,</a>
<a name="ln2233">                     int call_options, int timeout)</a>
<a name="ln2234">{</a>
<a name="ln2235">    int rc = 0;</a>
<a name="ln2236">    int reply_id = -1;</a>
<a name="ln2237">    enum crm_ipc_flags ipc_flags = crm_ipc_flags_none;</a>
<a name="ln2238"> </a>
<a name="ln2239">    xmlNode *op_msg = NULL;</a>
<a name="ln2240">    xmlNode *op_reply = NULL;</a>
<a name="ln2241"> </a>
<a name="ln2242">    stonith_private_t *native = stonith-&gt;private;</a>
<a name="ln2243"> </a>
<a name="ln2244">    if (stonith-&gt;state == stonith_disconnected) {</a>
<a name="ln2245">        return -ENOTCONN;</a>
<a name="ln2246">    }</a>
<a name="ln2247"> </a>
<a name="ln2248">    if (output_data != NULL) {</a>
<a name="ln2249">        *output_data = NULL;</a>
<a name="ln2250">    }</a>
<a name="ln2251"> </a>
<a name="ln2252">    if (op == NULL) {</a>
<a name="ln2253">        crm_err(&quot;No operation specified&quot;);</a>
<a name="ln2254">        return -EINVAL;</a>
<a name="ln2255">    }</a>
<a name="ln2256"> </a>
<a name="ln2257">    if (call_options &amp; st_opt_sync_call) {</a>
<a name="ln2258">        ipc_flags |= crm_ipc_client_response;</a>
<a name="ln2259">    }</a>
<a name="ln2260"> </a>
<a name="ln2261">    stonith-&gt;call_id++;</a>
<a name="ln2262">    /* prevent call_id from being negative (or zero) and conflicting</a>
<a name="ln2263">     *    with the stonith_errors enum</a>
<a name="ln2264">     * use 2 because we use it as (stonith-&gt;call_id - 1) below</a>
<a name="ln2265">     */</a>
<a name="ln2266">    if (stonith-&gt;call_id &lt; 1) {</a>
<a name="ln2267">        stonith-&gt;call_id = 1;</a>
<a name="ln2268">    }</a>
<a name="ln2269"> </a>
<a name="ln2270">    CRM_CHECK(native-&gt;token != NULL,;</a>
<a name="ln2271">        );</a>
<a name="ln2272">    op_msg = stonith_create_op(stonith-&gt;call_id, native-&gt;token, op, data, call_options);</a>
<a name="ln2273">    if (op_msg == NULL) {</a>
<a name="ln2274">        return -EINVAL;</a>
<a name="ln2275">    }</a>
<a name="ln2276"> </a>
<a name="ln2277">    crm_xml_add_int(op_msg, F_STONITH_TIMEOUT, timeout);</a>
<a name="ln2278">    crm_trace(&quot;Sending %s message to STONITH service, Timeout: %ds&quot;, op, timeout);</a>
<a name="ln2279"> </a>
<a name="ln2280">    rc = crm_ipc_send(native-&gt;ipc, op_msg, ipc_flags, 1000 * (timeout + 60), &amp;op_reply);</a>
<a name="ln2281">    free_xml(op_msg);</a>
<a name="ln2282"> </a>
<a name="ln2283">    if (rc &lt; 0) {</a>
<a name="ln2284">        crm_perror(LOG_ERR, &quot;Couldn't perform %s operation (timeout=%ds): %d&quot;, op, timeout, rc);</a>
<a name="ln2285">        rc = -ECOMM;</a>
<a name="ln2286">        goto done;</a>
<a name="ln2287">    }</a>
<a name="ln2288"> </a>
<a name="ln2289">    crm_log_xml_trace(op_reply, &quot;Reply&quot;);</a>
<a name="ln2290"> </a>
<a name="ln2291">    if (!(call_options &amp; st_opt_sync_call)) {</a>
<a name="ln2292">        crm_trace(&quot;Async call %d, returning&quot;, stonith-&gt;call_id);</a>
<a name="ln2293">        CRM_CHECK(stonith-&gt;call_id != 0, return -EPROTO);</a>
<a name="ln2294">        free_xml(op_reply);</a>
<a name="ln2295"> </a>
<a name="ln2296">        return stonith-&gt;call_id;</a>
<a name="ln2297">    }</a>
<a name="ln2298"> </a>
<a name="ln2299">    rc = pcmk_ok;</a>
<a name="ln2300">    crm_element_value_int(op_reply, F_STONITH_CALLID, &amp;reply_id);</a>
<a name="ln2301"> </a>
<a name="ln2302">    if (reply_id == stonith-&gt;call_id) {</a>
<a name="ln2303">        crm_trace(&quot;Synchronous reply %d received&quot;, reply_id);</a>
<a name="ln2304"> </a>
<a name="ln2305">        if (crm_element_value_int(op_reply, F_STONITH_RC, &amp;rc) != 0) {</a>
<a name="ln2306">            rc = -ENOMSG;</a>
<a name="ln2307">        }</a>
<a name="ln2308"> </a>
<a name="ln2309">        if ((call_options &amp; st_opt_discard_reply) || output_data == NULL) {</a>
<a name="ln2310">            crm_trace(&quot;Discarding reply&quot;);</a>
<a name="ln2311"> </a>
<a name="ln2312">        } else {</a>
<a name="ln2313">            *output_data = op_reply;</a>
<a name="ln2314">            op_reply = NULL;    /* Prevent subsequent free */</a>
<a name="ln2315">        }</a>
<a name="ln2316"> </a>
<a name="ln2317">    } else if (reply_id &lt;= 0) {</a>
<a name="ln2318">        crm_err(&quot;Received bad reply: No id set&quot;);</a>
<a name="ln2319">        crm_log_xml_err(op_reply, &quot;Bad reply&quot;);</a>
<a name="ln2320">        free_xml(op_reply);</a>
<a name="ln2321">        rc = -ENOMSG;</a>
<a name="ln2322"> </a>
<a name="ln2323">    } else {</a>
<a name="ln2324">        crm_err(&quot;Received bad reply: %d (wanted %d)&quot;, reply_id, stonith-&gt;call_id);</a>
<a name="ln2325">        crm_log_xml_err(op_reply, &quot;Old reply&quot;);</a>
<a name="ln2326">        free_xml(op_reply);</a>
<a name="ln2327">        rc = -ENOMSG;</a>
<a name="ln2328">    }</a>
<a name="ln2329"> </a>
<a name="ln2330">  done:</a>
<a name="ln2331">    if (crm_ipc_connected(native-&gt;ipc) == FALSE) {</a>
<a name="ln2332">        crm_err(&quot;STONITH disconnected&quot;);</a>
<a name="ln2333">        stonith-&gt;state = stonith_disconnected;</a>
<a name="ln2334">    }</a>
<a name="ln2335"> </a>
<a name="ln2336">    free_xml(op_reply);</a>
<a name="ln2337">    return rc;</a>
<a name="ln2338">}</a>
<a name="ln2339"> </a>
<a name="ln2340">/* Not used with mainloop */</a>
<a name="ln2341">bool</a>
<a name="ln2342">stonith_dispatch(stonith_t * st)</a>
<a name="ln2343">{</a>
<a name="ln2344">    gboolean stay_connected = TRUE;</a>
<a name="ln2345">    stonith_private_t *private = NULL;</a>
<a name="ln2346"> </a>
<a name="ln2347">    CRM_ASSERT(st != NULL);</a>
<a name="ln2348">    private = st-&gt;private;</a>
<a name="ln2349"> </a>
<a name="ln2350">    while (crm_ipc_ready(private-&gt;ipc)) {</a>
<a name="ln2351"> </a>
<a name="ln2352">        if (crm_ipc_read(private-&gt;ipc) &gt; 0) {</a>
<a name="ln2353">            const char *msg = crm_ipc_buffer(private-&gt;ipc);</a>
<a name="ln2354"> </a>
<a name="ln2355">            stonith_dispatch_internal(msg, strlen(msg), st);</a>
<a name="ln2356">        }</a>
<a name="ln2357"> </a>
<a name="ln2358">        if (crm_ipc_connected(private-&gt;ipc) == FALSE) {</a>
<a name="ln2359">            crm_err(&quot;Connection closed&quot;);</a>
<a name="ln2360">            stay_connected = FALSE;</a>
<a name="ln2361">        }</a>
<a name="ln2362">    }</a>
<a name="ln2363"> </a>
<a name="ln2364">    return stay_connected;</a>
<a name="ln2365">}</a>
<a name="ln2366"> </a>
<a name="ln2367">int</a>
<a name="ln2368">stonith_dispatch_internal(const char *buffer, ssize_t length, gpointer userdata)</a>
<a name="ln2369">{</a>
<a name="ln2370">    const char *type = NULL;</a>
<a name="ln2371">    struct notify_blob_s blob;</a>
<a name="ln2372"> </a>
<a name="ln2373">    stonith_t *st = userdata;</a>
<a name="ln2374">    stonith_private_t *private = NULL;</a>
<a name="ln2375"> </a>
<a name="ln2376">    CRM_ASSERT(st != NULL);</a>
<a name="ln2377">    private = st-&gt;private;</a>
<a name="ln2378"> </a>
<a name="ln2379">    blob.stonith = st;</a>
<a name="ln2380">    blob.xml = string2xml(buffer);</a>
<a name="ln2381">    if (blob.xml == NULL) {</a>
<a name="ln2382">        crm_warn(&quot;Received a NULL msg from STONITH service: %s.&quot;, buffer);</a>
<a name="ln2383">        return 0;</a>
<a name="ln2384">    }</a>
<a name="ln2385"> </a>
<a name="ln2386">    /* do callbacks */</a>
<a name="ln2387">    type = crm_element_value(blob.xml, F_TYPE);</a>
<a name="ln2388">    crm_trace(&quot;Activating %s callbacks...&quot;, type);</a>
<a name="ln2389"> </a>
<a name="ln2390">    if (safe_str_eq(type, T_STONITH_NG)) {</a>
<a name="ln2391">        stonith_perform_callback(st, blob.xml, 0, 0);</a>
<a name="ln2392"> </a>
<a name="ln2393">    } else if (safe_str_eq(type, T_STONITH_NOTIFY)) {</a>
<a name="ln2394">        g_list_foreach(private-&gt;notify_list, stonith_send_notification, &amp;blob);</a>
<a name="ln2395">    } else if (safe_str_eq(type, T_STONITH_TIMEOUT_VALUE)) {</a>
<a name="ln2396">        int call_id = 0;</a>
<a name="ln2397">        int timeout = 0;</a>
<a name="ln2398"> </a>
<a name="ln2399">        crm_element_value_int(blob.xml, F_STONITH_TIMEOUT, &amp;timeout);</a>
<a name="ln2400">        crm_element_value_int(blob.xml, F_STONITH_CALLID, &amp;call_id);</a>
<a name="ln2401"> </a>
<a name="ln2402">        update_callback_timeout(call_id, timeout, st);</a>
<a name="ln2403">    } else {</a>
<a name="ln2404">        crm_err(&quot;Unknown message type: %s&quot;, type);</a>
<a name="ln2405">        crm_log_xml_warn(blob.xml, &quot;BadReply&quot;);</a>
<a name="ln2406">    }</a>
<a name="ln2407"> </a>
<a name="ln2408">    free_xml(blob.xml);</a>
<a name="ln2409">    return 1;</a>
<a name="ln2410">}</a>
<a name="ln2411"> </a>
<a name="ln2412">static int</a>
<a name="ln2413">stonith_api_free(stonith_t * stonith)</a>
<a name="ln2414">{</a>
<a name="ln2415">    int rc = pcmk_ok;</a>
<a name="ln2416"> </a>
<a name="ln2417">    crm_trace(&quot;Destroying %p&quot;, stonith);</a>
<a name="ln2418"> </a>
<a name="ln2419">    if (stonith-&gt;state != stonith_disconnected) {</a>
<a name="ln2420">        crm_trace(&quot;Disconnecting %p first&quot;, stonith);</a>
<a name="ln2421">        rc = stonith-&gt;cmds-&gt;disconnect(stonith);</a>
<a name="ln2422">    }</a>
<a name="ln2423"> </a>
<a name="ln2424">    if (stonith-&gt;state == stonith_disconnected) {</a>
<a name="ln2425">        stonith_private_t *private = stonith-&gt;private;</a>
<a name="ln2426"> </a>
<a name="ln2427">        crm_trace(&quot;Removing %d callbacks&quot;, g_hash_table_size(private-&gt;stonith_op_callback_table));</a>
<a name="ln2428">        g_hash_table_destroy(private-&gt;stonith_op_callback_table);</a>
<a name="ln2429"> </a>
<a name="ln2430">        crm_trace(&quot;Destroying %d notification clients&quot;, g_list_length(private-&gt;notify_list));</a>
<a name="ln2431">        g_list_free_full(private-&gt;notify_list, free);</a>
<a name="ln2432"> </a>
<a name="ln2433">        free(stonith-&gt;private);</a>
<a name="ln2434">        free(stonith-&gt;cmds);</a>
<a name="ln2435">        free(stonith);</a>
<a name="ln2436"> </a>
<a name="ln2437">    } else {</a>
<a name="ln2438">        crm_err(&quot;Not free'ing active connection: %s (%d)&quot;, pcmk_strerror(rc), rc);</a>
<a name="ln2439">    }</a>
<a name="ln2440"> </a>
<a name="ln2441">    return rc;</a>
<a name="ln2442">}</a>
<a name="ln2443"> </a>
<a name="ln2444">void</a>
<a name="ln2445">stonith_api_delete(stonith_t * stonith)</a>
<a name="ln2446">{</a>
<a name="ln2447">    crm_trace(&quot;Destroying %p&quot;, stonith);</a>
<a name="ln2448">    if(stonith) {</a>
<a name="ln2449">        stonith-&gt;cmds-&gt;free(stonith);</a>
<a name="ln2450">    }</a>
<a name="ln2451">}</a>
<a name="ln2452"> </a>
<a name="ln2453">stonith_t *</a>
<a name="ln2454">stonith_api_new(void)</a>
<a name="ln2455">{</a>
<a name="ln2456">    stonith_t *new_stonith = NULL;</a>
<a name="ln2457">    stonith_private_t *private = NULL;</a>
<a name="ln2458"> </a>
<a name="ln2459">    new_stonith = calloc(1, sizeof(stonith_t));</a>
<a name="ln2460">    private = calloc(1, sizeof(stonith_private_t));</a>
<a name="ln2461">    new_stonith-&gt;private = private;</a>
<a name="ln2462"> </a>
<a name="ln2463">    private-&gt;stonith_op_callback_table = g_hash_table_new_full(g_direct_hash, g_direct_equal,</a>
<a name="ln2464">                                                               NULL, stonith_destroy_op_callback);</a>
<a name="ln2465">    private-&gt;notify_list = NULL;</a>
<a name="ln2466"> </a>
<a name="ln2467">    new_stonith-&gt;call_id = 1;</a>
<a name="ln2468">    new_stonith-&gt;state = stonith_disconnected;</a>
<a name="ln2469"> </a>
<a name="ln2470">    new_stonith-&gt;cmds = calloc(1, sizeof(stonith_api_operations_t));</a>
<a name="ln2471"> </a>
<a name="ln2472">/* *INDENT-OFF* */</a>
<a name="ln2473">    new_stonith-&gt;cmds-&gt;free       = stonith_api_free;</a>
<a name="ln2474">    new_stonith-&gt;cmds-&gt;connect    = stonith_api_signon;</a>
<a name="ln2475">    new_stonith-&gt;cmds-&gt;disconnect = stonith_api_signoff;</a>
<a name="ln2476"> </a>
<a name="ln2477">    new_stonith-&gt;cmds-&gt;list       = stonith_api_list;</a>
<a name="ln2478">    new_stonith-&gt;cmds-&gt;monitor    = stonith_api_monitor;</a>
<a name="ln2479">    new_stonith-&gt;cmds-&gt;status     = stonith_api_status;</a>
<a name="ln2480">    new_stonith-&gt;cmds-&gt;fence      = stonith_api_fence;</a>
<a name="ln2481">    new_stonith-&gt;cmds-&gt;confirm    = stonith_api_confirm;</a>
<a name="ln2482">    new_stonith-&gt;cmds-&gt;history    = stonith_api_history;</a>
<a name="ln2483"> </a>
<a name="ln2484">    new_stonith-&gt;cmds-&gt;list_agents  = stonith_api_device_list;</a>
<a name="ln2485">    new_stonith-&gt;cmds-&gt;metadata     = stonith_api_device_metadata;</a>
<a name="ln2486"> </a>
<a name="ln2487">    new_stonith-&gt;cmds-&gt;query           = stonith_api_query;</a>
<a name="ln2488">    new_stonith-&gt;cmds-&gt;remove_device   = stonith_api_remove_device;</a>
<a name="ln2489">    new_stonith-&gt;cmds-&gt;register_device = stonith_api_register_device;</a>
<a name="ln2490"> </a>
<a name="ln2491">    new_stonith-&gt;cmds-&gt;remove_level          = stonith_api_remove_level;</a>
<a name="ln2492">    new_stonith-&gt;cmds-&gt;remove_level_full     = stonith_api_remove_level_full;</a>
<a name="ln2493">    new_stonith-&gt;cmds-&gt;register_level        = stonith_api_register_level;</a>
<a name="ln2494">    new_stonith-&gt;cmds-&gt;register_level_full   = stonith_api_register_level_full;</a>
<a name="ln2495"> </a>
<a name="ln2496">    new_stonith-&gt;cmds-&gt;remove_callback       = stonith_api_del_callback;</a>
<a name="ln2497">    new_stonith-&gt;cmds-&gt;register_callback     = stonith_api_add_callback;</a>
<a name="ln2498">    new_stonith-&gt;cmds-&gt;remove_notification   = stonith_api_del_notification;</a>
<a name="ln2499">    new_stonith-&gt;cmds-&gt;register_notification = stonith_api_add_notification;</a>
<a name="ln2500">/* *INDENT-ON* */</a>
<a name="ln2501"> </a>
<a name="ln2502">    return new_stonith;</a>
<a name="ln2503">}</a>
<a name="ln2504"> </a>
<a name="ln2505">stonith_key_value_t *</a>
<a name="ln2506">stonith_key_value_add(stonith_key_value_t * head, const char *key, const char *value)</a>
<a name="ln2507">{</a>
<a name="ln2508">    stonith_key_value_t *p, *end;</a>
<a name="ln2509"> </a>
<a name="ln2510">    p = calloc(1, sizeof(stonith_key_value_t));</a>
<a name="ln2511">    if (key) {</a>
<a name="ln2512">        p-&gt;key = strdup(key);</a>
<a name="ln2513">    }</a>
<a name="ln2514">    if (value) {</a>
<a name="ln2515">        p-&gt;value = strdup(value);</a>
<a name="ln2516">    }</a>
<a name="ln2517"> </a>
<a name="ln2518">    end = head;</a>
<a name="ln2519">    while (end &amp;&amp; end-&gt;next) {</a>
<a name="ln2520">        end = end-&gt;next;</a>
<a name="ln2521">    }</a>
<a name="ln2522"> </a>
<a name="ln2523">    if (end) {</a>
<a name="ln2524">        end-&gt;next = p;</a>
<a name="ln2525">    } else {</a>
<a name="ln2526">        head = p;</a>
<a name="ln2527">    }</a>
<a name="ln2528"> </a>
<a name="ln2529">    return head;</a>
<a name="ln2530">}</a>
<a name="ln2531"> </a>
<a name="ln2532">void</a>
<a name="ln2533">stonith_key_value_freeall(stonith_key_value_t * head, int keys, int values)</a>
<a name="ln2534">{</a>
<a name="ln2535">    stonith_key_value_t *p;</a>
<a name="ln2536"> </a>
<a name="ln2537">    while (head) {</a>
<a name="ln2538">        p = head-&gt;next;</a>
<a name="ln2539">        if (keys) {</a>
<a name="ln2540">            free(head-&gt;key);</a>
<a name="ln2541">        }</a>
<a name="ln2542">        if (values) {</a>
<a name="ln2543">            free(head-&gt;value);</a>
<a name="ln2544">        }</a>
<a name="ln2545">        free(head);</a>
<a name="ln2546">        head = p;</a>
<a name="ln2547">    }</a>
<a name="ln2548">}</a>
<a name="ln2549"> </a>
<a name="ln2550">#define api_log_open() openlog(&quot;stonith-api&quot;, LOG_CONS | LOG_NDELAY | LOG_PID, LOG_DAEMON)</a>
<a name="ln2551">#define api_log(level, fmt, args...) syslog(level, &quot;%s: &quot;fmt, __FUNCTION__, args)</a>
<a name="ln2552"> </a>
<a name="ln2553">int</a>
<a name="ln2554">stonith_api_kick(uint32_t nodeid, const char *uname, int timeout, bool off)</a>
<a name="ln2555">{</a>
<a name="ln2556">    char *name = NULL;</a>
<a name="ln2557">    const char *action = &quot;reboot&quot;;</a>
<a name="ln2558"> </a>
<a name="ln2559">    int rc = -EPROTO;</a>
<a name="ln2560">    stonith_t *st = NULL;</a>
<a name="ln2561">    enum stonith_call_options opts = st_opt_sync_call | st_opt_allow_suicide;</a>
<a name="ln2562"> </a>
<a name="ln2563">    api_log_open();</a>
<a name="ln2564">    st = stonith_api_new();</a>
<a name="ln2565">    if (st) {</a>
<a name="ln2566">        rc = st-&gt;cmds-&gt;connect(st, &quot;stonith-api&quot;, NULL);</a>
<a name="ln2567">        if(rc != pcmk_ok) {</a>
<a name="ln2568">            api_log(LOG_ERR, &quot;Connection failed, could not kick (%s) node %u/%s : %s (%d)&quot;, action, nodeid, uname, pcmk_strerror(rc), rc);</a>
<a name="ln2569">        }</a>
<a name="ln2570">    }</a>
<a name="ln2571"> </a>
<a name="ln2572">    if (uname != NULL) {</a>
<a name="ln2573">        name = strdup(uname);</a>
<a name="ln2574"> </a>
<a name="ln2575">    } else if (nodeid &gt; 0) {</a>
<a name="ln2576">        opts |= st_opt_cs_nodeid;</a>
<a name="ln2577">        name = crm_itoa(nodeid);</a>
<a name="ln2578">    }</a>
<a name="ln2579"> </a>
<a name="ln2580">    if (off) {</a>
<a name="ln2581">        action = &quot;off&quot;;</a>
<a name="ln2582">    }</a>
<a name="ln2583"> </a>
<a name="ln2584">    if (rc == pcmk_ok) {</a>
<a name="ln2585">        rc = st-&gt;cmds-&gt;fence(st, opts, name, action, timeout, 0);</a>
<a name="ln2586">        if(rc != pcmk_ok) {</a>
<a name="ln2587">            api_log(LOG_ERR, &quot;Could not kick (%s) node %u/%s : %s (%d)&quot;, action, nodeid, uname, pcmk_strerror(rc), rc);</a>
<a name="ln2588">        } else {</a>
<a name="ln2589">            api_log(LOG_NOTICE, &quot;Node %u/%s kicked: %s &quot;, nodeid, uname, action);</a>
<a name="ln2590">        }</a>
<a name="ln2591">    }</a>
<a name="ln2592"> </a>
<a name="ln2593">    if (st) {</a>
<a name="ln2594">        st-&gt;cmds-&gt;disconnect(st);</a>
<a name="ln2595">        stonith_api_delete(st);</a>
<a name="ln2596">    }</a>
<a name="ln2597"> </a>
<a name="ln2598">    free(name);</a>
<a name="ln2599">    return rc;</a>
<a name="ln2600">}</a>
<a name="ln2601"> </a>
<a name="ln2602">time_t</a>
<a name="ln2603">stonith_api_time(uint32_t nodeid, const char *uname, bool in_progress)</a>
<a name="ln2604">{</a>
<a name="ln2605">    int rc = 0;</a>
<a name="ln2606">    char *name = NULL;</a>
<a name="ln2607"> </a>
<a name="ln2608">    time_t when = 0;</a>
<a name="ln2609">    stonith_t *st = NULL;</a>
<a name="ln2610">    stonith_history_t *history, *hp = NULL;</a>
<a name="ln2611">    enum stonith_call_options opts = st_opt_sync_call;</a>
<a name="ln2612"> </a>
<a name="ln2613">    st = stonith_api_new();</a>
<a name="ln2614">    if (st) {</a>
<a name="ln2615">        rc = st-&gt;cmds-&gt;connect(st, &quot;stonith-api&quot;, NULL);</a>
<a name="ln2616">        if(rc != pcmk_ok) {</a>
<a name="ln2617">            api_log(LOG_NOTICE, &quot;Connection failed: %s (%d)&quot;, pcmk_strerror(rc), rc);</a>
<a name="ln2618">        }</a>
<a name="ln2619">    }</a>
<a name="ln2620"> </a>
<a name="ln2621">    if (uname != NULL) {</a>
<a name="ln2622">        name = strdup(uname);</a>
<a name="ln2623"> </a>
<a name="ln2624">    } else if (nodeid &gt; 0) {</a>
<a name="ln2625">        opts |= st_opt_cs_nodeid;</a>
<a name="ln2626">        name = crm_itoa(nodeid);</a>
<a name="ln2627">    }</a>
<a name="ln2628"> </a>
<a name="ln2629">    if (st &amp;&amp; rc == pcmk_ok) {</a>
<a name="ln2630">        int entries = 0;</a>
<a name="ln2631">        int progress = 0;</a>
<a name="ln2632">        int completed = 0;</a>
<a name="ln2633"> </a>
<a name="ln2634">        rc = st-&gt;cmds-&gt;history(st, opts, name, &amp;history, 120);</a>
<a name="ln2635"> </a>
<a name="ln2636">        for (hp = history; hp; hp = hp-&gt;next) {</a>
<a name="ln2637">            entries++;</a>
<a name="ln2638">            if (in_progress) {</a>
<a name="ln2639">                progress++;</a>
<a name="ln2640">                if (hp-&gt;state != st_done &amp;&amp; hp-&gt;state != st_failed) {</a>
<a name="ln2641">                    when = time(NULL);</a>
<a name="ln2642">                }</a>
<a name="ln2643"> </a>
<a name="ln2644">            } else if (hp-&gt;state == st_done) {</a>
<a name="ln2645">                completed++;</a>
<a name="ln2646">                if (hp-&gt;completed &gt; when) {</a>
<a name="ln2647">                    when = hp-&gt;completed;</a>
<a name="ln2648">                }</a>
<a name="ln2649">            }</a>
<a name="ln2650">        }</a>
<a name="ln2651"> </a>
<a name="ln2652">        if(rc == pcmk_ok) {</a>
<a name="ln2653">            api_log(LOG_INFO, &quot;Found %d entries for %u/%s: %d in progress, %d completed&quot;, entries, nodeid, uname, progress, completed);</a>
<a name="ln2654">        } else {</a>
<a name="ln2655">            api_log(LOG_ERR, &quot;Could not retrieve fence history for %u/%s: %s (%d)&quot;, nodeid, uname, pcmk_strerror(rc), rc);</a>
<a name="ln2656">        }</a>
<a name="ln2657">    }</a>
<a name="ln2658"> </a>
<a name="ln2659">    if (st) {</a>
<a name="ln2660">        st-&gt;cmds-&gt;disconnect(st);</a>
<a name="ln2661">        stonith_api_delete(st);</a>
<a name="ln2662">    }</a>
<a name="ln2663"> </a>
<a name="ln2664">    if(when) {</a>
<a name="ln2665">        api_log(LOG_INFO, &quot;Node %u/%s last kicked at: %ld&quot;, nodeid, uname, (long int)when);</a>
<a name="ln2666">    }</a>
<a name="ln2667">    free(name);</a>
<a name="ln2668">    return when;</a>
<a name="ln2669">}</a>
<a name="ln2670"> </a>
<a name="ln2671">#if HAVE_STONITH_STONITH_H</a>
<a name="ln2672">#  include &lt;pils/plugin.h&gt;</a>
<a name="ln2673"> </a>
<a name="ln2674">const char *i_hate_pils(int rc);</a>
<a name="ln2675"> </a>
<a name="ln2676">const char *</a>
<a name="ln2677">i_hate_pils(int rc)</a>
<a name="ln2678">{</a>
<a name="ln2679">    return PIL_strerror(rc);</a>
<a name="ln2680">}</a>
<a name="ln2681">#endif</a>

</code></pre>
<div class="balloon" rel="360"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V547/" target="_blank">V547</a> Expression 'list == NULL' is always false.</p></div>
<div class="balloon" rel="463"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 463, 462.</p></div>
<div class="balloon" rel="472"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 472, 471.</p></div>
<div class="balloon" rel="689"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'action'. Check lines: 689, 687.</p></div>
<div class="balloon" rel="1566"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'kvp'. Check lines: 1566, 1565.</p></div>
<div class="balloon" rel="1867"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'new_client'. Check lines: 1867, 1866.</p></div>
<div class="balloon" rel="1898"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'new_client'. Check lines: 1898, 1897.</p></div>
<div class="balloon" rel="2015"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'blob'. Check lines: 2015, 2014.</p></div>
<div class="balloon" rel="2094"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V562/" target="_blank">V562</a> It's odd to compare 0 or 1 with a value of 0: (call_id > 0) == (0).</p></div>
<div class="balloon" rel="2154"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'event'. Check lines: 2154, 2147.</p></div>
<div class="balloon" rel="2181"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> Dereferencing of the null pointer 'event' might take place. The potential null pointer is passed into 'event_free' function. Inspect the first argument. Check lines: 2181, 2228, 2147.</p></div>
<div class="balloon" rel="2293"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V547/" target="_blank">V547</a> Expression 'stonith->call_id != 0' is always true.</p></div>
<div class="balloon" rel="2293"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V562/" target="_blank">V562</a> It's odd to compare 0 or 1 with a value of 0: (stonith->call_id != 0) == (0).</p></div>
<div class="balloon" rel="2461"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'new_stonith'. Check lines: 2461, 2459.</p></div>
<div class="balloon" rel="2463"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'private'. Check lines: 2463, 2460.</p></div>
<div class="balloon" rel="2473"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'new_stonith->cmds'. Check lines: 2473, 2470.</p></div>
<div class="balloon" rel="2512"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'p'. Check lines: 2512, 2510.</p></div>
<div class="balloon" rel="2585"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'st'. Check lines: 2585, 2459.</p></div>
<div class="balloon" rel="2585"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V595/" target="_blank">V595</a> The 'st' pointer was utilized before it was verified against nullptr. Check lines: 2585, 2593.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
