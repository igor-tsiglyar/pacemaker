
<html>
<head>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>
<pre><code class="cpp">
<a name="ln1"> </a>
<a name="ln2">// This is an open source non-commercial project. Dear PVS-Studio, please check it.</a>
<a name="ln3"> </a>
<a name="ln4">// PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com</a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (C) 2004 Andrew Beekhof &lt;andrew@beekhof.net&gt;</a>
<a name="ln7"> *</a>
<a name="ln8"> * This library is free software; you can redistribute it and/or</a>
<a name="ln9"> * modify it under the terms of the GNU Lesser General Public</a>
<a name="ln10"> * License as published by the Free Software Foundation; either</a>
<a name="ln11"> * version 2.1 of the License, or (at your option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This library is distributed in the hope that it will be useful,</a>
<a name="ln14"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * Lesser General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU Lesser General Public</a>
<a name="ln19"> * License along with this library; if not, write to the Free Software</a>
<a name="ln20"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</a>
<a name="ln21"> */</a>
<a name="ln22">#include &lt;crm_internal.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;glib.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;crm/crm.h&gt;</a>
<a name="ln27">#include &lt;crm/services.h&gt;</a>
<a name="ln28">#include &lt;crm/msg_xml.h&gt;</a>
<a name="ln29">#include &lt;crm/common/xml.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &lt;crm/common/util.h&gt;</a>
<a name="ln32">#include &lt;crm/pengine/rules.h&gt;</a>
<a name="ln33">#include &lt;crm/pengine/internal.h&gt;</a>
<a name="ln34">#include &lt;unpack.h&gt;</a>
<a name="ln35"> </a>
<a name="ln36">CRM_TRACE_INIT_DATA(pe_status);</a>
<a name="ln37"> </a>
<a name="ln38">#define set_config_flag(data_set, option, flag) do {			\</a>
<a name="ln39">	const char *tmp = pe_pref(data_set-&gt;config_hash, option);	\</a>
<a name="ln40">	if(tmp) {							\</a>
<a name="ln41">	    if(crm_is_true(tmp)) {					\</a>
<a name="ln42">		set_bit(data_set-&gt;flags, flag);			\</a>
<a name="ln43">	    } else {							\</a>
<a name="ln44">		clear_bit(data_set-&gt;flags, flag);		\</a>
<a name="ln45">	    }								\</a>
<a name="ln46">	}								\</a>
<a name="ln47">    } while(0)</a>
<a name="ln48"> </a>
<a name="ln49">gboolean unpack_rsc_op(resource_t * rsc, node_t * node, xmlNode * xml_op, xmlNode ** last_failure,</a>
<a name="ln50">                       enum action_fail_response *failed, pe_working_set_t * data_set);</a>
<a name="ln51">static gboolean determine_remote_online_status(pe_working_set_t * data_set, node_t * this_node);</a>
<a name="ln52"> </a>
<a name="ln53">static gboolean</a>
<a name="ln54">is_dangling_container_remote_node(node_t *node)</a>
<a name="ln55">{</a>
<a name="ln56">    /* we are looking for a remote-node that was supposed to be mapped to a</a>
<a name="ln57">     * container resource, but all traces of that container have disappeared </a>
<a name="ln58">     * from both the config and the status section. */</a>
<a name="ln59">    if (is_remote_node(node) &amp;&amp;</a>
<a name="ln60">        node-&gt;details-&gt;remote_rsc &amp;&amp;</a>
<a name="ln61">        node-&gt;details-&gt;remote_rsc-&gt;container == NULL &amp;&amp;</a>
<a name="ln62">        is_set(node-&gt;details-&gt;remote_rsc-&gt;flags, pe_rsc_orphan_container_filler)) {</a>
<a name="ln63">        return TRUE;</a>
<a name="ln64">    }</a>
<a name="ln65"> </a>
<a name="ln66">    return FALSE;</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">void</a>
<a name="ln70">pe_fence_node(pe_working_set_t * data_set, node_t * node, const char *reason)</a>
<a name="ln71">{</a>
<a name="ln72">    CRM_CHECK(node, return);</a>
<a name="ln73"> </a>
<a name="ln74">    /* A guest node is fenced by marking its container as failed */</a>
<a name="ln75">    if (is_container_remote_node(node)) {</a>
<a name="ln76">        resource_t *rsc = node-&gt;details-&gt;remote_rsc-&gt;container;</a>
<a name="ln77"> </a>
<a name="ln78">        if (is_set(rsc-&gt;flags, pe_rsc_failed) == FALSE) {</a>
<a name="ln79">            if (!is_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln80">                crm_notice(&quot;Not fencing guest node %s because the container is &quot;</a>
<a name="ln81">                           &quot;unmanaged, otherwise we would do so recovering %s &quot;</a>
<a name="ln82">                           &quot;%s&quot;, node-&gt;details-&gt;uname, rsc-&gt;id, reason);</a>
<a name="ln83">            } else {</a>
<a name="ln84">                crm_warn(&quot;Guest node %s will be fenced (by recovering %s) %s&quot;,</a>
<a name="ln85">                    node-&gt;details-&gt;uname, rsc-&gt;id, reason);</a>
<a name="ln86"> </a>
<a name="ln87">                /* We don't mark the node as unclean because that would prevent the</a>
<a name="ln88">                 * node from running resources. We want to allow it to run resources</a>
<a name="ln89">                 * in this transition if the recovery succeeds.</a>
<a name="ln90">                 */</a>
<a name="ln91">                node-&gt;details-&gt;remote_requires_reset = TRUE;</a>
<a name="ln92">                set_bit(rsc-&gt;flags, pe_rsc_failed);</a>
<a name="ln93">            }</a>
<a name="ln94">        }</a>
<a name="ln95">    } else if (is_dangling_container_remote_node(node)) {</a>
<a name="ln96">        crm_info(&quot;Cleaning up dangling connection resource for guest node %s %s&quot;</a>
<a name="ln97">                 &quot; (fencing is already done, guest resource no longer exists)&quot;,</a>
<a name="ln98">                 node-&gt;details-&gt;uname, reason);</a>
<a name="ln99">        set_bit(node-&gt;details-&gt;remote_rsc-&gt;flags, pe_rsc_failed);</a>
<a name="ln100"> </a>
<a name="ln101">    } else if (is_baremetal_remote_node(node)) {</a>
<a name="ln102">        resource_t *rsc = node-&gt;details-&gt;remote_rsc;</a>
<a name="ln103"> </a>
<a name="ln104">        if (rsc &amp;&amp; (!is_set(rsc-&gt;flags, pe_rsc_managed))) {</a>
<a name="ln105">            crm_notice(&quot;Not fencing node %s because connection is unmanaged, &quot;</a>
<a name="ln106">                       &quot;otherwise would %s&quot;, node-&gt;details-&gt;uname, reason);</a>
<a name="ln107">        } else {</a>
<a name="ln108">            if (pe_can_fence(data_set, node)) {</a>
<a name="ln109">                crm_warn(&quot;Node %s will be fenced %s&quot;, node-&gt;details-&gt;uname, reason);</a>
<a name="ln110">            } else {</a>
<a name="ln111">                crm_warn(&quot;Node %s is unclean %s&quot;, node-&gt;details-&gt;uname, reason);</a>
<a name="ln112">            }</a>
<a name="ln113">            node-&gt;details-&gt;remote_requires_reset = TRUE;</a>
<a name="ln114">        }</a>
<a name="ln115">        node-&gt;details-&gt;unclean = TRUE;</a>
<a name="ln116">    } else if (node-&gt;details-&gt;unclean == FALSE) {</a>
<a name="ln117">        if (pe_can_fence(data_set, node)) {</a>
<a name="ln118">            crm_warn(&quot;Node %s will be fenced %s&quot;, node-&gt;details-&gt;uname, reason);</a>
<a name="ln119">        } else {</a>
<a name="ln120">            crm_warn(&quot;Node %s is unclean %s&quot;, node-&gt;details-&gt;uname, reason);</a>
<a name="ln121">        }</a>
<a name="ln122">        node-&gt;details-&gt;unclean = TRUE;</a>
<a name="ln123">    } else {</a>
<a name="ln124">        crm_trace(&quot;Huh? %s %s&quot;, node-&gt;details-&gt;uname, reason);</a>
<a name="ln125">    }</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">gboolean</a>
<a name="ln129">unpack_config(xmlNode * config, pe_working_set_t * data_set)</a>
<a name="ln130">{</a>
<a name="ln131">    const char *value = NULL;</a>
<a name="ln132">    GHashTable *config_hash =</a>
<a name="ln133">        g_hash_table_new_full(crm_str_hash, g_str_equal, g_hash_destroy_str, g_hash_destroy_str);</a>
<a name="ln134"> </a>
<a name="ln135">    xmlXPathObjectPtr xpathObj = NULL;</a>
<a name="ln136"> </a>
<a name="ln137">    if(is_not_set(data_set-&gt;flags, pe_flag_enable_unfencing)) {</a>
<a name="ln138">        xpathObj = xpath_search(data_set-&gt;input, &quot;//nvpair[@name='provides' and @value='unfencing']&quot;);</a>
<a name="ln139">        if(xpathObj &amp;&amp; numXpathResults(xpathObj) &gt; 0) {</a>
<a name="ln140">            set_bit(data_set-&gt;flags, pe_flag_enable_unfencing);</a>
<a name="ln141">        }</a>
<a name="ln142">        freeXpathObject(xpathObj);</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">    if(is_not_set(data_set-&gt;flags, pe_flag_enable_unfencing)) {</a>
<a name="ln146">        xpathObj = xpath_search(data_set-&gt;input, &quot;//nvpair[@name='requires' and @value='unfencing']&quot;);</a>
<a name="ln147">        if(xpathObj &amp;&amp; numXpathResults(xpathObj) &gt; 0) {</a>
<a name="ln148">            set_bit(data_set-&gt;flags, pe_flag_enable_unfencing);</a>
<a name="ln149">        }</a>
<a name="ln150">        freeXpathObject(xpathObj);</a>
<a name="ln151">    }</a>
<a name="ln152"> </a>
<a name="ln153"> </a>
<a name="ln154">#ifdef REDHAT_COMPAT_6</a>
<a name="ln155">    if(is_not_set(data_set-&gt;flags, pe_flag_enable_unfencing)) {</a>
<a name="ln156">        xpathObj = xpath_search(data_set-&gt;input, &quot;//primitive[@type='fence_scsi']&quot;);</a>
<a name="ln157">        if(xpathObj &amp;&amp; numXpathResults(xpathObj) &gt; 0) {</a>
<a name="ln158">            set_bit(data_set-&gt;flags, pe_flag_enable_unfencing);</a>
<a name="ln159">        }</a>
<a name="ln160">        freeXpathObject(xpathObj);</a>
<a name="ln161">    }</a>
<a name="ln162">#endif</a>
<a name="ln163"> </a>
<a name="ln164">    data_set-&gt;config_hash = config_hash;</a>
<a name="ln165"> </a>
<a name="ln166">    unpack_instance_attributes(data_set-&gt;input, config, XML_CIB_TAG_PROPSET, NULL, config_hash,</a>
<a name="ln167">                               CIB_OPTIONS_FIRST, FALSE, data_set-&gt;now);</a>
<a name="ln168"> </a>
<a name="ln169">    verify_pe_options(data_set-&gt;config_hash);</a>
<a name="ln170"> </a>
<a name="ln171">    set_config_flag(data_set, &quot;enable-startup-probes&quot;, pe_flag_startup_probes);</a>
<a name="ln172">    if(is_not_set(data_set-&gt;flags, pe_flag_startup_probes)) {</a>
<a name="ln173">        crm_info(&quot;Startup probes: disabled (dangerous)&quot;);</a>
<a name="ln174">    }</a>
<a name="ln175"> </a>
<a name="ln176">    value = pe_pref(data_set-&gt;config_hash, XML_ATTR_HAVE_WATCHDOG);</a>
<a name="ln177">    if (value &amp;&amp; crm_is_true(value)) {</a>
<a name="ln178">        crm_notice(&quot;Watchdog will be used via SBD if fencing is required&quot;);</a>
<a name="ln179">        set_bit(data_set-&gt;flags, pe_flag_have_stonith_resource);</a>
<a name="ln180">    }</a>
<a name="ln181"> </a>
<a name="ln182">    value = pe_pref(data_set-&gt;config_hash, &quot;stonith-timeout&quot;);</a>
<a name="ln183">    data_set-&gt;stonith_timeout = crm_get_msec(value);</a>
<a name="ln184">    crm_debug(&quot;STONITH timeout: %d&quot;, data_set-&gt;stonith_timeout);</a>
<a name="ln185"> </a>
<a name="ln186">    set_config_flag(data_set, &quot;stonith-enabled&quot;, pe_flag_stonith_enabled);</a>
<a name="ln187">    crm_debug(&quot;STONITH of failed nodes is %s&quot;,</a>
<a name="ln188">              is_set(data_set-&gt;flags, pe_flag_stonith_enabled) ? &quot;enabled&quot; : &quot;disabled&quot;);</a>
<a name="ln189"> </a>
<a name="ln190">    data_set-&gt;stonith_action = pe_pref(data_set-&gt;config_hash, &quot;stonith-action&quot;);</a>
<a name="ln191">    crm_trace(&quot;STONITH will %s nodes&quot;, data_set-&gt;stonith_action);</a>
<a name="ln192"> </a>
<a name="ln193">    set_config_flag(data_set, &quot;concurrent-fencing&quot;, pe_flag_concurrent_fencing);</a>
<a name="ln194">    crm_debug(&quot;Concurrent fencing is %s&quot;,</a>
<a name="ln195">              is_set(data_set-&gt;flags, pe_flag_concurrent_fencing) ? &quot;enabled&quot; : &quot;disabled&quot;);</a>
<a name="ln196"> </a>
<a name="ln197">    set_config_flag(data_set, &quot;stop-all-resources&quot;, pe_flag_stop_everything);</a>
<a name="ln198">    crm_debug(&quot;Stop all active resources: %s&quot;,</a>
<a name="ln199">              is_set(data_set-&gt;flags, pe_flag_stop_everything) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln200"> </a>
<a name="ln201">    set_config_flag(data_set, &quot;symmetric-cluster&quot;, pe_flag_symmetric_cluster);</a>
<a name="ln202">    if (is_set(data_set-&gt;flags, pe_flag_symmetric_cluster)) {</a>
<a name="ln203">        crm_debug(&quot;Cluster is symmetric&quot; &quot; - resources can run anywhere by default&quot;);</a>
<a name="ln204">    }</a>
<a name="ln205"> </a>
<a name="ln206">    value = pe_pref(data_set-&gt;config_hash, &quot;default-resource-stickiness&quot;);</a>
<a name="ln207">    data_set-&gt;default_resource_stickiness = char2score(value);</a>
<a name="ln208">    crm_debug(&quot;Default stickiness: %d&quot;, data_set-&gt;default_resource_stickiness);</a>
<a name="ln209"> </a>
<a name="ln210">    value = pe_pref(data_set-&gt;config_hash, &quot;no-quorum-policy&quot;);</a>
<a name="ln211"> </a>
<a name="ln212">    if (safe_str_eq(value, &quot;ignore&quot;)) {</a>
<a name="ln213">        data_set-&gt;no_quorum_policy = no_quorum_ignore;</a>
<a name="ln214"> </a>
<a name="ln215">    } else if (safe_str_eq(value, &quot;freeze&quot;)) {</a>
<a name="ln216">        data_set-&gt;no_quorum_policy = no_quorum_freeze;</a>
<a name="ln217"> </a>
<a name="ln218">    } else if (safe_str_eq(value, &quot;suicide&quot;)) {</a>
<a name="ln219">        gboolean do_panic = FALSE;</a>
<a name="ln220"> </a>
<a name="ln221">        crm_element_value_int(data_set-&gt;input, XML_ATTR_QUORUM_PANIC, &amp;do_panic);</a>
<a name="ln222"> </a>
<a name="ln223">        if (is_set(data_set-&gt;flags, pe_flag_stonith_enabled) == FALSE) {</a>
<a name="ln224">            crm_config_err</a>
<a name="ln225">                (&quot;Setting no-quorum-policy=suicide makes no sense if stonith-enabled=false&quot;);</a>
<a name="ln226">        }</a>
<a name="ln227"> </a>
<a name="ln228">        if (do_panic &amp;&amp; is_set(data_set-&gt;flags, pe_flag_stonith_enabled)) {</a>
<a name="ln229">            data_set-&gt;no_quorum_policy = no_quorum_suicide;</a>
<a name="ln230"> </a>
<a name="ln231">        } else if (is_set(data_set-&gt;flags, pe_flag_have_quorum) == FALSE &amp;&amp; do_panic == FALSE) {</a>
<a name="ln232">            crm_notice(&quot;Resetting no-quorum-policy to 'stop': The cluster has never had quorum&quot;);</a>
<a name="ln233">            data_set-&gt;no_quorum_policy = no_quorum_stop;</a>
<a name="ln234">        }</a>
<a name="ln235"> </a>
<a name="ln236">    } else {</a>
<a name="ln237">        data_set-&gt;no_quorum_policy = no_quorum_stop;</a>
<a name="ln238">    }</a>
<a name="ln239"> </a>
<a name="ln240">    switch (data_set-&gt;no_quorum_policy) {</a>
<a name="ln241">        case no_quorum_freeze:</a>
<a name="ln242">            crm_debug(&quot;On loss of CCM Quorum: Freeze resources&quot;);</a>
<a name="ln243">            break;</a>
<a name="ln244">        case no_quorum_stop:</a>
<a name="ln245">            crm_debug(&quot;On loss of CCM Quorum: Stop ALL resources&quot;);</a>
<a name="ln246">            break;</a>
<a name="ln247">        case no_quorum_suicide:</a>
<a name="ln248">            crm_notice(&quot;On loss of CCM Quorum: Fence all remaining nodes&quot;);</a>
<a name="ln249">            break;</a>
<a name="ln250">        case no_quorum_ignore:</a>
<a name="ln251">            crm_notice(&quot;On loss of CCM Quorum: Ignore&quot;);</a>
<a name="ln252">            break;</a>
<a name="ln253">    }</a>
<a name="ln254"> </a>
<a name="ln255">    set_config_flag(data_set, &quot;stop-orphan-resources&quot;, pe_flag_stop_rsc_orphans);</a>
<a name="ln256">    crm_trace(&quot;Orphan resources are %s&quot;,</a>
<a name="ln257">              is_set(data_set-&gt;flags, pe_flag_stop_rsc_orphans) ? &quot;stopped&quot; : &quot;ignored&quot;);</a>
<a name="ln258"> </a>
<a name="ln259">    set_config_flag(data_set, &quot;stop-orphan-actions&quot;, pe_flag_stop_action_orphans);</a>
<a name="ln260">    crm_trace(&quot;Orphan resource actions are %s&quot;,</a>
<a name="ln261">              is_set(data_set-&gt;flags, pe_flag_stop_action_orphans) ? &quot;stopped&quot; : &quot;ignored&quot;);</a>
<a name="ln262"> </a>
<a name="ln263">    set_config_flag(data_set, &quot;remove-after-stop&quot;, pe_flag_remove_after_stop);</a>
<a name="ln264">    crm_trace(&quot;Stopped resources are removed from the status section: %s&quot;,</a>
<a name="ln265">              is_set(data_set-&gt;flags, pe_flag_remove_after_stop) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln266"> </a>
<a name="ln267">    set_config_flag(data_set, &quot;maintenance-mode&quot;, pe_flag_maintenance_mode);</a>
<a name="ln268">    crm_trace(&quot;Maintenance mode: %s&quot;,</a>
<a name="ln269">              is_set(data_set-&gt;flags, pe_flag_maintenance_mode) ? &quot;true&quot; : &quot;false&quot;);</a>
<a name="ln270"> </a>
<a name="ln271">    if (is_set(data_set-&gt;flags, pe_flag_maintenance_mode)) {</a>
<a name="ln272">        clear_bit(data_set-&gt;flags, pe_flag_is_managed_default);</a>
<a name="ln273">    } else {</a>
<a name="ln274">        set_config_flag(data_set, &quot;is-managed-default&quot;, pe_flag_is_managed_default);</a>
<a name="ln275">    }</a>
<a name="ln276">    crm_trace(&quot;By default resources are %smanaged&quot;,</a>
<a name="ln277">              is_set(data_set-&gt;flags, pe_flag_is_managed_default) ? &quot;&quot; : &quot;not &quot;);</a>
<a name="ln278"> </a>
<a name="ln279">    set_config_flag(data_set, &quot;start-failure-is-fatal&quot;, pe_flag_start_failure_fatal);</a>
<a name="ln280">    crm_trace(&quot;Start failures are %s&quot;,</a>
<a name="ln281">              is_set(data_set-&gt;flags,</a>
<a name="ln282">                     pe_flag_start_failure_fatal) ? &quot;always fatal&quot; : &quot;handled by failcount&quot;);</a>
<a name="ln283"> </a>
<a name="ln284">    node_score_red = char2score(pe_pref(data_set-&gt;config_hash, &quot;node-health-red&quot;));</a>
<a name="ln285">    node_score_green = char2score(pe_pref(data_set-&gt;config_hash, &quot;node-health-green&quot;));</a>
<a name="ln286">    node_score_yellow = char2score(pe_pref(data_set-&gt;config_hash, &quot;node-health-yellow&quot;));</a>
<a name="ln287"> </a>
<a name="ln288">    crm_debug(&quot;Node scores: 'red' = %s, 'yellow' = %s, 'green' = %s&quot;,</a>
<a name="ln289">             pe_pref(data_set-&gt;config_hash, &quot;node-health-red&quot;),</a>
<a name="ln290">             pe_pref(data_set-&gt;config_hash, &quot;node-health-yellow&quot;),</a>
<a name="ln291">             pe_pref(data_set-&gt;config_hash, &quot;node-health-green&quot;));</a>
<a name="ln292"> </a>
<a name="ln293">    data_set-&gt;placement_strategy = pe_pref(data_set-&gt;config_hash, &quot;placement-strategy&quot;);</a>
<a name="ln294">    crm_trace(&quot;Placement strategy: %s&quot;, data_set-&gt;placement_strategy);</a>
<a name="ln295"> </a>
<a name="ln296">    return TRUE;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">static void</a>
<a name="ln300">destroy_digest_cache(gpointer ptr)</a>
<a name="ln301">{</a>
<a name="ln302">    op_digest_cache_t *data = ptr;</a>
<a name="ln303"> </a>
<a name="ln304">    free_xml(data-&gt;params_all);</a>
<a name="ln305">    free_xml(data-&gt;params_secure);</a>
<a name="ln306">    free_xml(data-&gt;params_restart);</a>
<a name="ln307"> </a>
<a name="ln308">    free(data-&gt;digest_all_calc);</a>
<a name="ln309">    free(data-&gt;digest_restart_calc);</a>
<a name="ln310">    free(data-&gt;digest_secure_calc);</a>
<a name="ln311"> </a>
<a name="ln312">    free(data);</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">node_t *</a>
<a name="ln316">pe_create_node(const char *id, const char *uname, const char *type,</a>
<a name="ln317">               const char *score, pe_working_set_t * data_set)</a>
<a name="ln318">{</a>
<a name="ln319">    node_t *new_node = NULL;</a>
<a name="ln320"> </a>
<a name="ln321">    if (pe_find_node(data_set-&gt;nodes, uname) != NULL) {</a>
<a name="ln322">        crm_config_warn(&quot;Detected multiple node entries with uname=%s&quot;</a>
<a name="ln323">                        &quot; - this is rarely intended&quot;, uname);</a>
<a name="ln324">    }</a>
<a name="ln325"> </a>
<a name="ln326">    new_node = calloc(1, sizeof(node_t));</a>
<a name="ln327">    if (new_node == NULL) {</a>
<a name="ln328">        return NULL;</a>
<a name="ln329">    }</a>
<a name="ln330"> </a>
<a name="ln331">    new_node-&gt;weight = char2score(score);</a>
<a name="ln332">    new_node-&gt;fixed = FALSE;</a>
<a name="ln333">    new_node-&gt;details = calloc(1, sizeof(struct node_shared_s));</a>
<a name="ln334"> </a>
<a name="ln335">    if (new_node-&gt;details == NULL) {</a>
<a name="ln336">        free(new_node);</a>
<a name="ln337">        return NULL;</a>
<a name="ln338">    }</a>
<a name="ln339"> </a>
<a name="ln340">    crm_trace(&quot;Creating node for entry %s/%s&quot;, uname, id);</a>
<a name="ln341">    new_node-&gt;details-&gt;id = id;</a>
<a name="ln342">    new_node-&gt;details-&gt;uname = uname;</a>
<a name="ln343">    new_node-&gt;details-&gt;online = FALSE;</a>
<a name="ln344">    new_node-&gt;details-&gt;shutdown = FALSE;</a>
<a name="ln345">    new_node-&gt;details-&gt;rsc_discovery_enabled = TRUE;</a>
<a name="ln346">    new_node-&gt;details-&gt;running_rsc = NULL;</a>
<a name="ln347">    new_node-&gt;details-&gt;type = node_ping;</a>
<a name="ln348"> </a>
<a name="ln349">    if (safe_str_eq(type, &quot;remote&quot;)) {</a>
<a name="ln350">        new_node-&gt;details-&gt;type = node_remote;</a>
<a name="ln351">        set_bit(data_set-&gt;flags, pe_flag_have_remote_nodes);</a>
<a name="ln352">    } else if (type == NULL || safe_str_eq(type, &quot;member&quot;)</a>
<a name="ln353">        || safe_str_eq(type, NORMALNODE)) {</a>
<a name="ln354">        new_node-&gt;details-&gt;type = node_member;</a>
<a name="ln355">    }</a>
<a name="ln356"> </a>
<a name="ln357">    new_node-&gt;details-&gt;attrs = g_hash_table_new_full(crm_str_hash, g_str_equal,</a>
<a name="ln358">                                                     g_hash_destroy_str,</a>
<a name="ln359">                                                     g_hash_destroy_str);</a>
<a name="ln360"> </a>
<a name="ln361">    if (is_remote_node(new_node)) {</a>
<a name="ln362">        g_hash_table_insert(new_node-&gt;details-&gt;attrs, strdup(&quot;#kind&quot;), strdup(&quot;remote&quot;));</a>
<a name="ln363">    } else {</a>
<a name="ln364">        g_hash_table_insert(new_node-&gt;details-&gt;attrs, strdup(&quot;#kind&quot;), strdup(&quot;cluster&quot;));</a>
<a name="ln365">    }</a>
<a name="ln366"> </a>
<a name="ln367">    new_node-&gt;details-&gt;utilization =</a>
<a name="ln368">        g_hash_table_new_full(crm_str_hash, g_str_equal, g_hash_destroy_str,</a>
<a name="ln369">                              g_hash_destroy_str);</a>
<a name="ln370"> </a>
<a name="ln371">    new_node-&gt;details-&gt;digest_cache =</a>
<a name="ln372">        g_hash_table_new_full(crm_str_hash, g_str_equal, g_hash_destroy_str,</a>
<a name="ln373">                              destroy_digest_cache);</a>
<a name="ln374"> </a>
<a name="ln375">    data_set-&gt;nodes = g_list_insert_sorted(data_set-&gt;nodes, new_node, sort_node_uname);</a>
<a name="ln376">    return new_node;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">bool</a>
<a name="ln380">remote_id_conflict(const char *remote_name, pe_working_set_t *data) </a>
<a name="ln381">{</a>
<a name="ln382">    bool match = FALSE;</a>
<a name="ln383">#if 1</a>
<a name="ln384">    pe_find_resource(data-&gt;resources, remote_name);</a>
<a name="ln385">#else</a>
<a name="ln386">    if (data-&gt;name_check == NULL) {</a>
<a name="ln387">        data-&gt;name_check = g_hash_table_new(crm_str_hash, g_str_equal);</a>
<a name="ln388">        for (xml_rsc = __xml_first_child(parent); xml_rsc != NULL; xml_rsc = __xml_next_element(xml_rsc)) {</a>
<a name="ln389">            const char *id = ID(xml_rsc);</a>
<a name="ln390"> </a>
<a name="ln391">            /* avoiding heap allocation here because we know the duration of this hashtable allows us to */</a>
<a name="ln392">            g_hash_table_insert(data-&gt;name_check, (char *) id, (char *) id);</a>
<a name="ln393">        }</a>
<a name="ln394">    }</a>
<a name="ln395">    if (g_hash_table_lookup(data-&gt;name_check, remote_name)) {</a>
<a name="ln396">        match = TRUE;</a>
<a name="ln397">    }</a>
<a name="ln398">#endif</a>
<a name="ln399">    if (match) {</a>
<a name="ln400">        crm_err(&quot;Invalid remote-node name, a resource called '%s' already exists.&quot;, remote_name);</a>
<a name="ln401">        return NULL;</a>
<a name="ln402">    }</a>
<a name="ln403"> </a>
<a name="ln404">    return match;</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407"> </a>
<a name="ln408">static const char *</a>
<a name="ln409">expand_remote_rsc_meta(xmlNode *xml_obj, xmlNode *parent, pe_working_set_t *data)</a>
<a name="ln410">{</a>
<a name="ln411">    xmlNode *xml_rsc = NULL;</a>
<a name="ln412">    xmlNode *xml_tmp = NULL;</a>
<a name="ln413">    xmlNode *attr_set = NULL;</a>
<a name="ln414">    xmlNode *attr = NULL;</a>
<a name="ln415"> </a>
<a name="ln416">    const char *container_id = ID(xml_obj);</a>
<a name="ln417">    const char *remote_name = NULL;</a>
<a name="ln418">    const char *remote_server = NULL;</a>
<a name="ln419">    const char *remote_port = NULL;</a>
<a name="ln420">    const char *connect_timeout = &quot;60s&quot;;</a>
<a name="ln421">    const char *remote_allow_migrate=NULL;</a>
<a name="ln422">    const char *container_managed = NULL;</a>
<a name="ln423"> </a>
<a name="ln424">    for (attr_set = __xml_first_child(xml_obj); attr_set != NULL; attr_set = __xml_next_element(attr_set)) {</a>
<a name="ln425">        if (safe_str_neq((const char *)attr_set-&gt;name, XML_TAG_META_SETS)) {</a>
<a name="ln426">            continue;</a>
<a name="ln427">        }</a>
<a name="ln428"> </a>
<a name="ln429">        for (attr = __xml_first_child(attr_set); attr != NULL; attr = __xml_next_element(attr)) {</a>
<a name="ln430">            const char *value = crm_element_value(attr, XML_NVPAIR_ATTR_VALUE);</a>
<a name="ln431">            const char *name = crm_element_value(attr, XML_NVPAIR_ATTR_NAME);</a>
<a name="ln432"> </a>
<a name="ln433">            if (safe_str_eq(name, XML_RSC_ATTR_REMOTE_NODE)) {</a>
<a name="ln434">                remote_name = value;</a>
<a name="ln435">            } else if (safe_str_eq(name, &quot;remote-addr&quot;)) {</a>
<a name="ln436">                remote_server = value;</a>
<a name="ln437">            } else if (safe_str_eq(name, &quot;remote-port&quot;)) {</a>
<a name="ln438">                remote_port = value;</a>
<a name="ln439">            } else if (safe_str_eq(name, &quot;remote-connect-timeout&quot;)) {</a>
<a name="ln440">                connect_timeout = value;</a>
<a name="ln441">            } else if (safe_str_eq(name, &quot;remote-allow-migrate&quot;)) {</a>
<a name="ln442">                remote_allow_migrate=value;</a>
<a name="ln443">            } else if (safe_str_eq(name, XML_RSC_ATTR_MANAGED)) {</a>
<a name="ln444">                container_managed = value;</a>
<a name="ln445">            }</a>
<a name="ln446">        }</a>
<a name="ln447">    }</a>
<a name="ln448"> </a>
<a name="ln449">    if (remote_name == NULL) {</a>
<a name="ln450">        return NULL;</a>
<a name="ln451">    }</a>
<a name="ln452"> </a>
<a name="ln453">    if (remote_id_conflict(remote_name, data)) {</a>
<a name="ln454">        return NULL;</a>
<a name="ln455">    }</a>
<a name="ln456"> </a>
<a name="ln457">    xml_rsc = create_xml_node(parent, XML_CIB_TAG_RESOURCE);</a>
<a name="ln458"> </a>
<a name="ln459">    crm_xml_add(xml_rsc, XML_ATTR_ID, remote_name);</a>
<a name="ln460">    crm_xml_add(xml_rsc, XML_AGENT_ATTR_CLASS, PCMK_RESOURCE_CLASS_OCF);</a>
<a name="ln461">    crm_xml_add(xml_rsc, XML_AGENT_ATTR_PROVIDER, &quot;pacemaker&quot;);</a>
<a name="ln462">    crm_xml_add(xml_rsc, XML_ATTR_TYPE, &quot;remote&quot;);</a>
<a name="ln463"> </a>
<a name="ln464">    xml_tmp = create_xml_node(xml_rsc, XML_TAG_META_SETS);</a>
<a name="ln465">    crm_xml_set_id(xml_tmp, &quot;%s_%s&quot;, remote_name, XML_TAG_META_SETS);</a>
<a name="ln466"> </a>
<a name="ln467">    attr = create_xml_node(xml_tmp, XML_CIB_TAG_NVPAIR);</a>
<a name="ln468">    crm_xml_set_id(attr, &quot;%s_%s&quot;, remote_name, &quot;meta-attributes-container&quot;);</a>
<a name="ln469">    crm_xml_add(attr, XML_NVPAIR_ATTR_NAME, XML_RSC_ATTR_CONTAINER);</a>
<a name="ln470">    crm_xml_add(attr, XML_NVPAIR_ATTR_VALUE, container_id);</a>
<a name="ln471"> </a>
<a name="ln472">    attr = create_xml_node(xml_tmp, XML_CIB_TAG_NVPAIR);</a>
<a name="ln473">    crm_xml_set_id(attr, &quot;%s_%s&quot;, remote_name, &quot;meta-attributes-internal&quot;);</a>
<a name="ln474">    crm_xml_add(attr, XML_NVPAIR_ATTR_NAME, XML_RSC_ATTR_INTERNAL_RSC);</a>
<a name="ln475">    crm_xml_add(attr, XML_NVPAIR_ATTR_VALUE, &quot;true&quot;);</a>
<a name="ln476"> </a>
<a name="ln477">    if (remote_allow_migrate) {</a>
<a name="ln478">        attr = create_xml_node(xml_tmp, XML_CIB_TAG_NVPAIR);</a>
<a name="ln479">        crm_xml_set_id(attr, &quot;%s_%s&quot;, remote_name, &quot;meta-attributes-migrate&quot;);</a>
<a name="ln480">        crm_xml_add(attr, XML_NVPAIR_ATTR_NAME, XML_OP_ATTR_ALLOW_MIGRATE);</a>
<a name="ln481">        crm_xml_add(attr, XML_NVPAIR_ATTR_VALUE, remote_allow_migrate);</a>
<a name="ln482">    }</a>
<a name="ln483"> </a>
<a name="ln484">    if (container_managed) {</a>
<a name="ln485">        attr = create_xml_node(xml_tmp, XML_CIB_TAG_NVPAIR);</a>
<a name="ln486">        crm_xml_set_id(attr, &quot;%s_%s&quot;, remote_name, &quot;meta-attributes-managed&quot;);</a>
<a name="ln487">        crm_xml_add(attr, XML_NVPAIR_ATTR_NAME, XML_RSC_ATTR_MANAGED);</a>
<a name="ln488">        crm_xml_add(attr, XML_NVPAIR_ATTR_VALUE, container_managed);</a>
<a name="ln489">    }</a>
<a name="ln490"> </a>
<a name="ln491">    xml_tmp = create_xml_node(xml_rsc, &quot;operations&quot;);</a>
<a name="ln492">    attr = create_xml_node(xml_tmp, XML_ATTR_OP);</a>
<a name="ln493">    crm_xml_set_id(attr, &quot;%s_%s&quot;, remote_name, &quot;monitor-interval-30s&quot;);</a>
<a name="ln494">    crm_xml_add(attr, XML_ATTR_TIMEOUT, &quot;30s&quot;);</a>
<a name="ln495">    crm_xml_add(attr, XML_LRM_ATTR_INTERVAL, &quot;30s&quot;);</a>
<a name="ln496">    crm_xml_add(attr, XML_NVPAIR_ATTR_NAME, &quot;monitor&quot;);</a>
<a name="ln497"> </a>
<a name="ln498">    if (connect_timeout) {</a>
<a name="ln499">        attr = create_xml_node(xml_tmp, XML_ATTR_OP);</a>
<a name="ln500">        crm_xml_set_id(attr, &quot;%s_%s&quot;, remote_name, &quot;start-interval-0&quot;);</a>
<a name="ln501">        crm_xml_add(attr, XML_ATTR_TIMEOUT, connect_timeout);</a>
<a name="ln502">        crm_xml_add(attr, XML_LRM_ATTR_INTERVAL, &quot;0&quot;);</a>
<a name="ln503">        crm_xml_add(attr, XML_NVPAIR_ATTR_NAME, &quot;start&quot;);</a>
<a name="ln504">    }</a>
<a name="ln505"> </a>
<a name="ln506">    if (remote_port || remote_server) {</a>
<a name="ln507">        xml_tmp = create_xml_node(xml_rsc, XML_TAG_ATTR_SETS);</a>
<a name="ln508">        crm_xml_set_id(xml_tmp, &quot;%s_%s&quot;, remote_name, XML_TAG_ATTR_SETS);</a>
<a name="ln509"> </a>
<a name="ln510">        if (remote_server) {</a>
<a name="ln511">            attr = create_xml_node(xml_tmp, XML_CIB_TAG_NVPAIR);</a>
<a name="ln512">            crm_xml_set_id(attr, &quot;%s_%s&quot;, remote_name, &quot;instance-attributes-addr&quot;);</a>
<a name="ln513">            crm_xml_add(attr, XML_NVPAIR_ATTR_NAME, &quot;addr&quot;);</a>
<a name="ln514">            crm_xml_add(attr, XML_NVPAIR_ATTR_VALUE, remote_server);</a>
<a name="ln515">        }</a>
<a name="ln516">        if (remote_port) {</a>
<a name="ln517">            attr = create_xml_node(xml_tmp, XML_CIB_TAG_NVPAIR);</a>
<a name="ln518">            crm_xml_set_id(attr, &quot;%s_%s&quot;, remote_name, &quot;instance-attributes-port&quot;);</a>
<a name="ln519">            crm_xml_add(attr, XML_NVPAIR_ATTR_NAME, &quot;port&quot;);</a>
<a name="ln520">            crm_xml_add(attr, XML_NVPAIR_ATTR_VALUE, remote_port);</a>
<a name="ln521">        }</a>
<a name="ln522">    }</a>
<a name="ln523"> </a>
<a name="ln524">    return remote_name;</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">static void</a>
<a name="ln528">handle_startup_fencing(pe_working_set_t *data_set, node_t *new_node)</a>
<a name="ln529">{</a>
<a name="ln530">    static const char *blind_faith = NULL;</a>
<a name="ln531">    static gboolean unseen_are_unclean = TRUE;</a>
<a name="ln532">    static gboolean need_warning = TRUE;</a>
<a name="ln533"> </a>
<a name="ln534">    if ((new_node-&gt;details-&gt;type == node_remote) &amp;&amp; (new_node-&gt;details-&gt;remote_rsc == NULL)) {</a>
<a name="ln535">        /* Ignore fencing for remote nodes that don't have a connection resource</a>
<a name="ln536">         * associated with them. This happens when remote node entries get left</a>
<a name="ln537">         * in the nodes section after the connection resource is removed.</a>
<a name="ln538">         */</a>
<a name="ln539">        return;</a>
<a name="ln540">    }</a>
<a name="ln541"> </a>
<a name="ln542">    blind_faith = pe_pref(data_set-&gt;config_hash, &quot;startup-fencing&quot;);</a>
<a name="ln543"> </a>
<a name="ln544">    if (crm_is_true(blind_faith) == FALSE) {</a>
<a name="ln545">        unseen_are_unclean = FALSE;</a>
<a name="ln546">        if (need_warning) {</a>
<a name="ln547">            crm_warn(&quot;Blind faith: not fencing unseen nodes&quot;);</a>
<a name="ln548"> </a>
<a name="ln549">            /* Warn once per run, not per node and transition */</a>
<a name="ln550">            need_warning = FALSE;</a>
<a name="ln551">        }</a>
<a name="ln552">    }</a>
<a name="ln553"> </a>
<a name="ln554">    if (is_set(data_set-&gt;flags, pe_flag_stonith_enabled) == FALSE</a>
<a name="ln555">        || unseen_are_unclean == FALSE) {</a>
<a name="ln556">        /* blind faith... */</a>
<a name="ln557">        new_node-&gt;details-&gt;unclean = FALSE;</a>
<a name="ln558"> </a>
<a name="ln559">    } else {</a>
<a name="ln560">        /* all nodes are unclean until we've seen their</a>
<a name="ln561">         * status entry</a>
<a name="ln562">         */</a>
<a name="ln563">        new_node-&gt;details-&gt;unclean = TRUE;</a>
<a name="ln564">    }</a>
<a name="ln565"> </a>
<a name="ln566">    /* We need to be able to determine if a node's status section</a>
<a name="ln567">     * exists or not separate from whether the node is unclean. */</a>
<a name="ln568">    new_node-&gt;details-&gt;unseen = TRUE;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">gboolean</a>
<a name="ln572">unpack_nodes(xmlNode * xml_nodes, pe_working_set_t * data_set)</a>
<a name="ln573">{</a>
<a name="ln574">    xmlNode *xml_obj = NULL;</a>
<a name="ln575">    node_t *new_node = NULL;</a>
<a name="ln576">    const char *id = NULL;</a>
<a name="ln577">    const char *uname = NULL;</a>
<a name="ln578">    const char *type = NULL;</a>
<a name="ln579">    const char *score = NULL;</a>
<a name="ln580"> </a>
<a name="ln581">    for (xml_obj = __xml_first_child(xml_nodes); xml_obj != NULL; xml_obj = __xml_next_element(xml_obj)) {</a>
<a name="ln582">        if (crm_str_eq((const char *)xml_obj-&gt;name, XML_CIB_TAG_NODE, TRUE)) {</a>
<a name="ln583">            new_node = NULL;</a>
<a name="ln584"> </a>
<a name="ln585">            id = crm_element_value(xml_obj, XML_ATTR_ID);</a>
<a name="ln586">            uname = crm_element_value(xml_obj, XML_ATTR_UNAME);</a>
<a name="ln587">            type = crm_element_value(xml_obj, XML_ATTR_TYPE);</a>
<a name="ln588">            score = crm_element_value(xml_obj, XML_RULE_ATTR_SCORE);</a>
<a name="ln589">            crm_trace(&quot;Processing node %s/%s&quot;, uname, id);</a>
<a name="ln590"> </a>
<a name="ln591">            if (id == NULL) {</a>
<a name="ln592">                crm_config_err(&quot;Must specify id tag in &lt;node&gt;&quot;);</a>
<a name="ln593">                continue;</a>
<a name="ln594">            }</a>
<a name="ln595">            new_node = pe_create_node(id, uname, type, score, data_set);</a>
<a name="ln596"> </a>
<a name="ln597">            if (new_node == NULL) {</a>
<a name="ln598">                return FALSE;</a>
<a name="ln599">            }</a>
<a name="ln600"> </a>
<a name="ln601">/* 		if(data_set-&gt;have_quorum == FALSE */</a>
<a name="ln602">/* 		   &amp;&amp; data_set-&gt;no_quorum_policy == no_quorum_stop) { */</a>
<a name="ln603">/* 			/\* start shutting resources down *\/ */</a>
<a name="ln604">/* 			new_node-&gt;weight = -INFINITY; */</a>
<a name="ln605">/* 		} */</a>
<a name="ln606"> </a>
<a name="ln607">            handle_startup_fencing(data_set, new_node);</a>
<a name="ln608"> </a>
<a name="ln609">            add_node_attrs(xml_obj, new_node, FALSE, data_set);</a>
<a name="ln610">            unpack_instance_attributes(data_set-&gt;input, xml_obj, XML_TAG_UTILIZATION, NULL,</a>
<a name="ln611">                                       new_node-&gt;details-&gt;utilization, NULL, FALSE, data_set-&gt;now);</a>
<a name="ln612"> </a>
<a name="ln613">            crm_trace(&quot;Done with node %s&quot;, crm_element_value(xml_obj, XML_ATTR_UNAME));</a>
<a name="ln614">        }</a>
<a name="ln615">    }</a>
<a name="ln616"> </a>
<a name="ln617">    if (data_set-&gt;localhost &amp;&amp; pe_find_node(data_set-&gt;nodes, data_set-&gt;localhost) == NULL) {</a>
<a name="ln618">        crm_info(&quot;Creating a fake local node&quot;);</a>
<a name="ln619">        pe_create_node(data_set-&gt;localhost, data_set-&gt;localhost, NULL, 0,</a>
<a name="ln620">                       data_set);</a>
<a name="ln621">    }</a>
<a name="ln622"> </a>
<a name="ln623">    return TRUE;</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">static void</a>
<a name="ln627">setup_container(resource_t * rsc, pe_working_set_t * data_set)</a>
<a name="ln628">{</a>
<a name="ln629">    const char *container_id = NULL;</a>
<a name="ln630"> </a>
<a name="ln631">    if (rsc-&gt;children) {</a>
<a name="ln632">        GListPtr gIter = rsc-&gt;children;</a>
<a name="ln633"> </a>
<a name="ln634">        for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln635">            resource_t *child_rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln636"> </a>
<a name="ln637">            setup_container(child_rsc, data_set);</a>
<a name="ln638">        }</a>
<a name="ln639">        return;</a>
<a name="ln640">    }</a>
<a name="ln641"> </a>
<a name="ln642">    container_id = g_hash_table_lookup(rsc-&gt;meta, XML_RSC_ATTR_CONTAINER);</a>
<a name="ln643">    if (container_id &amp;&amp; safe_str_neq(container_id, rsc-&gt;id)) {</a>
<a name="ln644">        resource_t *container = pe_find_resource(data_set-&gt;resources, container_id);</a>
<a name="ln645"> </a>
<a name="ln646">        if (container) {</a>
<a name="ln647">            rsc-&gt;container = container;</a>
<a name="ln648">            container-&gt;fillers = g_list_append(container-&gt;fillers, rsc);</a>
<a name="ln649">            pe_rsc_trace(rsc, &quot;Resource %s's container is %s&quot;, rsc-&gt;id, container_id);</a>
<a name="ln650">        } else {</a>
<a name="ln651">            pe_err(&quot;Resource %s: Unknown resource container (%s)&quot;, rsc-&gt;id, container_id);</a>
<a name="ln652">        }</a>
<a name="ln653">    }</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656">gboolean</a>
<a name="ln657">unpack_remote_nodes(xmlNode * xml_resources, pe_working_set_t * data_set)</a>
<a name="ln658">{</a>
<a name="ln659">    xmlNode *xml_obj = NULL;</a>
<a name="ln660"> </a>
<a name="ln661">    /* generate remote nodes from resource config before unpacking resources */</a>
<a name="ln662">    for (xml_obj = __xml_first_child(xml_resources); xml_obj != NULL; xml_obj = __xml_next_element(xml_obj)) {</a>
<a name="ln663">        const char *new_node_id = NULL;</a>
<a name="ln664"> </a>
<a name="ln665">        /* first check if this is a bare metal remote node. Bare metal remote nodes</a>
<a name="ln666">         * are defined as a resource primitive only. */</a>
<a name="ln667">        if (xml_contains_remote_node(xml_obj)) {</a>
<a name="ln668">            new_node_id = ID(xml_obj);</a>
<a name="ln669">            /* The &quot;pe_find_node&quot; check is here to make sure we don't iterate over</a>
<a name="ln670">             * an expanded node that has already been added to the node list. */</a>
<a name="ln671">            if (new_node_id &amp;&amp; pe_find_node(data_set-&gt;nodes, new_node_id) == NULL) {</a>
<a name="ln672">                crm_trace(&quot;Found baremetal remote node %s in container resource %s&quot;, new_node_id, ID(xml_obj));</a>
<a name="ln673">                pe_create_node(new_node_id, new_node_id, &quot;remote&quot;, NULL,</a>
<a name="ln674">                               data_set);</a>
<a name="ln675">            }</a>
<a name="ln676">            continue;</a>
<a name="ln677">        }</a>
<a name="ln678"> </a>
<a name="ln679">        /* Now check for guest remote nodes.</a>
<a name="ln680">         * guest remote nodes are defined within a resource primitive.</a>
<a name="ln681">         * Example1: a vm resource might be configured as a remote node.</a>
<a name="ln682">         * Example2: a vm resource might be configured within a group to be a remote node.</a>
<a name="ln683">         * Note: right now we only support guest remote nodes in as a standalone primitive</a>
<a name="ln684">         * or a primitive within a group. No cloned primitives can be a guest remote node</a>
<a name="ln685">         * right now */</a>
<a name="ln686">        if (crm_str_eq((const char *)xml_obj-&gt;name, XML_CIB_TAG_RESOURCE, TRUE)) {</a>
<a name="ln687">            /* expands a metadata defined remote resource into the xml config</a>
<a name="ln688">             * as an actual rsc primitive to be unpacked later. */</a>
<a name="ln689">            new_node_id = expand_remote_rsc_meta(xml_obj, xml_resources, data_set);</a>
<a name="ln690"> </a>
<a name="ln691">            if (new_node_id &amp;&amp; pe_find_node(data_set-&gt;nodes, new_node_id) == NULL) {</a>
<a name="ln692">                crm_trace(&quot;Found guest remote node %s in container resource %s&quot;, new_node_id, ID(xml_obj));</a>
<a name="ln693">                pe_create_node(new_node_id, new_node_id, &quot;remote&quot;, NULL,</a>
<a name="ln694">                               data_set);</a>
<a name="ln695">            }</a>
<a name="ln696">            continue;</a>
<a name="ln697"> </a>
<a name="ln698">        } else if (crm_str_eq((const char *)xml_obj-&gt;name, XML_CIB_TAG_GROUP, TRUE)) {</a>
<a name="ln699">            xmlNode *xml_obj2 = NULL;</a>
<a name="ln700">            /* search through a group to see if any of the primitive contain a remote node. */</a>
<a name="ln701">            for (xml_obj2 = __xml_first_child(xml_obj); xml_obj2 != NULL; xml_obj2 = __xml_next_element(xml_obj2)) {</a>
<a name="ln702"> </a>
<a name="ln703">                new_node_id = expand_remote_rsc_meta(xml_obj2, xml_resources, data_set);</a>
<a name="ln704"> </a>
<a name="ln705">                if (new_node_id &amp;&amp; pe_find_node(data_set-&gt;nodes, new_node_id) == NULL) {</a>
<a name="ln706">                    crm_trace(&quot;Found guest remote node %s in container resource %s which is in group %s&quot;, new_node_id, ID(xml_obj2), ID(xml_obj));</a>
<a name="ln707">                    pe_create_node(new_node_id, new_node_id, &quot;remote&quot;, NULL,</a>
<a name="ln708">                                   data_set);</a>
<a name="ln709">                }</a>
<a name="ln710">            }</a>
<a name="ln711">        }</a>
<a name="ln712">    }</a>
<a name="ln713">    return TRUE;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716"> </a>
<a name="ln717">/* Call this after all the nodes and resources have been</a>
<a name="ln718"> * unpacked, but before the status section is read.</a>
<a name="ln719"> *</a>
<a name="ln720"> * A remote node's online status is reflected by the state</a>
<a name="ln721"> * of the remote node's connection resource. We need to link</a>
<a name="ln722"> * the remote node to this connection resource so we can have</a>
<a name="ln723"> * easy access to the connection resource during the PE calculations.</a>
<a name="ln724"> */</a>
<a name="ln725">static void</a>
<a name="ln726">link_rsc2remotenode(pe_working_set_t *data_set, resource_t *new_rsc)</a>
<a name="ln727">{</a>
<a name="ln728">    node_t *remote_node = NULL;</a>
<a name="ln729"> </a>
<a name="ln730">    if (new_rsc-&gt;is_remote_node == FALSE) {</a>
<a name="ln731">        return;</a>
<a name="ln732">    }</a>
<a name="ln733"> </a>
<a name="ln734">    if (is_set(data_set-&gt;flags, pe_flag_quick_location)) {</a>
<a name="ln735">        /* remote_nodes and remote_resources are not linked in quick location calculations */</a>
<a name="ln736">        return;</a>
<a name="ln737">    }</a>
<a name="ln738"> </a>
<a name="ln739">    print_resource(LOG_DEBUG_3, &quot;Linking remote-node connection resource, &quot;, new_rsc, FALSE);</a>
<a name="ln740"> </a>
<a name="ln741">    remote_node = pe_find_node(data_set-&gt;nodes, new_rsc-&gt;id);</a>
<a name="ln742">    CRM_CHECK(remote_node != NULL, return;);</a>
<a name="ln743"> </a>
<a name="ln744">    remote_node-&gt;details-&gt;remote_rsc = new_rsc;</a>
<a name="ln745">    /* If this is a baremetal remote-node (no container resource</a>
<a name="ln746">     * associated with it) then we need to handle startup fencing the same way</a>
<a name="ln747">     * as cluster nodes. */</a>
<a name="ln748">    if (new_rsc-&gt;container == NULL) {</a>
<a name="ln749">        handle_startup_fencing(data_set, remote_node);</a>
<a name="ln750">    } else {</a>
<a name="ln751">        /* At this point we know if the remote node is a container or baremetal</a>
<a name="ln752">         * remote node, update the #kind attribute if a container is involved */</a>
<a name="ln753">        g_hash_table_replace(remote_node-&gt;details-&gt;attrs, strdup(&quot;#kind&quot;), strdup(&quot;container&quot;));</a>
<a name="ln754">    }</a>
<a name="ln755">}</a>
<a name="ln756"> </a>
<a name="ln757">static void</a>
<a name="ln758">destroy_tag(gpointer data)</a>
<a name="ln759">{</a>
<a name="ln760">    tag_t *tag = data;</a>
<a name="ln761"> </a>
<a name="ln762">    if (tag) {</a>
<a name="ln763">        free(tag-&gt;id);</a>
<a name="ln764">        g_list_free_full(tag-&gt;refs, free);</a>
<a name="ln765">        free(tag);</a>
<a name="ln766">    }</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">gboolean</a>
<a name="ln770">unpack_resources(xmlNode * xml_resources, pe_working_set_t * data_set)</a>
<a name="ln771">{</a>
<a name="ln772">    xmlNode *xml_obj = NULL;</a>
<a name="ln773">    GListPtr gIter = NULL;</a>
<a name="ln774"> </a>
<a name="ln775">    data_set-&gt;template_rsc_sets =</a>
<a name="ln776">        g_hash_table_new_full(crm_str_hash, g_str_equal, g_hash_destroy_str,</a>
<a name="ln777">                              destroy_tag);</a>
<a name="ln778"> </a>
<a name="ln779">    for (xml_obj = __xml_first_child(xml_resources); xml_obj != NULL; xml_obj = __xml_next_element(xml_obj)) {</a>
<a name="ln780">        resource_t *new_rsc = NULL;</a>
<a name="ln781"> </a>
<a name="ln782">        if (crm_str_eq((const char *)xml_obj-&gt;name, XML_CIB_TAG_RSC_TEMPLATE, TRUE)) {</a>
<a name="ln783">            const char *template_id = ID(xml_obj);</a>
<a name="ln784"> </a>
<a name="ln785">            if (template_id &amp;&amp; g_hash_table_lookup_extended(data_set-&gt;template_rsc_sets,</a>
<a name="ln786">                                                            template_id, NULL, NULL) == FALSE) {</a>
<a name="ln787">                /* Record the template's ID for the knowledge of its existence anyway. */</a>
<a name="ln788">                g_hash_table_insert(data_set-&gt;template_rsc_sets, strdup(template_id), NULL);</a>
<a name="ln789">            }</a>
<a name="ln790">            continue;</a>
<a name="ln791">        }</a>
<a name="ln792"> </a>
<a name="ln793">        crm_trace(&quot;Beginning unpack... &lt;%s id=%s... &gt;&quot;, crm_element_name(xml_obj), ID(xml_obj));</a>
<a name="ln794">        if (common_unpack(xml_obj, &amp;new_rsc, NULL, data_set)) {</a>
<a name="ln795">            data_set-&gt;resources = g_list_append(data_set-&gt;resources, new_rsc);</a>
<a name="ln796"> </a>
<a name="ln797">            if (xml_contains_remote_node(xml_obj)) {</a>
<a name="ln798">                new_rsc-&gt;is_remote_node = TRUE;</a>
<a name="ln799">            }</a>
<a name="ln800">            print_resource(LOG_DEBUG_3, &quot;Added &quot;, new_rsc, FALSE);</a>
<a name="ln801"> </a>
<a name="ln802">        } else {</a>
<a name="ln803">            crm_config_err(&quot;Failed unpacking %s %s&quot;,</a>
<a name="ln804">                           crm_element_name(xml_obj), crm_element_value(xml_obj, XML_ATTR_ID));</a>
<a name="ln805">            if (new_rsc != NULL &amp;&amp; new_rsc-&gt;fns != NULL) {</a>
<a name="ln806">                new_rsc-&gt;fns-&gt;free(new_rsc);</a>
<a name="ln807">            }</a>
<a name="ln808">        }</a>
<a name="ln809">    }</a>
<a name="ln810"> </a>
<a name="ln811">    for (gIter = data_set-&gt;resources; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln812">        resource_t *rsc = (resource_t *) gIter-&gt;data;</a>
<a name="ln813"> </a>
<a name="ln814">        setup_container(rsc, data_set);</a>
<a name="ln815">        link_rsc2remotenode(data_set, rsc);</a>
<a name="ln816">    }</a>
<a name="ln817"> </a>
<a name="ln818">    data_set-&gt;resources = g_list_sort(data_set-&gt;resources, sort_rsc_priority);</a>
<a name="ln819">    if (is_set(data_set-&gt;flags, pe_flag_quick_location)) {</a>
<a name="ln820">        /* Ignore */</a>
<a name="ln821"> </a>
<a name="ln822">    } else if (is_set(data_set-&gt;flags, pe_flag_stonith_enabled)</a>
<a name="ln823">               &amp;&amp; is_set(data_set-&gt;flags, pe_flag_have_stonith_resource) == FALSE) {</a>
<a name="ln824"> </a>
<a name="ln825">        crm_config_err(&quot;Resource start-up disabled since no STONITH resources have been defined&quot;);</a>
<a name="ln826">        crm_config_err(&quot;Either configure some or disable STONITH with the stonith-enabled option&quot;);</a>
<a name="ln827">        crm_config_err(&quot;NOTE: Clusters with shared data need STONITH to ensure data integrity&quot;);</a>
<a name="ln828">    }</a>
<a name="ln829"> </a>
<a name="ln830">    return TRUE;</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833">gboolean</a>
<a name="ln834">unpack_tags(xmlNode * xml_tags, pe_working_set_t * data_set)</a>
<a name="ln835">{</a>
<a name="ln836">    xmlNode *xml_tag = NULL;</a>
<a name="ln837"> </a>
<a name="ln838">    data_set-&gt;tags =</a>
<a name="ln839">        g_hash_table_new_full(crm_str_hash, g_str_equal, g_hash_destroy_str, destroy_tag);</a>
<a name="ln840"> </a>
<a name="ln841">    for (xml_tag = __xml_first_child(xml_tags); xml_tag != NULL; xml_tag = __xml_next_element(xml_tag)) {</a>
<a name="ln842">        xmlNode *xml_obj_ref = NULL;</a>
<a name="ln843">        const char *tag_id = ID(xml_tag);</a>
<a name="ln844"> </a>
<a name="ln845">        if (crm_str_eq((const char *)xml_tag-&gt;name, XML_CIB_TAG_TAG, TRUE) == FALSE) {</a>
<a name="ln846">            continue;</a>
<a name="ln847">        }</a>
<a name="ln848"> </a>
<a name="ln849">        if (tag_id == NULL) {</a>
<a name="ln850">            crm_config_err(&quot;Failed unpacking %s: %s should be specified&quot;,</a>
<a name="ln851">                           crm_element_name(xml_tag), XML_ATTR_ID);</a>
<a name="ln852">            continue;</a>
<a name="ln853">        }</a>
<a name="ln854"> </a>
<a name="ln855">        for (xml_obj_ref = __xml_first_child(xml_tag); xml_obj_ref != NULL; xml_obj_ref = __xml_next_element(xml_obj_ref)) {</a>
<a name="ln856">            const char *obj_ref = ID(xml_obj_ref);</a>
<a name="ln857"> </a>
<a name="ln858">            if (crm_str_eq((const char *)xml_obj_ref-&gt;name, XML_CIB_TAG_OBJ_REF, TRUE) == FALSE) {</a>
<a name="ln859">                continue;</a>
<a name="ln860">            }</a>
<a name="ln861"> </a>
<a name="ln862">            if (obj_ref == NULL) {</a>
<a name="ln863">                crm_config_err(&quot;Failed unpacking %s for tag %s: %s should be specified&quot;,</a>
<a name="ln864">                               crm_element_name(xml_obj_ref), tag_id, XML_ATTR_ID);</a>
<a name="ln865">                continue;</a>
<a name="ln866">            }</a>
<a name="ln867"> </a>
<a name="ln868">            if (add_tag_ref(data_set-&gt;tags, tag_id, obj_ref) == FALSE) {</a>
<a name="ln869">                return FALSE;</a>
<a name="ln870">            }</a>
<a name="ln871">        }</a>
<a name="ln872">    }</a>
<a name="ln873"> </a>
<a name="ln874">    return TRUE;</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">/* The ticket state section:</a>
<a name="ln878"> * &quot;/cib/status/tickets/ticket_state&quot; */</a>
<a name="ln879">static gboolean</a>
<a name="ln880">unpack_ticket_state(xmlNode * xml_ticket, pe_working_set_t * data_set)</a>
<a name="ln881">{</a>
<a name="ln882">    const char *ticket_id = NULL;</a>
<a name="ln883">    const char *granted = NULL;</a>
<a name="ln884">    const char *last_granted = NULL;</a>
<a name="ln885">    const char *standby = NULL;</a>
<a name="ln886">    xmlAttrPtr xIter = NULL;</a>
<a name="ln887"> </a>
<a name="ln888">    ticket_t *ticket = NULL;</a>
<a name="ln889"> </a>
<a name="ln890">    ticket_id = ID(xml_ticket);</a>
<a name="ln891">    if (ticket_id == NULL || strlen(ticket_id) == 0) {</a>
<a name="ln892">        return FALSE;</a>
<a name="ln893">    }</a>
<a name="ln894"> </a>
<a name="ln895">    crm_trace(&quot;Processing ticket state for %s&quot;, ticket_id);</a>
<a name="ln896"> </a>
<a name="ln897">    ticket = g_hash_table_lookup(data_set-&gt;tickets, ticket_id);</a>
<a name="ln898">    if (ticket == NULL) {</a>
<a name="ln899">        ticket = ticket_new(ticket_id, data_set);</a>
<a name="ln900">        if (ticket == NULL) {</a>
<a name="ln901">            return FALSE;</a>
<a name="ln902">        }</a>
<a name="ln903">    }</a>
<a name="ln904"> </a>
<a name="ln905">    for (xIter = xml_ticket-&gt;properties; xIter; xIter = xIter-&gt;next) {</a>
<a name="ln906">        const char *prop_name = (const char *)xIter-&gt;name;</a>
<a name="ln907">        const char *prop_value = crm_element_value(xml_ticket, prop_name);</a>
<a name="ln908"> </a>
<a name="ln909">        if (crm_str_eq(prop_name, XML_ATTR_ID, TRUE)) {</a>
<a name="ln910">            continue;</a>
<a name="ln911">        }</a>
<a name="ln912">        g_hash_table_replace(ticket-&gt;state, strdup(prop_name), strdup(prop_value));</a>
<a name="ln913">    }</a>
<a name="ln914"> </a>
<a name="ln915">    granted = g_hash_table_lookup(ticket-&gt;state, &quot;granted&quot;);</a>
<a name="ln916">    if (granted &amp;&amp; crm_is_true(granted)) {</a>
<a name="ln917">        ticket-&gt;granted = TRUE;</a>
<a name="ln918">        crm_info(&quot;We have ticket '%s'&quot;, ticket-&gt;id);</a>
<a name="ln919">    } else {</a>
<a name="ln920">        ticket-&gt;granted = FALSE;</a>
<a name="ln921">        crm_info(&quot;We do not have ticket '%s'&quot;, ticket-&gt;id);</a>
<a name="ln922">    }</a>
<a name="ln923"> </a>
<a name="ln924">    last_granted = g_hash_table_lookup(ticket-&gt;state, &quot;last-granted&quot;);</a>
<a name="ln925">    if (last_granted) {</a>
<a name="ln926">        ticket-&gt;last_granted = crm_parse_int(last_granted, 0);</a>
<a name="ln927">    }</a>
<a name="ln928"> </a>
<a name="ln929">    standby = g_hash_table_lookup(ticket-&gt;state, &quot;standby&quot;);</a>
<a name="ln930">    if (standby &amp;&amp; crm_is_true(standby)) {</a>
<a name="ln931">        ticket-&gt;standby = TRUE;</a>
<a name="ln932">        if (ticket-&gt;granted) {</a>
<a name="ln933">            crm_info(&quot;Granted ticket '%s' is in standby-mode&quot;, ticket-&gt;id);</a>
<a name="ln934">        }</a>
<a name="ln935">    } else {</a>
<a name="ln936">        ticket-&gt;standby = FALSE;</a>
<a name="ln937">    }</a>
<a name="ln938"> </a>
<a name="ln939">    crm_trace(&quot;Done with ticket state for %s&quot;, ticket_id);</a>
<a name="ln940"> </a>
<a name="ln941">    return TRUE;</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">static gboolean</a>
<a name="ln945">unpack_tickets_state(xmlNode * xml_tickets, pe_working_set_t * data_set)</a>
<a name="ln946">{</a>
<a name="ln947">    xmlNode *xml_obj = NULL;</a>
<a name="ln948"> </a>
<a name="ln949">    for (xml_obj = __xml_first_child(xml_tickets); xml_obj != NULL; xml_obj = __xml_next_element(xml_obj)) {</a>
<a name="ln950">        if (crm_str_eq((const char *)xml_obj-&gt;name, XML_CIB_TAG_TICKET_STATE, TRUE) == FALSE) {</a>
<a name="ln951">            continue;</a>
<a name="ln952">        }</a>
<a name="ln953">        unpack_ticket_state(xml_obj, data_set);</a>
<a name="ln954">    }</a>
<a name="ln955"> </a>
<a name="ln956">    return TRUE;</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959">/* Compatibility with the deprecated ticket state section:</a>
<a name="ln960"> * &quot;/cib/status/tickets/instance_attributes&quot; */</a>
<a name="ln961">static void</a>
<a name="ln962">get_ticket_state_legacy(gpointer key, gpointer value, gpointer user_data)</a>
<a name="ln963">{</a>
<a name="ln964">    const char *long_key = key;</a>
<a name="ln965">    char *state_key = NULL;</a>
<a name="ln966"> </a>
<a name="ln967">    const char *granted_prefix = &quot;granted-ticket-&quot;;</a>
<a name="ln968">    const char *last_granted_prefix = &quot;last-granted-&quot;;</a>
<a name="ln969">    static int granted_prefix_strlen = 0;</a>
<a name="ln970">    static int last_granted_prefix_strlen = 0;</a>
<a name="ln971"> </a>
<a name="ln972">    const char *ticket_id = NULL;</a>
<a name="ln973">    const char *is_granted = NULL;</a>
<a name="ln974">    const char *last_granted = NULL;</a>
<a name="ln975">    const char *sep = NULL;</a>
<a name="ln976"> </a>
<a name="ln977">    ticket_t *ticket = NULL;</a>
<a name="ln978">    pe_working_set_t *data_set = user_data;</a>
<a name="ln979"> </a>
<a name="ln980">    if (granted_prefix_strlen == 0) {</a>
<a name="ln981">        granted_prefix_strlen = strlen(granted_prefix);</a>
<a name="ln982">    }</a>
<a name="ln983"> </a>
<a name="ln984">    if (last_granted_prefix_strlen == 0) {</a>
<a name="ln985">        last_granted_prefix_strlen = strlen(last_granted_prefix);</a>
<a name="ln986">    }</a>
<a name="ln987"> </a>
<a name="ln988">    if (strstr(long_key, granted_prefix) == long_key) {</a>
<a name="ln989">        ticket_id = long_key + granted_prefix_strlen;</a>
<a name="ln990">        if (strlen(ticket_id)) {</a>
<a name="ln991">            state_key = strdup(&quot;granted&quot;);</a>
<a name="ln992">            is_granted = value;</a>
<a name="ln993">        }</a>
<a name="ln994">    } else if (strstr(long_key, last_granted_prefix) == long_key) {</a>
<a name="ln995">        ticket_id = long_key + last_granted_prefix_strlen;</a>
<a name="ln996">        if (strlen(ticket_id)) {</a>
<a name="ln997">            state_key = strdup(&quot;last-granted&quot;);</a>
<a name="ln998">            last_granted = value;</a>
<a name="ln999">        }</a>
<a name="ln1000">    } else if ((sep = strrchr(long_key, '-'))) {</a>
<a name="ln1001">        ticket_id = sep + 1;</a>
<a name="ln1002">        state_key = strndup(long_key, strlen(long_key) - strlen(sep));</a>
<a name="ln1003">    }</a>
<a name="ln1004"> </a>
<a name="ln1005">    if (ticket_id == NULL || strlen(ticket_id) == 0) {</a>
<a name="ln1006">        free(state_key);</a>
<a name="ln1007">        return;</a>
<a name="ln1008">    }</a>
<a name="ln1009"> </a>
<a name="ln1010">    if (state_key == NULL || strlen(state_key) == 0) {</a>
<a name="ln1011">        free(state_key);</a>
<a name="ln1012">        return;</a>
<a name="ln1013">    }</a>
<a name="ln1014"> </a>
<a name="ln1015">    ticket = g_hash_table_lookup(data_set-&gt;tickets, ticket_id);</a>
<a name="ln1016">    if (ticket == NULL) {</a>
<a name="ln1017">        ticket = ticket_new(ticket_id, data_set);</a>
<a name="ln1018">        if (ticket == NULL) {</a>
<a name="ln1019">            free(state_key);</a>
<a name="ln1020">            return;</a>
<a name="ln1021">        }</a>
<a name="ln1022">    }</a>
<a name="ln1023"> </a>
<a name="ln1024">    g_hash_table_replace(ticket-&gt;state, state_key, strdup(value));</a>
<a name="ln1025"> </a>
<a name="ln1026">    if (is_granted) {</a>
<a name="ln1027">        if (crm_is_true(is_granted)) {</a>
<a name="ln1028">            ticket-&gt;granted = TRUE;</a>
<a name="ln1029">            crm_info(&quot;We have ticket '%s'&quot;, ticket-&gt;id);</a>
<a name="ln1030">        } else {</a>
<a name="ln1031">            ticket-&gt;granted = FALSE;</a>
<a name="ln1032">            crm_info(&quot;We do not have ticket '%s'&quot;, ticket-&gt;id);</a>
<a name="ln1033">        }</a>
<a name="ln1034"> </a>
<a name="ln1035">    } else if (last_granted) {</a>
<a name="ln1036">        ticket-&gt;last_granted = crm_parse_int(last_granted, 0);</a>
<a name="ln1037">    }</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">static void</a>
<a name="ln1041">unpack_handle_remote_attrs(node_t *this_node, xmlNode *state, pe_working_set_t * data_set) </a>
<a name="ln1042">{</a>
<a name="ln1043">    const char *resource_discovery_enabled = NULL;</a>
<a name="ln1044">    xmlNode *attrs = NULL;</a>
<a name="ln1045">    resource_t *rsc = NULL;</a>
<a name="ln1046">    const char *shutdown = NULL;</a>
<a name="ln1047"> </a>
<a name="ln1048">    if (crm_str_eq((const char *)state-&gt;name, XML_CIB_TAG_STATE, TRUE) == FALSE) {</a>
<a name="ln1049">        return;</a>
<a name="ln1050">    }</a>
<a name="ln1051"> </a>
<a name="ln1052">    if ((this_node == NULL) || (is_remote_node(this_node) == FALSE)) {</a>
<a name="ln1053">        return;</a>
<a name="ln1054">    }</a>
<a name="ln1055">    crm_trace(&quot;Processing remote node id=%s, uname=%s&quot;, this_node-&gt;details-&gt;id, this_node-&gt;details-&gt;uname);</a>
<a name="ln1056"> </a>
<a name="ln1057">    this_node-&gt;details-&gt;remote_maintenance =</a>
<a name="ln1058">        crm_atoi(crm_element_value(state, XML_NODE_IS_MAINTENANCE), &quot;0&quot;);</a>
<a name="ln1059"> </a>
<a name="ln1060">    rsc = this_node-&gt;details-&gt;remote_rsc;</a>
<a name="ln1061">    if (this_node-&gt;details-&gt;remote_requires_reset == FALSE) {</a>
<a name="ln1062">        this_node-&gt;details-&gt;unclean = FALSE;</a>
<a name="ln1063">        this_node-&gt;details-&gt;unseen = FALSE;</a>
<a name="ln1064">    }</a>
<a name="ln1065">    attrs = find_xml_node(state, XML_TAG_TRANSIENT_NODEATTRS, FALSE);</a>
<a name="ln1066">    add_node_attrs(attrs, this_node, TRUE, data_set);</a>
<a name="ln1067"> </a>
<a name="ln1068">    shutdown = g_hash_table_lookup(this_node-&gt;details-&gt;attrs, XML_CIB_ATTR_SHUTDOWN);</a>
<a name="ln1069">    if (shutdown != NULL &amp;&amp; safe_str_neq(&quot;0&quot;, shutdown)) {</a>
<a name="ln1070">        crm_info(&quot;Node %s is shutting down&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1071">        this_node-&gt;details-&gt;shutdown = TRUE;</a>
<a name="ln1072">        if (rsc) {</a>
<a name="ln1073">            rsc-&gt;next_role = RSC_ROLE_STOPPED;</a>
<a name="ln1074">        }</a>
<a name="ln1075">    }</a>
<a name="ln1076"> </a>
<a name="ln1077">    if (crm_is_true(g_hash_table_lookup(this_node-&gt;details-&gt;attrs, &quot;standby&quot;))) {</a>
<a name="ln1078">        crm_info(&quot;Node %s is in standby-mode&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1079">        this_node-&gt;details-&gt;standby = TRUE;</a>
<a name="ln1080">    }</a>
<a name="ln1081"> </a>
<a name="ln1082">    if (crm_is_true(g_hash_table_lookup(this_node-&gt;details-&gt;attrs, &quot;maintenance&quot;)) ||</a>
<a name="ln1083">        (rsc &amp;&amp; !is_set(rsc-&gt;flags, pe_rsc_managed))) {</a>
<a name="ln1084">        crm_info(&quot;Node %s is in maintenance-mode&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1085">        this_node-&gt;details-&gt;maintenance = TRUE;</a>
<a name="ln1086">    }</a>
<a name="ln1087"> </a>
<a name="ln1088">    resource_discovery_enabled = g_hash_table_lookup(this_node-&gt;details-&gt;attrs, XML_NODE_ATTR_RSC_DISCOVERY);</a>
<a name="ln1089">    if (resource_discovery_enabled &amp;&amp; !crm_is_true(resource_discovery_enabled)) {</a>
<a name="ln1090">        if (is_baremetal_remote_node(this_node) &amp;&amp; is_not_set(data_set-&gt;flags, pe_flag_stonith_enabled)) {</a>
<a name="ln1091">            crm_warn(&quot;ignoring %s attribute on baremetal remote node %s, disabling resource discovery requires stonith to be enabled.&quot;,</a>
<a name="ln1092">                     XML_NODE_ATTR_RSC_DISCOVERY, this_node-&gt;details-&gt;uname);</a>
<a name="ln1093">        } else {</a>
<a name="ln1094">            /* if we're here, this is either a baremetal node and fencing is enabled,</a>
<a name="ln1095">             * or this is a container node which we don't care if fencing is enabled </a>
<a name="ln1096">             * or not on. container nodes are 'fenced' by recovering the container resource</a>
<a name="ln1097">             * regardless of whether fencing is enabled. */</a>
<a name="ln1098">            crm_info(&quot;Node %s has resource discovery disabled&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1099">            this_node-&gt;details-&gt;rsc_discovery_enabled = FALSE;</a>
<a name="ln1100">        }</a>
<a name="ln1101">    }</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104">static bool</a>
<a name="ln1105">unpack_node_loop(xmlNode * status, bool fence, pe_working_set_t * data_set) </a>
<a name="ln1106">{</a>
<a name="ln1107">    bool changed = false;</a>
<a name="ln1108">    xmlNode *lrm_rsc = NULL;</a>
<a name="ln1109"> </a>
<a name="ln1110">    for (xmlNode *state = __xml_first_child(status); state != NULL; state = __xml_next_element(state)) {</a>
<a name="ln1111">        const char *id = NULL;</a>
<a name="ln1112">        const char *uname = NULL;</a>
<a name="ln1113">        node_t *this_node = NULL;</a>
<a name="ln1114">        bool process = FALSE;</a>
<a name="ln1115"> </a>
<a name="ln1116">        if (crm_str_eq((const char *)state-&gt;name, XML_CIB_TAG_STATE, TRUE) == FALSE) {</a>
<a name="ln1117">            continue;</a>
<a name="ln1118">        }</a>
<a name="ln1119"> </a>
<a name="ln1120">        id = crm_element_value(state, XML_ATTR_ID);</a>
<a name="ln1121">        uname = crm_element_value(state, XML_ATTR_UNAME);</a>
<a name="ln1122">        this_node = pe_find_node_any(data_set-&gt;nodes, id, uname);</a>
<a name="ln1123"> </a>
<a name="ln1124">        if (this_node == NULL) {</a>
<a name="ln1125">            crm_info(&quot;Node %s is unknown&quot;, id);</a>
<a name="ln1126">            continue;</a>
<a name="ln1127"> </a>
<a name="ln1128">        } else if (this_node-&gt;details-&gt;unpacked) {</a>
<a name="ln1129">            crm_info(&quot;Node %s is already processed&quot;, id);</a>
<a name="ln1130">            continue;</a>
<a name="ln1131"> </a>
<a name="ln1132">        } else if (is_remote_node(this_node) == FALSE &amp;&amp; is_set(data_set-&gt;flags, pe_flag_stonith_enabled)) {</a>
<a name="ln1133">            // A redundant test, but preserves the order for regression tests</a>
<a name="ln1134">            process = TRUE;</a>
<a name="ln1135"> </a>
<a name="ln1136">        } else if (is_remote_node(this_node)) {</a>
<a name="ln1137">            resource_t *rsc = this_node-&gt;details-&gt;remote_rsc;</a>
<a name="ln1138"> </a>
<a name="ln1139">            if (fence || (rsc &amp;&amp; rsc-&gt;role == RSC_ROLE_STARTED)) {</a>
<a name="ln1140">                determine_remote_online_status(data_set, this_node);</a>
<a name="ln1141">                unpack_handle_remote_attrs(this_node, state, data_set);</a>
<a name="ln1142">                process = TRUE;</a>
<a name="ln1143">            }</a>
<a name="ln1144"> </a>
<a name="ln1145">        } else if (this_node-&gt;details-&gt;online) {</a>
<a name="ln1146">            process = TRUE;</a>
<a name="ln1147"> </a>
<a name="ln1148">        } else if (fence) {</a>
<a name="ln1149">            process = TRUE;</a>
<a name="ln1150">        }</a>
<a name="ln1151"> </a>
<a name="ln1152">        if(process) {</a>
<a name="ln1153">            crm_trace(&quot;Processing lrm resource entries on %shealthy%s node: %s&quot;,</a>
<a name="ln1154">                      fence?&quot;un&quot;:&quot;&quot;, is_remote_node(this_node)?&quot; remote&quot;:&quot;&quot;,</a>
<a name="ln1155">                      this_node-&gt;details-&gt;uname);</a>
<a name="ln1156">            changed = TRUE;</a>
<a name="ln1157">            this_node-&gt;details-&gt;unpacked = TRUE;</a>
<a name="ln1158"> </a>
<a name="ln1159">            lrm_rsc = find_xml_node(state, XML_CIB_TAG_LRM, FALSE);</a>
<a name="ln1160">            lrm_rsc = find_xml_node(lrm_rsc, XML_LRM_TAG_RESOURCES, FALSE);</a>
<a name="ln1161">            unpack_lrm_resources(this_node, lrm_rsc, data_set);</a>
<a name="ln1162">        }</a>
<a name="ln1163">    }</a>
<a name="ln1164">    return changed;</a>
<a name="ln1165">}</a>
<a name="ln1166"> </a>
<a name="ln1167">/* remove nodes that are down, stopping */</a>
<a name="ln1168">/* create +ve rsc_to_node constraints between resources and the nodes they are running on */</a>
<a name="ln1169">/* anything else? */</a>
<a name="ln1170">gboolean</a>
<a name="ln1171">unpack_status(xmlNode * status, pe_working_set_t * data_set)</a>
<a name="ln1172">{</a>
<a name="ln1173">    const char *id = NULL;</a>
<a name="ln1174">    const char *uname = NULL;</a>
<a name="ln1175"> </a>
<a name="ln1176">    xmlNode *state = NULL;</a>
<a name="ln1177">    node_t *this_node = NULL;</a>
<a name="ln1178"> </a>
<a name="ln1179">    crm_trace(&quot;Beginning unpack&quot;);</a>
<a name="ln1180"> </a>
<a name="ln1181">    if (data_set-&gt;tickets == NULL) {</a>
<a name="ln1182">        data_set-&gt;tickets =</a>
<a name="ln1183">            g_hash_table_new_full(crm_str_hash, g_str_equal, g_hash_destroy_str, destroy_ticket);</a>
<a name="ln1184">    }</a>
<a name="ln1185"> </a>
<a name="ln1186">    for (state = __xml_first_child(status); state != NULL; state = __xml_next_element(state)) {</a>
<a name="ln1187">        if (crm_str_eq((const char *)state-&gt;name, XML_CIB_TAG_TICKETS, TRUE)) {</a>
<a name="ln1188">            xmlNode *xml_tickets = state;</a>
<a name="ln1189">            GHashTable *state_hash = NULL;</a>
<a name="ln1190"> </a>
<a name="ln1191">            /* Compatibility with the deprecated ticket state section:</a>
<a name="ln1192">             * Unpack the attributes in the deprecated &quot;/cib/status/tickets/instance_attributes&quot; if it exists. */</a>
<a name="ln1193">            state_hash =</a>
<a name="ln1194">                g_hash_table_new_full(crm_str_hash, g_str_equal, g_hash_destroy_str,</a>
<a name="ln1195">                                      g_hash_destroy_str);</a>
<a name="ln1196"> </a>
<a name="ln1197">            unpack_instance_attributes(data_set-&gt;input, xml_tickets, XML_TAG_ATTR_SETS, NULL,</a>
<a name="ln1198">                                       state_hash, NULL, TRUE, data_set-&gt;now);</a>
<a name="ln1199"> </a>
<a name="ln1200">            g_hash_table_foreach(state_hash, get_ticket_state_legacy, data_set);</a>
<a name="ln1201"> </a>
<a name="ln1202">            if (state_hash) {</a>
<a name="ln1203">                g_hash_table_destroy(state_hash);</a>
<a name="ln1204">            }</a>
<a name="ln1205"> </a>
<a name="ln1206">            /* Unpack the new &quot;/cib/status/tickets/ticket_state&quot;s */</a>
<a name="ln1207">            unpack_tickets_state(xml_tickets, data_set);</a>
<a name="ln1208">        }</a>
<a name="ln1209"> </a>
<a name="ln1210">        if (crm_str_eq((const char *)state-&gt;name, XML_CIB_TAG_STATE, TRUE)) {</a>
<a name="ln1211">            xmlNode *attrs = NULL;</a>
<a name="ln1212">            const char *resource_discovery_enabled = NULL;</a>
<a name="ln1213"> </a>
<a name="ln1214">            id = crm_element_value(state, XML_ATTR_ID);</a>
<a name="ln1215">            uname = crm_element_value(state, XML_ATTR_UNAME);</a>
<a name="ln1216">            this_node = pe_find_node_any(data_set-&gt;nodes, id, uname);</a>
<a name="ln1217"> </a>
<a name="ln1218">            if (uname == NULL) {</a>
<a name="ln1219">                /* error */</a>
<a name="ln1220">                continue;</a>
<a name="ln1221"> </a>
<a name="ln1222">            } else if (this_node == NULL) {</a>
<a name="ln1223">                crm_config_warn(&quot;Node %s in status section no longer exists&quot;, uname);</a>
<a name="ln1224">                continue;</a>
<a name="ln1225"> </a>
<a name="ln1226">            } else if (is_remote_node(this_node)) {</a>
<a name="ln1227">                /* online state for remote nodes is determined by the</a>
<a name="ln1228">                 * rsc state after all the unpacking is done. we do however</a>
<a name="ln1229">                 * need to mark whether or not the node has been fenced as this plays</a>
<a name="ln1230">                 * a role during unpacking cluster node resource state */</a>
<a name="ln1231">                this_node-&gt;details-&gt;remote_was_fenced = </a>
<a name="ln1232">                    crm_atoi(crm_element_value(state, XML_NODE_IS_FENCED), &quot;0&quot;);</a>
<a name="ln1233">                continue;</a>
<a name="ln1234">            }</a>
<a name="ln1235"> </a>
<a name="ln1236">            crm_trace(&quot;Processing node id=%s, uname=%s&quot;, id, uname);</a>
<a name="ln1237"> </a>
<a name="ln1238">            /* Mark the node as provisionally clean</a>
<a name="ln1239">             * - at least we have seen it in the current cluster's lifetime</a>
<a name="ln1240">             */</a>
<a name="ln1241">            this_node-&gt;details-&gt;unclean = FALSE;</a>
<a name="ln1242">            this_node-&gt;details-&gt;unseen = FALSE;</a>
<a name="ln1243">            attrs = find_xml_node(state, XML_TAG_TRANSIENT_NODEATTRS, FALSE);</a>
<a name="ln1244">            add_node_attrs(attrs, this_node, TRUE, data_set);</a>
<a name="ln1245"> </a>
<a name="ln1246">            if (crm_is_true(g_hash_table_lookup(this_node-&gt;details-&gt;attrs, &quot;standby&quot;))) {</a>
<a name="ln1247">                crm_info(&quot;Node %s is in standby-mode&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1248">                this_node-&gt;details-&gt;standby = TRUE;</a>
<a name="ln1249">            }</a>
<a name="ln1250"> </a>
<a name="ln1251">            if (crm_is_true(g_hash_table_lookup(this_node-&gt;details-&gt;attrs, &quot;maintenance&quot;))) {</a>
<a name="ln1252">                crm_info(&quot;Node %s is in maintenance-mode&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1253">                this_node-&gt;details-&gt;maintenance = TRUE;</a>
<a name="ln1254">            }</a>
<a name="ln1255"> </a>
<a name="ln1256">            resource_discovery_enabled = g_hash_table_lookup(this_node-&gt;details-&gt;attrs, XML_NODE_ATTR_RSC_DISCOVERY);</a>
<a name="ln1257">            if (resource_discovery_enabled &amp;&amp; !crm_is_true(resource_discovery_enabled)) {</a>
<a name="ln1258">                crm_warn(&quot;ignoring %s attribute on node %s, disabling resource discovery is not allowed on cluster nodes&quot;,</a>
<a name="ln1259">                    XML_NODE_ATTR_RSC_DISCOVERY, this_node-&gt;details-&gt;uname);</a>
<a name="ln1260">            }</a>
<a name="ln1261"> </a>
<a name="ln1262">            crm_trace(&quot;determining node state&quot;);</a>
<a name="ln1263">            determine_online_status(state, this_node, data_set);</a>
<a name="ln1264"> </a>
<a name="ln1265">            if (this_node-&gt;details-&gt;online &amp;&amp; data_set-&gt;no_quorum_policy == no_quorum_suicide) {</a>
<a name="ln1266">                /* Everything else should flow from this automatically</a>
<a name="ln1267">                 * At least until the PE becomes able to migrate off healthy resources</a>
<a name="ln1268">                 */</a>
<a name="ln1269">                pe_fence_node(data_set, this_node, &quot;because the cluster does not have quorum&quot;);</a>
<a name="ln1270">            }</a>
<a name="ln1271">        }</a>
<a name="ln1272">    }</a>
<a name="ln1273"> </a>
<a name="ln1274"> </a>
<a name="ln1275">    while(unpack_node_loop(status, FALSE, data_set)) {</a>
<a name="ln1276">        crm_trace(&quot;Start another loop&quot;);</a>
<a name="ln1277">    }</a>
<a name="ln1278"> </a>
<a name="ln1279">    // Now catch any nodes we didnt see</a>
<a name="ln1280">    unpack_node_loop(status, is_set(data_set-&gt;flags, pe_flag_stonith_enabled), data_set);</a>
<a name="ln1281"> </a>
<a name="ln1282">    for (GListPtr gIter = data_set-&gt;nodes; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln1283">        node_t *this_node = gIter-&gt;data;</a>
<a name="ln1284"> </a>
<a name="ln1285">        if (this_node == NULL) {</a>
<a name="ln1286">            continue;</a>
<a name="ln1287">        } else if(is_remote_node(this_node) == FALSE) {</a>
<a name="ln1288">            continue;</a>
<a name="ln1289">        } else if(this_node-&gt;details-&gt;unpacked) {</a>
<a name="ln1290">            continue;</a>
<a name="ln1291">        }</a>
<a name="ln1292">        determine_remote_online_status(data_set, this_node);</a>
<a name="ln1293">    }</a>
<a name="ln1294"> </a>
<a name="ln1295">    return TRUE;</a>
<a name="ln1296">}</a>
<a name="ln1297"> </a>
<a name="ln1298">static gboolean</a>
<a name="ln1299">determine_online_status_no_fencing(pe_working_set_t * data_set, xmlNode * node_state,</a>
<a name="ln1300">                                   node_t * this_node)</a>
<a name="ln1301">{</a>
<a name="ln1302">    gboolean online = FALSE;</a>
<a name="ln1303">    const char *join = crm_element_value(node_state, XML_NODE_JOIN_STATE);</a>
<a name="ln1304">    const char *is_peer = crm_element_value(node_state, XML_NODE_IS_PEER);</a>
<a name="ln1305">    const char *in_cluster = crm_element_value(node_state, XML_NODE_IN_CLUSTER);</a>
<a name="ln1306">    const char *exp_state = crm_element_value(node_state, XML_NODE_EXPECTED);</a>
<a name="ln1307"> </a>
<a name="ln1308">    if (!crm_is_true(in_cluster)) {</a>
<a name="ln1309">        crm_trace(&quot;Node is down: in_cluster=%s&quot;, crm_str(in_cluster));</a>
<a name="ln1310"> </a>
<a name="ln1311">    } else if (safe_str_eq(is_peer, ONLINESTATUS)) {</a>
<a name="ln1312">        if (safe_str_eq(join, CRMD_JOINSTATE_MEMBER)) {</a>
<a name="ln1313">            online = TRUE;</a>
<a name="ln1314">        } else {</a>
<a name="ln1315">            crm_debug(&quot;Node is not ready to run resources: %s&quot;, join);</a>
<a name="ln1316">        }</a>
<a name="ln1317"> </a>
<a name="ln1318">    } else if (this_node-&gt;details-&gt;expected_up == FALSE) {</a>
<a name="ln1319">        crm_trace(&quot;CRMd is down: in_cluster=%s&quot;, crm_str(in_cluster));</a>
<a name="ln1320">        crm_trace(&quot;\tis_peer=%s, join=%s, expected=%s&quot;,</a>
<a name="ln1321">                  crm_str(is_peer), crm_str(join), crm_str(exp_state));</a>
<a name="ln1322"> </a>
<a name="ln1323">    } else {</a>
<a name="ln1324">        /* mark it unclean */</a>
<a name="ln1325">        pe_fence_node(data_set, this_node, &quot;because node is unexpectedly down&quot;);</a>
<a name="ln1326">        crm_info(&quot;\tin_cluster=%s, is_peer=%s, join=%s, expected=%s&quot;,</a>
<a name="ln1327">                 crm_str(in_cluster), crm_str(is_peer), crm_str(join), crm_str(exp_state));</a>
<a name="ln1328">    }</a>
<a name="ln1329">    return online;</a>
<a name="ln1330">}</a>
<a name="ln1331"> </a>
<a name="ln1332">static gboolean</a>
<a name="ln1333">determine_online_status_fencing(pe_working_set_t * data_set, xmlNode * node_state,</a>
<a name="ln1334">                                node_t * this_node)</a>
<a name="ln1335">{</a>
<a name="ln1336">    gboolean online = FALSE;</a>
<a name="ln1337">    gboolean do_terminate = FALSE;</a>
<a name="ln1338">    const char *join = crm_element_value(node_state, XML_NODE_JOIN_STATE);</a>
<a name="ln1339">    const char *is_peer = crm_element_value(node_state, XML_NODE_IS_PEER);</a>
<a name="ln1340">    const char *in_cluster = crm_element_value(node_state, XML_NODE_IN_CLUSTER);</a>
<a name="ln1341">    const char *exp_state = crm_element_value(node_state, XML_NODE_EXPECTED);</a>
<a name="ln1342">    const char *terminate = g_hash_table_lookup(this_node-&gt;details-&gt;attrs, &quot;terminate&quot;);</a>
<a name="ln1343"> </a>
<a name="ln1344">/*</a>
<a name="ln1345">  - XML_NODE_IN_CLUSTER    ::= true|false</a>
<a name="ln1346">  - XML_NODE_IS_PEER       ::= true|false|online|offline</a>
<a name="ln1347">  - XML_NODE_JOIN_STATE    ::= member|down|pending|banned</a>
<a name="ln1348">  - XML_NODE_EXPECTED      ::= member|down</a>
<a name="ln1349">*/</a>
<a name="ln1350"> </a>
<a name="ln1351">    if (crm_is_true(terminate)) {</a>
<a name="ln1352">        do_terminate = TRUE;</a>
<a name="ln1353"> </a>
<a name="ln1354">    } else if (terminate != NULL &amp;&amp; strlen(terminate) &gt; 0) {</a>
<a name="ln1355">        /* could be a time() value */</a>
<a name="ln1356">        char t = terminate[0];</a>
<a name="ln1357"> </a>
<a name="ln1358">        if (t != '0' &amp;&amp; isdigit(t)) {</a>
<a name="ln1359">            do_terminate = TRUE;</a>
<a name="ln1360">        }</a>
<a name="ln1361">    }</a>
<a name="ln1362"> </a>
<a name="ln1363">    crm_trace(&quot;%s: in_cluster=%s, is_peer=%s, join=%s, expected=%s, term=%d&quot;,</a>
<a name="ln1364">              this_node-&gt;details-&gt;uname, crm_str(in_cluster), crm_str(is_peer),</a>
<a name="ln1365">              crm_str(join), crm_str(exp_state), do_terminate);</a>
<a name="ln1366"> </a>
<a name="ln1367">    online = crm_is_true(in_cluster);</a>
<a name="ln1368">    if (safe_str_eq(is_peer, ONLINESTATUS)) {</a>
<a name="ln1369">        is_peer = XML_BOOLEAN_YES;</a>
<a name="ln1370">    }</a>
<a name="ln1371">    if (exp_state == NULL) {</a>
<a name="ln1372">        exp_state = CRMD_JOINSTATE_DOWN;</a>
<a name="ln1373">    }</a>
<a name="ln1374"> </a>
<a name="ln1375">    if (this_node-&gt;details-&gt;shutdown) {</a>
<a name="ln1376">        crm_debug(&quot;%s is shutting down&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1377"> </a>
<a name="ln1378">        /* Slightly different criteria since we can't shut down a dead peer */</a>
<a name="ln1379">        online = crm_is_true(is_peer);</a>
<a name="ln1380"> </a>
<a name="ln1381">    } else if (in_cluster == NULL) {</a>
<a name="ln1382">        pe_fence_node(data_set, this_node, &quot;because the peer has not been seen by the cluster&quot;);</a>
<a name="ln1383"> </a>
<a name="ln1384">    } else if (safe_str_eq(join, CRMD_JOINSTATE_NACK)) {</a>
<a name="ln1385">        pe_fence_node(data_set, this_node, &quot;because it failed the pacemaker membership criteria&quot;);</a>
<a name="ln1386"> </a>
<a name="ln1387">    } else if (do_terminate == FALSE &amp;&amp; safe_str_eq(exp_state, CRMD_JOINSTATE_DOWN)) {</a>
<a name="ln1388"> </a>
<a name="ln1389">        if (crm_is_true(in_cluster) || crm_is_true(is_peer)) {</a>
<a name="ln1390">            crm_info(&quot;- Node %s is not ready to run resources&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1391">            this_node-&gt;details-&gt;standby = TRUE;</a>
<a name="ln1392">            this_node-&gt;details-&gt;pending = TRUE;</a>
<a name="ln1393"> </a>
<a name="ln1394">        } else {</a>
<a name="ln1395">            crm_trace(&quot;%s is down or still coming up&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1396">        }</a>
<a name="ln1397"> </a>
<a name="ln1398">    } else if (do_terminate &amp;&amp; safe_str_eq(join, CRMD_JOINSTATE_DOWN)</a>
<a name="ln1399">               &amp;&amp; crm_is_true(in_cluster) == FALSE &amp;&amp; crm_is_true(is_peer) == FALSE) {</a>
<a name="ln1400">        crm_info(&quot;Node %s was just shot&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1401">        online = FALSE;</a>
<a name="ln1402"> </a>
<a name="ln1403">    } else if (crm_is_true(in_cluster) == FALSE) {</a>
<a name="ln1404">        pe_fence_node(data_set, this_node, &quot;because the node is no longer part of the cluster&quot;);</a>
<a name="ln1405"> </a>
<a name="ln1406">    } else if (crm_is_true(is_peer) == FALSE) {</a>
<a name="ln1407">        pe_fence_node(data_set, this_node, &quot;because our peer process is no longer available&quot;);</a>
<a name="ln1408"> </a>
<a name="ln1409">        /* Everything is running at this point, now check join state */</a>
<a name="ln1410">    } else if (do_terminate) {</a>
<a name="ln1411">        pe_fence_node(data_set, this_node, &quot;because termination was requested&quot;);</a>
<a name="ln1412"> </a>
<a name="ln1413">    } else if (safe_str_eq(join, CRMD_JOINSTATE_MEMBER)) {</a>
<a name="ln1414">        crm_info(&quot;Node %s is active&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1415"> </a>
<a name="ln1416">    } else if (safe_str_eq(join, CRMD_JOINSTATE_PENDING)</a>
<a name="ln1417">               || safe_str_eq(join, CRMD_JOINSTATE_DOWN)) {</a>
<a name="ln1418">        crm_info(&quot;Node %s is not ready to run resources&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1419">        this_node-&gt;details-&gt;standby = TRUE;</a>
<a name="ln1420">        this_node-&gt;details-&gt;pending = TRUE;</a>
<a name="ln1421"> </a>
<a name="ln1422">    } else {</a>
<a name="ln1423">        pe_fence_node(data_set, this_node, &quot;because the peer was in an unknown state&quot;);</a>
<a name="ln1424">        crm_warn(&quot;%s: in-cluster=%s, is-peer=%s, join=%s, expected=%s, term=%d, shutdown=%d&quot;,</a>
<a name="ln1425">                 this_node-&gt;details-&gt;uname, crm_str(in_cluster), crm_str(is_peer),</a>
<a name="ln1426">                 crm_str(join), crm_str(exp_state), do_terminate, this_node-&gt;details-&gt;shutdown);</a>
<a name="ln1427">    }</a>
<a name="ln1428"> </a>
<a name="ln1429">    return online;</a>
<a name="ln1430">}</a>
<a name="ln1431"> </a>
<a name="ln1432">static gboolean</a>
<a name="ln1433">determine_remote_online_status(pe_working_set_t * data_set, node_t * this_node)</a>
<a name="ln1434">{</a>
<a name="ln1435">    resource_t *rsc = this_node-&gt;details-&gt;remote_rsc;</a>
<a name="ln1436">    resource_t *container = NULL;</a>
<a name="ln1437">    pe_node_t *host = NULL;</a>
<a name="ln1438"> </a>
<a name="ln1439">    /* If there is a node state entry for a (former) Pacemaker Remote node</a>
<a name="ln1440">     * but no resource creating that node, the node's connection resource will</a>
<a name="ln1441">     * be NULL. Consider it an offline remote node in that case.</a>
<a name="ln1442">     */</a>
<a name="ln1443">    if (rsc == NULL) {</a>
<a name="ln1444">        this_node-&gt;details-&gt;online = FALSE;</a>
<a name="ln1445">        goto remote_online_done;</a>
<a name="ln1446">    }</a>
<a name="ln1447"> </a>
<a name="ln1448">    container = rsc-&gt;container;</a>
<a name="ln1449"> </a>
<a name="ln1450">    if (container &amp;&amp; (g_list_length(rsc-&gt;running_on) == 1)) {</a>
<a name="ln1451">        host = rsc-&gt;running_on-&gt;data;</a>
<a name="ln1452">    }</a>
<a name="ln1453"> </a>
<a name="ln1454">    /* If the resource is currently started, mark it online. */</a>
<a name="ln1455">    if (rsc-&gt;role == RSC_ROLE_STARTED) {</a>
<a name="ln1456">        crm_trace(&quot;%s node %s presumed ONLINE because connection resource is started&quot;,</a>
<a name="ln1457">                  (container? &quot;Guest&quot; : &quot;Remote&quot;), this_node-&gt;details-&gt;id);</a>
<a name="ln1458">        this_node-&gt;details-&gt;online = TRUE;</a>
<a name="ln1459">    }</a>
<a name="ln1460"> </a>
<a name="ln1461">    /* consider this node shutting down if transitioning start-&gt;stop */</a>
<a name="ln1462">    if (rsc-&gt;role == RSC_ROLE_STARTED &amp;&amp; rsc-&gt;next_role == RSC_ROLE_STOPPED) {</a>
<a name="ln1463">        crm_trace(&quot;%s node %s shutting down because connection resource is stopping&quot;,</a>
<a name="ln1464">                  (container? &quot;Guest&quot; : &quot;Remote&quot;), this_node-&gt;details-&gt;id);</a>
<a name="ln1465">        this_node-&gt;details-&gt;shutdown = TRUE;</a>
<a name="ln1466">    }</a>
<a name="ln1467"> </a>
<a name="ln1468">    /* Now check all the failure conditions. */</a>
<a name="ln1469">    if(container &amp;&amp; is_set(container-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln1470">        crm_trace(&quot;Guest node %s UNCLEAN because guest resource failed&quot;,</a>
<a name="ln1471">                  this_node-&gt;details-&gt;id);</a>
<a name="ln1472">        this_node-&gt;details-&gt;online = FALSE;</a>
<a name="ln1473">        this_node-&gt;details-&gt;remote_requires_reset = TRUE;</a>
<a name="ln1474"> </a>
<a name="ln1475">    } else if(is_set(rsc-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln1476">        crm_trace(&quot;%s node %s OFFLINE because connection resource failed&quot;,</a>
<a name="ln1477">                  (container? &quot;Guest&quot; : &quot;Remote&quot;), this_node-&gt;details-&gt;id);</a>
<a name="ln1478">        this_node-&gt;details-&gt;online = FALSE;</a>
<a name="ln1479"> </a>
<a name="ln1480">    } else if (rsc-&gt;role == RSC_ROLE_STOPPED</a>
<a name="ln1481">        || (container &amp;&amp; container-&gt;role == RSC_ROLE_STOPPED)) {</a>
<a name="ln1482"> </a>
<a name="ln1483">        crm_trace(&quot;%s node %s OFFLINE because its resource is stopped&quot;,</a>
<a name="ln1484">                  (container? &quot;Guest&quot; : &quot;Remote&quot;), this_node-&gt;details-&gt;id);</a>
<a name="ln1485">        this_node-&gt;details-&gt;online = FALSE;</a>
<a name="ln1486">        this_node-&gt;details-&gt;remote_requires_reset = FALSE;</a>
<a name="ln1487"> </a>
<a name="ln1488">    } else if (host &amp;&amp; (host-&gt;details-&gt;online == FALSE)</a>
<a name="ln1489">               &amp;&amp; host-&gt;details-&gt;unclean) {</a>
<a name="ln1490">        crm_trace(&quot;Guest node %s UNCLEAN because host is unclean&quot;,</a>
<a name="ln1491">                  this_node-&gt;details-&gt;id);</a>
<a name="ln1492">        this_node-&gt;details-&gt;online = FALSE;</a>
<a name="ln1493">        this_node-&gt;details-&gt;remote_requires_reset = TRUE;</a>
<a name="ln1494">    }</a>
<a name="ln1495"> </a>
<a name="ln1496">remote_online_done:</a>
<a name="ln1497">    crm_trace(&quot;Remote node %s online=%s&quot;,</a>
<a name="ln1498">        this_node-&gt;details-&gt;id, this_node-&gt;details-&gt;online ? &quot;TRUE&quot; : &quot;FALSE&quot;);</a>
<a name="ln1499">    return this_node-&gt;details-&gt;online;</a>
<a name="ln1500">}</a>
<a name="ln1501"> </a>
<a name="ln1502">gboolean</a>
<a name="ln1503">determine_online_status(xmlNode * node_state, node_t * this_node, pe_working_set_t * data_set)</a>
<a name="ln1504">{</a>
<a name="ln1505">    gboolean online = FALSE;</a>
<a name="ln1506">    const char *shutdown = NULL;</a>
<a name="ln1507">    const char *exp_state = crm_element_value(node_state, XML_NODE_EXPECTED);</a>
<a name="ln1508"> </a>
<a name="ln1509">    if (this_node == NULL) {</a>
<a name="ln1510">        crm_config_err(&quot;No node to check&quot;);</a>
<a name="ln1511">        return online;</a>
<a name="ln1512">    }</a>
<a name="ln1513"> </a>
<a name="ln1514">    this_node-&gt;details-&gt;shutdown = FALSE;</a>
<a name="ln1515">    this_node-&gt;details-&gt;expected_up = FALSE;</a>
<a name="ln1516">    shutdown = g_hash_table_lookup(this_node-&gt;details-&gt;attrs, XML_CIB_ATTR_SHUTDOWN);</a>
<a name="ln1517"> </a>
<a name="ln1518">    if (shutdown != NULL &amp;&amp; safe_str_neq(&quot;0&quot;, shutdown)) {</a>
<a name="ln1519">        this_node-&gt;details-&gt;shutdown = TRUE;</a>
<a name="ln1520"> </a>
<a name="ln1521">    } else if (safe_str_eq(exp_state, CRMD_JOINSTATE_MEMBER)) {</a>
<a name="ln1522">        this_node-&gt;details-&gt;expected_up = TRUE;</a>
<a name="ln1523">    }</a>
<a name="ln1524"> </a>
<a name="ln1525">    if (this_node-&gt;details-&gt;type == node_ping) {</a>
<a name="ln1526">        this_node-&gt;details-&gt;unclean = FALSE;</a>
<a name="ln1527">        online = FALSE;         /* As far as resource management is concerned,</a>
<a name="ln1528">                                 * the node is safely offline.</a>
<a name="ln1529">                                 * Anyone caught abusing this logic will be shot</a>
<a name="ln1530">                                 */</a>
<a name="ln1531"> </a>
<a name="ln1532">    } else if (is_set(data_set-&gt;flags, pe_flag_stonith_enabled) == FALSE) {</a>
<a name="ln1533">        online = determine_online_status_no_fencing(data_set, node_state, this_node);</a>
<a name="ln1534"> </a>
<a name="ln1535">    } else {</a>
<a name="ln1536">        online = determine_online_status_fencing(data_set, node_state, this_node);</a>
<a name="ln1537">    }</a>
<a name="ln1538"> </a>
<a name="ln1539">    if (online) {</a>
<a name="ln1540">        this_node-&gt;details-&gt;online = TRUE;</a>
<a name="ln1541"> </a>
<a name="ln1542">    } else {</a>
<a name="ln1543">        /* remove node from contention */</a>
<a name="ln1544">        this_node-&gt;fixed = TRUE;</a>
<a name="ln1545">        this_node-&gt;weight = -INFINITY;</a>
<a name="ln1546">    }</a>
<a name="ln1547"> </a>
<a name="ln1548">    if (online &amp;&amp; this_node-&gt;details-&gt;shutdown) {</a>
<a name="ln1549">        /* don't run resources here */</a>
<a name="ln1550">        this_node-&gt;fixed = TRUE;</a>
<a name="ln1551">        this_node-&gt;weight = -INFINITY;</a>
<a name="ln1552">    }</a>
<a name="ln1553"> </a>
<a name="ln1554">    if (this_node-&gt;details-&gt;type == node_ping) {</a>
<a name="ln1555">        crm_info(&quot;Node %s is not a pacemaker node&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1556"> </a>
<a name="ln1557">    } else if (this_node-&gt;details-&gt;unclean) {</a>
<a name="ln1558">        pe_proc_warn(&quot;Node %s is unclean&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1559"> </a>
<a name="ln1560">    } else if (this_node-&gt;details-&gt;online) {</a>
<a name="ln1561">        crm_info(&quot;Node %s is %s&quot;, this_node-&gt;details-&gt;uname,</a>
<a name="ln1562">                 this_node-&gt;details-&gt;shutdown ? &quot;shutting down&quot; :</a>
<a name="ln1563">                 this_node-&gt;details-&gt;pending ? &quot;pending&quot; :</a>
<a name="ln1564">                 this_node-&gt;details-&gt;standby ? &quot;standby&quot; :</a>
<a name="ln1565">                 this_node-&gt;details-&gt;maintenance ? &quot;maintenance&quot; : &quot;online&quot;);</a>
<a name="ln1566"> </a>
<a name="ln1567">    } else {</a>
<a name="ln1568">        crm_trace(&quot;Node %s is offline&quot;, this_node-&gt;details-&gt;uname);</a>
<a name="ln1569">    }</a>
<a name="ln1570"> </a>
<a name="ln1571">    return online;</a>
<a name="ln1572">}</a>
<a name="ln1573"> </a>
<a name="ln1574">char *</a>
<a name="ln1575">clone_strip(const char *last_rsc_id)</a>
<a name="ln1576">{</a>
<a name="ln1577">    int lpc = 0;</a>
<a name="ln1578">    char *zero = NULL;</a>
<a name="ln1579"> </a>
<a name="ln1580">    CRM_CHECK(last_rsc_id != NULL, return NULL);</a>
<a name="ln1581">    lpc = strlen(last_rsc_id);</a>
<a name="ln1582">    while (--lpc &gt; 0) {</a>
<a name="ln1583">        switch (last_rsc_id[lpc]) {</a>
<a name="ln1584">            case 0:</a>
<a name="ln1585">                crm_err(&quot;Empty string: %s&quot;, last_rsc_id);</a>
<a name="ln1586">                return NULL;</a>
<a name="ln1587">                break;</a>
<a name="ln1588">            case '0':</a>
<a name="ln1589">            case '1':</a>
<a name="ln1590">            case '2':</a>
<a name="ln1591">            case '3':</a>
<a name="ln1592">            case '4':</a>
<a name="ln1593">            case '5':</a>
<a name="ln1594">            case '6':</a>
<a name="ln1595">            case '7':</a>
<a name="ln1596">            case '8':</a>
<a name="ln1597">            case '9':</a>
<a name="ln1598">                break;</a>
<a name="ln1599">            case ':':</a>
<a name="ln1600">                zero = calloc(1, lpc + 1);</a>
<a name="ln1601">                memcpy(zero, last_rsc_id, lpc);</a>
<a name="ln1602">                zero[lpc] = 0;</a>
<a name="ln1603">                return zero;</a>
<a name="ln1604">            default:</a>
<a name="ln1605">                goto done;</a>
<a name="ln1606">        }</a>
<a name="ln1607">    }</a>
<a name="ln1608">  done:</a>
<a name="ln1609">    zero = strdup(last_rsc_id);</a>
<a name="ln1610">    return zero;</a>
<a name="ln1611">}</a>
<a name="ln1612"> </a>
<a name="ln1613">char *</a>
<a name="ln1614">clone_zero(const char *last_rsc_id)</a>
<a name="ln1615">{</a>
<a name="ln1616">    int lpc = 0;</a>
<a name="ln1617">    char *zero = NULL;</a>
<a name="ln1618"> </a>
<a name="ln1619">    CRM_CHECK(last_rsc_id != NULL, return NULL);</a>
<a name="ln1620">    if (last_rsc_id != NULL) {</a>
<a name="ln1621">        lpc = strlen(last_rsc_id);</a>
<a name="ln1622">    }</a>
<a name="ln1623"> </a>
<a name="ln1624">    while (--lpc &gt; 0) {</a>
<a name="ln1625">        switch (last_rsc_id[lpc]) {</a>
<a name="ln1626">            case 0:</a>
<a name="ln1627">                return NULL;</a>
<a name="ln1628">                break;</a>
<a name="ln1629">            case '0':</a>
<a name="ln1630">            case '1':</a>
<a name="ln1631">            case '2':</a>
<a name="ln1632">            case '3':</a>
<a name="ln1633">            case '4':</a>
<a name="ln1634">            case '5':</a>
<a name="ln1635">            case '6':</a>
<a name="ln1636">            case '7':</a>
<a name="ln1637">            case '8':</a>
<a name="ln1638">            case '9':</a>
<a name="ln1639">                break;</a>
<a name="ln1640">            case ':':</a>
<a name="ln1641">                zero = calloc(1, lpc + 3);</a>
<a name="ln1642">                memcpy(zero, last_rsc_id, lpc);</a>
<a name="ln1643">                zero[lpc] = ':';</a>
<a name="ln1644">                zero[lpc + 1] = '0';</a>
<a name="ln1645">                zero[lpc + 2] = 0;</a>
<a name="ln1646">                return zero;</a>
<a name="ln1647">            default:</a>
<a name="ln1648">                goto done;</a>
<a name="ln1649">        }</a>
<a name="ln1650">    }</a>
<a name="ln1651">  done:</a>
<a name="ln1652">    lpc = strlen(last_rsc_id);</a>
<a name="ln1653">    zero = calloc(1, lpc + 3);</a>
<a name="ln1654">    memcpy(zero, last_rsc_id, lpc);</a>
<a name="ln1655">    zero[lpc] = ':';</a>
<a name="ln1656">    zero[lpc + 1] = '0';</a>
<a name="ln1657">    zero[lpc + 2] = 0;</a>
<a name="ln1658">    crm_trace(&quot;%s -&gt; %s&quot;, last_rsc_id, zero);</a>
<a name="ln1659">    return zero;</a>
<a name="ln1660">}</a>
<a name="ln1661"> </a>
<a name="ln1662">static resource_t *</a>
<a name="ln1663">create_fake_resource(const char *rsc_id, xmlNode * rsc_entry, pe_working_set_t * data_set)</a>
<a name="ln1664">{</a>
<a name="ln1665">    resource_t *rsc = NULL;</a>
<a name="ln1666">    xmlNode *xml_rsc = create_xml_node(NULL, XML_CIB_TAG_RESOURCE);</a>
<a name="ln1667"> </a>
<a name="ln1668">    copy_in_properties(xml_rsc, rsc_entry);</a>
<a name="ln1669">    crm_xml_add(xml_rsc, XML_ATTR_ID, rsc_id);</a>
<a name="ln1670">    crm_log_xml_debug(xml_rsc, &quot;Orphan resource&quot;);</a>
<a name="ln1671"> </a>
<a name="ln1672">    if (!common_unpack(xml_rsc, &amp;rsc, NULL, data_set)) {</a>
<a name="ln1673">        return NULL;</a>
<a name="ln1674">    }</a>
<a name="ln1675"> </a>
<a name="ln1676">    if (xml_contains_remote_node(xml_rsc)) {</a>
<a name="ln1677">        node_t *node;</a>
<a name="ln1678"> </a>
<a name="ln1679">        crm_debug(&quot;Detected orphaned remote node %s&quot;, rsc_id);</a>
<a name="ln1680">        rsc-&gt;is_remote_node = TRUE;</a>
<a name="ln1681">        node = pe_find_node(data_set-&gt;nodes, rsc_id);</a>
<a name="ln1682">        if (node == NULL) {</a>
<a name="ln1683">	        node = pe_create_node(rsc_id, rsc_id, &quot;remote&quot;, NULL, data_set);</a>
<a name="ln1684">        }</a>
<a name="ln1685">        link_rsc2remotenode(data_set, rsc);</a>
<a name="ln1686"> </a>
<a name="ln1687">        if (node) {</a>
<a name="ln1688">            crm_trace(&quot;Setting node %s as shutting down due to orphaned connection resource&quot;, rsc_id);</a>
<a name="ln1689">            node-&gt;details-&gt;shutdown = TRUE;</a>
<a name="ln1690">        }</a>
<a name="ln1691">    }</a>
<a name="ln1692"> </a>
<a name="ln1693">    if (crm_element_value(rsc_entry, XML_RSC_ATTR_CONTAINER)) {</a>
<a name="ln1694">        /* This orphaned rsc needs to be mapped to a container. */</a>
<a name="ln1695">        crm_trace(&quot;Detected orphaned container filler %s&quot;, rsc_id);</a>
<a name="ln1696">        set_bit(rsc-&gt;flags, pe_rsc_orphan_container_filler);</a>
<a name="ln1697">    }</a>
<a name="ln1698">    set_bit(rsc-&gt;flags, pe_rsc_orphan);</a>
<a name="ln1699">    data_set-&gt;resources = g_list_append(data_set-&gt;resources, rsc);</a>
<a name="ln1700">    return rsc;</a>
<a name="ln1701">}</a>
<a name="ln1702"> </a>
<a name="ln1703">extern resource_t *create_child_clone(resource_t * rsc, int sub_id, pe_working_set_t * data_set);</a>
<a name="ln1704"> </a>
<a name="ln1705">static resource_t *</a>
<a name="ln1706">find_anonymous_clone(pe_working_set_t * data_set, node_t * node, resource_t * parent,</a>
<a name="ln1707">                     const char *rsc_id)</a>
<a name="ln1708">{</a>
<a name="ln1709">    GListPtr rIter = NULL;</a>
<a name="ln1710">    resource_t *rsc = NULL;</a>
<a name="ln1711">    gboolean skip_inactive = FALSE;</a>
<a name="ln1712"> </a>
<a name="ln1713">    CRM_ASSERT(parent != NULL);</a>
<a name="ln1714">    CRM_ASSERT(pe_rsc_is_clone(parent));</a>
<a name="ln1715">    CRM_ASSERT(is_not_set(parent-&gt;flags, pe_rsc_unique));</a>
<a name="ln1716"> </a>
<a name="ln1717">    /* Find an instance active (or partially active for grouped clones) on the specified node */</a>
<a name="ln1718">    pe_rsc_trace(parent, &quot;Looking for %s on %s in %s&quot;, rsc_id, node-&gt;details-&gt;uname, parent-&gt;id);</a>
<a name="ln1719">    for (rIter = parent-&gt;children; rsc == NULL &amp;&amp; rIter; rIter = rIter-&gt;next) {</a>
<a name="ln1720">        GListPtr nIter = NULL;</a>
<a name="ln1721">        GListPtr locations = NULL;</a>
<a name="ln1722">        resource_t *child = rIter-&gt;data;</a>
<a name="ln1723"> </a>
<a name="ln1724">        child-&gt;fns-&gt;location(child, &amp;locations, TRUE);</a>
<a name="ln1725">        if (locations == NULL) {</a>
<a name="ln1726">            pe_rsc_trace(child, &quot;Resource %s, skip inactive&quot;, child-&gt;id);</a>
<a name="ln1727">            continue;</a>
<a name="ln1728">        }</a>
<a name="ln1729"> </a>
<a name="ln1730">        for (nIter = locations; nIter &amp;&amp; rsc == NULL; nIter = nIter-&gt;next) {</a>
<a name="ln1731">            node_t *childnode = nIter-&gt;data;</a>
<a name="ln1732"> </a>
<a name="ln1733">            if (childnode-&gt;details == node-&gt;details) {</a>
<a name="ln1734">                /* -&gt;find_rsc() because we might be a cloned group */</a>
<a name="ln1735">                rsc = parent-&gt;fns-&gt;find_rsc(child, rsc_id, NULL, pe_find_clone);</a>
<a name="ln1736">                if(rsc) {</a>
<a name="ln1737">                    pe_rsc_trace(rsc, &quot;Resource %s, active&quot;, rsc-&gt;id);</a>
<a name="ln1738">                }</a>
<a name="ln1739">            }</a>
<a name="ln1740"> </a>
<a name="ln1741">            /* Keep this block, it means we'll do the right thing if</a>
<a name="ln1742">             * anyone toggles the unique flag to 'off'</a>
<a name="ln1743">             */</a>
<a name="ln1744">            if (rsc &amp;&amp; rsc-&gt;running_on) {</a>
<a name="ln1745">                crm_notice(&quot;/Anonymous/ clone %s is already running on %s&quot;,</a>
<a name="ln1746">                           parent-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln1747">                skip_inactive = TRUE;</a>
<a name="ln1748">                rsc = NULL;</a>
<a name="ln1749">            }</a>
<a name="ln1750">        }</a>
<a name="ln1751"> </a>
<a name="ln1752">        g_list_free(locations);</a>
<a name="ln1753">    }</a>
<a name="ln1754"> </a>
<a name="ln1755">    /* Find an inactive instance */</a>
<a name="ln1756">    if (skip_inactive == FALSE) {</a>
<a name="ln1757">        pe_rsc_trace(parent, &quot;Looking for %s anywhere&quot;, rsc_id);</a>
<a name="ln1758">        for (rIter = parent-&gt;children; rsc == NULL &amp;&amp; rIter; rIter = rIter-&gt;next) {</a>
<a name="ln1759">            GListPtr locations = NULL;</a>
<a name="ln1760">            resource_t *child = rIter-&gt;data;</a>
<a name="ln1761"> </a>
<a name="ln1762">            if (is_set(child-&gt;flags, pe_rsc_block)) {</a>
<a name="ln1763">                pe_rsc_trace(child, &quot;Skip: blocked in stopped state&quot;);</a>
<a name="ln1764">                continue;</a>
<a name="ln1765">            }</a>
<a name="ln1766"> </a>
<a name="ln1767">            child-&gt;fns-&gt;location(child, &amp;locations, TRUE);</a>
<a name="ln1768">            if (locations == NULL) {</a>
<a name="ln1769">                /* -&gt;find_rsc() because we might be a cloned group */</a>
<a name="ln1770">                rsc = parent-&gt;fns-&gt;find_rsc(child, rsc_id, NULL, pe_find_clone);</a>
<a name="ln1771">                pe_rsc_trace(parent, &quot;Resource %s, empty slot&quot;, rsc-&gt;id);</a>
<a name="ln1772">            }</a>
<a name="ln1773">            g_list_free(locations);</a>
<a name="ln1774">        }</a>
<a name="ln1775">    }</a>
<a name="ln1776"> </a>
<a name="ln1777">    if (rsc == NULL) {</a>
<a name="ln1778">        /* Create an extra orphan */</a>
<a name="ln1779">        resource_t *top = create_child_clone(parent, -1, data_set);</a>
<a name="ln1780"> </a>
<a name="ln1781">        /* -&gt;find_rsc() because we might be a cloned group */</a>
<a name="ln1782">        rsc = top-&gt;fns-&gt;find_rsc(top, rsc_id, NULL, pe_find_clone);</a>
<a name="ln1783">        CRM_ASSERT(rsc != NULL);</a>
<a name="ln1784"> </a>
<a name="ln1785">        pe_rsc_debug(parent, &quot;Created orphan %s for %s: %s on %s&quot;, top-&gt;id, parent-&gt;id, rsc_id,</a>
<a name="ln1786">                     node-&gt;details-&gt;uname);</a>
<a name="ln1787">    }</a>
<a name="ln1788"> </a>
<a name="ln1789">    if (safe_str_neq(rsc_id, rsc-&gt;id)) {</a>
<a name="ln1790">        pe_rsc_debug(rsc, &quot;Internally renamed %s on %s to %s%s&quot;,</a>
<a name="ln1791">                    rsc_id, node-&gt;details-&gt;uname, rsc-&gt;id,</a>
<a name="ln1792">                    is_set(rsc-&gt;flags, pe_rsc_orphan) ? &quot; (ORPHAN)&quot; : &quot;&quot;);</a>
<a name="ln1793">    }</a>
<a name="ln1794"> </a>
<a name="ln1795">    return rsc;</a>
<a name="ln1796">}</a>
<a name="ln1797"> </a>
<a name="ln1798">static resource_t *</a>
<a name="ln1799">unpack_find_resource(pe_working_set_t * data_set, node_t * node, const char *rsc_id,</a>
<a name="ln1800">                     xmlNode * rsc_entry)</a>
<a name="ln1801">{</a>
<a name="ln1802">    resource_t *rsc = NULL;</a>
<a name="ln1803">    resource_t *parent = NULL;</a>
<a name="ln1804"> </a>
<a name="ln1805">    crm_trace(&quot;looking for %s&quot;, rsc_id);</a>
<a name="ln1806">    rsc = pe_find_resource(data_set-&gt;resources, rsc_id);</a>
<a name="ln1807"> </a>
<a name="ln1808">    /* no match */</a>
<a name="ln1809">    if (rsc == NULL) {</a>
<a name="ln1810">        /* Even when clone-max=0, we still create a single :0 orphan to match against */</a>
<a name="ln1811">        char *tmp = clone_zero(rsc_id);</a>
<a name="ln1812">        resource_t *clone0 = pe_find_resource(data_set-&gt;resources, tmp);</a>
<a name="ln1813"> </a>
<a name="ln1814">        if (clone0 &amp;&amp; is_not_set(clone0-&gt;flags, pe_rsc_unique)) {</a>
<a name="ln1815">            rsc = clone0;</a>
<a name="ln1816">        } else {</a>
<a name="ln1817">            crm_trace(&quot;%s is not known as %s either&quot;, rsc_id, tmp);</a>
<a name="ln1818">        }</a>
<a name="ln1819"> </a>
<a name="ln1820">        parent = uber_parent(clone0);</a>
<a name="ln1821">        free(tmp);</a>
<a name="ln1822"> </a>
<a name="ln1823">        crm_trace(&quot;%s not found: %s&quot;, rsc_id, parent ? parent-&gt;id : &quot;orphan&quot;);</a>
<a name="ln1824"> </a>
<a name="ln1825">    } else if (rsc-&gt;variant &gt; pe_native) {</a>
<a name="ln1826">        crm_trace(&quot;%s is no longer a primitive resource, the lrm_resource entry is obsolete&quot;,</a>
<a name="ln1827">                  rsc_id);</a>
<a name="ln1828">        return NULL;</a>
<a name="ln1829"> </a>
<a name="ln1830">    } else {</a>
<a name="ln1831">        parent = uber_parent(rsc);</a>
<a name="ln1832">    }</a>
<a name="ln1833"> </a>
<a name="ln1834">    if(parent &amp;&amp; parent-&gt;parent) {</a>
<a name="ln1835">        rsc = find_container_child(rsc_id, rsc, node);</a>
<a name="ln1836"> </a>
<a name="ln1837">    } else if (pe_rsc_is_clone(parent)) {</a>
<a name="ln1838">        if (is_not_set(parent-&gt;flags, pe_rsc_unique)) {</a>
<a name="ln1839">            char *base = clone_strip(rsc_id);</a>
<a name="ln1840"> </a>
<a name="ln1841">            rsc = find_anonymous_clone(data_set, node, parent, base);</a>
<a name="ln1842">            CRM_ASSERT(rsc != NULL);</a>
<a name="ln1843">            free(base);</a>
<a name="ln1844">        }</a>
<a name="ln1845"> </a>
<a name="ln1846">        if (rsc &amp;&amp; safe_str_neq(rsc_id, rsc-&gt;id)) {</a>
<a name="ln1847">            free(rsc-&gt;clone_name);</a>
<a name="ln1848">            rsc-&gt;clone_name = strdup(rsc_id);</a>
<a name="ln1849">        }</a>
<a name="ln1850">    }</a>
<a name="ln1851"> </a>
<a name="ln1852">    return rsc;</a>
<a name="ln1853">}</a>
<a name="ln1854"> </a>
<a name="ln1855">static resource_t *</a>
<a name="ln1856">process_orphan_resource(xmlNode * rsc_entry, node_t * node, pe_working_set_t * data_set)</a>
<a name="ln1857">{</a>
<a name="ln1858">    resource_t *rsc = NULL;</a>
<a name="ln1859">    const char *rsc_id = crm_element_value(rsc_entry, XML_ATTR_ID);</a>
<a name="ln1860"> </a>
<a name="ln1861">    crm_debug(&quot;Detected orphan resource %s on %s&quot;, rsc_id, node-&gt;details-&gt;uname);</a>
<a name="ln1862">    rsc = create_fake_resource(rsc_id, rsc_entry, data_set);</a>
<a name="ln1863"> </a>
<a name="ln1864">    if (is_set(data_set-&gt;flags, pe_flag_stop_rsc_orphans) == FALSE) {</a>
<a name="ln1865">        clear_bit(rsc-&gt;flags, pe_rsc_managed);</a>
<a name="ln1866"> </a>
<a name="ln1867">    } else {</a>
<a name="ln1868">        print_resource(LOG_DEBUG_3, &quot;Added orphan&quot;, rsc, FALSE);</a>
<a name="ln1869"> </a>
<a name="ln1870">        CRM_CHECK(rsc != NULL, return NULL);</a>
<a name="ln1871">        resource_location(rsc, NULL, -INFINITY, &quot;__orphan_dont_run__&quot;, data_set);</a>
<a name="ln1872">    }</a>
<a name="ln1873">    return rsc;</a>
<a name="ln1874">}</a>
<a name="ln1875"> </a>
<a name="ln1876">static void</a>
<a name="ln1877">process_rsc_state(resource_t * rsc, node_t * node,</a>
<a name="ln1878">                  enum action_fail_response on_fail,</a>
<a name="ln1879">                  xmlNode * migrate_op, pe_working_set_t * data_set)</a>
<a name="ln1880">{</a>
<a name="ln1881">    node_t *tmpnode = NULL;</a>
<a name="ln1882">    CRM_ASSERT(rsc);</a>
<a name="ln1883">    pe_rsc_trace(rsc, &quot;Resource %s is %s on %s: on_fail=%s&quot;,</a>
<a name="ln1884">                 rsc-&gt;id, role2text(rsc-&gt;role), node-&gt;details-&gt;uname, fail2text(on_fail));</a>
<a name="ln1885"> </a>
<a name="ln1886">    /* process current state */</a>
<a name="ln1887">    if (rsc-&gt;role != RSC_ROLE_UNKNOWN) {</a>
<a name="ln1888">        resource_t *iter = rsc;</a>
<a name="ln1889"> </a>
<a name="ln1890">        while (iter) {</a>
<a name="ln1891">            if (g_hash_table_lookup(iter-&gt;known_on, node-&gt;details-&gt;id) == NULL) {</a>
<a name="ln1892">                node_t *n = node_copy(node);</a>
<a name="ln1893"> </a>
<a name="ln1894">                pe_rsc_trace(rsc, &quot;%s (aka. %s) known on %s&quot;, rsc-&gt;id, rsc-&gt;clone_name,</a>
<a name="ln1895">                             n-&gt;details-&gt;uname);</a>
<a name="ln1896">                g_hash_table_insert(iter-&gt;known_on, (gpointer) n-&gt;details-&gt;id, n);</a>
<a name="ln1897">            }</a>
<a name="ln1898">            if (is_set(iter-&gt;flags, pe_rsc_unique)) {</a>
<a name="ln1899">                break;</a>
<a name="ln1900">            }</a>
<a name="ln1901">            iter = iter-&gt;parent;</a>
<a name="ln1902">        }</a>
<a name="ln1903">    }</a>
<a name="ln1904"> </a>
<a name="ln1905">    /* If a managed resource is believed to be running, but node is down ... */</a>
<a name="ln1906">    if (rsc-&gt;role &gt; RSC_ROLE_STOPPED</a>
<a name="ln1907">        &amp;&amp; node-&gt;details-&gt;online == FALSE</a>
<a name="ln1908">        &amp;&amp; node-&gt;details-&gt;maintenance == FALSE</a>
<a name="ln1909">        &amp;&amp; is_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln1910"> </a>
<a name="ln1911">        char *reason = NULL;</a>
<a name="ln1912">        gboolean should_fence = FALSE;</a>
<a name="ln1913"> </a>
<a name="ln1914">        /* If this is a guest node, fence it (regardless of whether fencing is</a>
<a name="ln1915">         * enabled, because guest node fencing is done by recovery of the</a>
<a name="ln1916">         * container resource rather than by stonithd). Mark the resource</a>
<a name="ln1917">         * we're processing as failed. When the guest comes back up, its</a>
<a name="ln1918">         * operation history in the CIB will be cleared, freeing the affected</a>
<a name="ln1919">         * resource to run again once we are sure we know its state.</a>
<a name="ln1920">         */</a>
<a name="ln1921">        if (is_container_remote_node(node)) {</a>
<a name="ln1922">            set_bit(rsc-&gt;flags, pe_rsc_failed);</a>
<a name="ln1923">            should_fence = TRUE;</a>
<a name="ln1924"> </a>
<a name="ln1925">        } else if (is_set(data_set-&gt;flags, pe_flag_stonith_enabled)) {</a>
<a name="ln1926">            if (is_baremetal_remote_node(node) &amp;&amp; node-&gt;details-&gt;remote_rsc &amp;&amp; is_not_set(node-&gt;details-&gt;remote_rsc-&gt;flags, pe_rsc_failed)) {</a>
<a name="ln1927">                /* setting unseen = true means that fencing of the remote node will</a>
<a name="ln1928">                 * only occur if the connection resource is not going to start somewhere.</a>
<a name="ln1929">                 * This allows connection resources on a failed cluster-node to move to</a>
<a name="ln1930">                 * another node without requiring the baremetal remote nodes to be fenced</a>
<a name="ln1931">                 * as well. */</a>
<a name="ln1932">                node-&gt;details-&gt;unseen = TRUE;</a>
<a name="ln1933">                reason = crm_strdup_printf(&quot;because %s is active there. Fencing will be revoked if remote-node connection can be re-established on another cluster-node.&quot;, rsc-&gt;id);</a>
<a name="ln1934">            }</a>
<a name="ln1935">            should_fence = TRUE;</a>
<a name="ln1936">        }</a>
<a name="ln1937"> </a>
<a name="ln1938">        if (should_fence) {</a>
<a name="ln1939">            if (reason == NULL) {</a>
<a name="ln1940">               reason = crm_strdup_printf(&quot;because %s is thought to be active there&quot;, rsc-&gt;id);</a>
<a name="ln1941">            }</a>
<a name="ln1942">            pe_fence_node(data_set, node, reason);</a>
<a name="ln1943">        }</a>
<a name="ln1944">        free(reason);</a>
<a name="ln1945">    }</a>
<a name="ln1946"> </a>
<a name="ln1947">    if (node-&gt;details-&gt;unclean) {</a>
<a name="ln1948">        /* No extra processing needed</a>
<a name="ln1949">         * Also allows resources to be started again after a node is shot</a>
<a name="ln1950">         */</a>
<a name="ln1951">        on_fail = action_fail_ignore;</a>
<a name="ln1952">    }</a>
<a name="ln1953"> </a>
<a name="ln1954">    switch (on_fail) {</a>
<a name="ln1955">        case action_fail_ignore:</a>
<a name="ln1956">            /* nothing to do */</a>
<a name="ln1957">            break;</a>
<a name="ln1958"> </a>
<a name="ln1959">        case action_fail_fence:</a>
<a name="ln1960">            /* treat it as if it is still running</a>
<a name="ln1961">             * but also mark the node as unclean</a>
<a name="ln1962">             */</a>
<a name="ln1963">            pe_fence_node(data_set, node, &quot;because of resource failure(s)&quot;);</a>
<a name="ln1964">            break;</a>
<a name="ln1965"> </a>
<a name="ln1966">        case action_fail_standby:</a>
<a name="ln1967">            node-&gt;details-&gt;standby = TRUE;</a>
<a name="ln1968">            node-&gt;details-&gt;standby_onfail = TRUE;</a>
<a name="ln1969">            break;</a>
<a name="ln1970"> </a>
<a name="ln1971">        case action_fail_block:</a>
<a name="ln1972">            /* is_managed == FALSE will prevent any</a>
<a name="ln1973">             * actions being sent for the resource</a>
<a name="ln1974">             */</a>
<a name="ln1975">            clear_bit(rsc-&gt;flags, pe_rsc_managed);</a>
<a name="ln1976">            set_bit(rsc-&gt;flags, pe_rsc_block);</a>
<a name="ln1977">            break;</a>
<a name="ln1978"> </a>
<a name="ln1979">        case action_fail_migrate:</a>
<a name="ln1980">            /* make sure it comes up somewhere else</a>
<a name="ln1981">             * or not at all</a>
<a name="ln1982">             */</a>
<a name="ln1983">            resource_location(rsc, node, -INFINITY, &quot;__action_migration_auto__&quot;, data_set);</a>
<a name="ln1984">            break;</a>
<a name="ln1985"> </a>
<a name="ln1986">        case action_fail_stop:</a>
<a name="ln1987">            rsc-&gt;next_role = RSC_ROLE_STOPPED;</a>
<a name="ln1988">            break;</a>
<a name="ln1989"> </a>
<a name="ln1990">        case action_fail_recover:</a>
<a name="ln1991">            if (rsc-&gt;role != RSC_ROLE_STOPPED &amp;&amp; rsc-&gt;role != RSC_ROLE_UNKNOWN) {</a>
<a name="ln1992">                set_bit(rsc-&gt;flags, pe_rsc_failed);</a>
<a name="ln1993">                stop_action(rsc, node, FALSE);</a>
<a name="ln1994">            }</a>
<a name="ln1995">            break;</a>
<a name="ln1996"> </a>
<a name="ln1997">        case action_fail_restart_container:</a>
<a name="ln1998">            set_bit(rsc-&gt;flags, pe_rsc_failed);</a>
<a name="ln1999"> </a>
<a name="ln2000">            if (rsc-&gt;container) {</a>
<a name="ln2001">                stop_action(rsc-&gt;container, node, FALSE);</a>
<a name="ln2002">            } else if (rsc-&gt;role != RSC_ROLE_STOPPED &amp;&amp; rsc-&gt;role != RSC_ROLE_UNKNOWN) {</a>
<a name="ln2003">                stop_action(rsc, node, FALSE);</a>
<a name="ln2004">            }</a>
<a name="ln2005">            break;</a>
<a name="ln2006">        case action_fail_reset_remote:</a>
<a name="ln2007">            set_bit(rsc-&gt;flags, pe_rsc_failed);</a>
<a name="ln2008">            if (is_set(data_set-&gt;flags, pe_flag_stonith_enabled)) {</a>
<a name="ln2009">                tmpnode = NULL;</a>
<a name="ln2010">                if (rsc-&gt;is_remote_node) {</a>
<a name="ln2011">                    tmpnode = pe_find_node(data_set-&gt;nodes, rsc-&gt;id);</a>
<a name="ln2012">                }</a>
<a name="ln2013">                if (tmpnode &amp;&amp;</a>
<a name="ln2014">                    is_baremetal_remote_node(tmpnode) &amp;&amp;</a>
<a name="ln2015">                    tmpnode-&gt;details-&gt;remote_was_fenced == 0) {</a>
<a name="ln2016"> </a>
<a name="ln2017">                    /* connection resource to baremetal resource failed in a way that</a>
<a name="ln2018">                     * should result in fencing the remote-node. */</a>
<a name="ln2019">                    pe_fence_node(data_set, tmpnode, &quot;because of connection failure(s)&quot;);</a>
<a name="ln2020">                }</a>
<a name="ln2021">            }</a>
<a name="ln2022"> </a>
<a name="ln2023">            /* require the stop action regardless if fencing is occuring or not. */</a>
<a name="ln2024">            if (rsc-&gt;role &gt; RSC_ROLE_STOPPED) {</a>
<a name="ln2025">                stop_action(rsc, node, FALSE);</a>
<a name="ln2026">            }</a>
<a name="ln2027"> </a>
<a name="ln2028">            /* if reconnect delay is in use, prevent the connection from exiting the</a>
<a name="ln2029">             * &quot;STOPPED&quot; role until the failure is cleared by the delay timeout. */</a>
<a name="ln2030">            if (rsc-&gt;remote_reconnect_interval) {</a>
<a name="ln2031">                rsc-&gt;next_role = RSC_ROLE_STOPPED;</a>
<a name="ln2032">            }</a>
<a name="ln2033">            break;</a>
<a name="ln2034">    }</a>
<a name="ln2035"> </a>
<a name="ln2036">    /* ensure a remote-node connection failure forces an unclean remote-node</a>
<a name="ln2037">     * to be fenced. By setting unseen = FALSE, the remote-node failure will</a>
<a name="ln2038">     * result in a fencing operation regardless if we're going to attempt to </a>
<a name="ln2039">     * reconnect to the remote-node in this transition or not. */</a>
<a name="ln2040">    if (is_set(rsc-&gt;flags, pe_rsc_failed) &amp;&amp; rsc-&gt;is_remote_node) {</a>
<a name="ln2041">        tmpnode = pe_find_node(data_set-&gt;nodes, rsc-&gt;id);</a>
<a name="ln2042">        if (tmpnode &amp;&amp; tmpnode-&gt;details-&gt;unclean) {</a>
<a name="ln2043">            tmpnode-&gt;details-&gt;unseen = FALSE;</a>
<a name="ln2044">        }</a>
<a name="ln2045">    }</a>
<a name="ln2046"> </a>
<a name="ln2047">    if (rsc-&gt;role != RSC_ROLE_STOPPED &amp;&amp; rsc-&gt;role != RSC_ROLE_UNKNOWN) {</a>
<a name="ln2048">        if (is_set(rsc-&gt;flags, pe_rsc_orphan)) {</a>
<a name="ln2049">            if (is_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln2050">                crm_config_warn(&quot;Detected active orphan %s running on %s&quot;,</a>
<a name="ln2051">                                rsc-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln2052">            } else {</a>
<a name="ln2053">                crm_config_warn(&quot;Cluster configured not to stop active orphans.&quot;</a>
<a name="ln2054">                                &quot; %s must be stopped manually on %s&quot;,</a>
<a name="ln2055">                                rsc-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln2056">            }</a>
<a name="ln2057">        }</a>
<a name="ln2058"> </a>
<a name="ln2059">        native_add_running(rsc, node, data_set);</a>
<a name="ln2060">        if (on_fail != action_fail_ignore) {</a>
<a name="ln2061">            set_bit(rsc-&gt;flags, pe_rsc_failed);</a>
<a name="ln2062">        }</a>
<a name="ln2063"> </a>
<a name="ln2064">    } else if (rsc-&gt;clone_name &amp;&amp; strchr(rsc-&gt;clone_name, ':') != NULL) {</a>
<a name="ln2065">        /* Only do this for older status sections that included instance numbers</a>
<a name="ln2066">         * Otherwise stopped instances will appear as orphans</a>
<a name="ln2067">         */</a>
<a name="ln2068">        pe_rsc_trace(rsc, &quot;Resetting clone_name %s for %s (stopped)&quot;, rsc-&gt;clone_name, rsc-&gt;id);</a>
<a name="ln2069">        free(rsc-&gt;clone_name);</a>
<a name="ln2070">        rsc-&gt;clone_name = NULL;</a>
<a name="ln2071"> </a>
<a name="ln2072">    } else {</a>
<a name="ln2073">        char *key = stop_key(rsc);</a>
<a name="ln2074">        GListPtr possible_matches = find_actions(rsc-&gt;actions, key, node);</a>
<a name="ln2075">        GListPtr gIter = possible_matches;</a>
<a name="ln2076"> </a>
<a name="ln2077">        for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2078">            action_t *stop = (action_t *) gIter-&gt;data;</a>
<a name="ln2079"> </a>
<a name="ln2080">            stop-&gt;flags |= pe_action_optional;</a>
<a name="ln2081">        }</a>
<a name="ln2082"> </a>
<a name="ln2083">        g_list_free(possible_matches);</a>
<a name="ln2084">        free(key);</a>
<a name="ln2085">    }</a>
<a name="ln2086">}</a>
<a name="ln2087"> </a>
<a name="ln2088">/* create active recurring operations as optional */</a>
<a name="ln2089">static void</a>
<a name="ln2090">process_recurring(node_t * node, resource_t * rsc,</a>
<a name="ln2091">                  int start_index, int stop_index,</a>
<a name="ln2092">                  GListPtr sorted_op_list, pe_working_set_t * data_set)</a>
<a name="ln2093">{</a>
<a name="ln2094">    int counter = -1;</a>
<a name="ln2095">    const char *task = NULL;</a>
<a name="ln2096">    const char *status = NULL;</a>
<a name="ln2097">    GListPtr gIter = sorted_op_list;</a>
<a name="ln2098"> </a>
<a name="ln2099">    CRM_ASSERT(rsc);</a>
<a name="ln2100">    pe_rsc_trace(rsc, &quot;%s: Start index %d, stop index = %d&quot;, rsc-&gt;id, start_index, stop_index);</a>
<a name="ln2101"> </a>
<a name="ln2102">    for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2103">        xmlNode *rsc_op = (xmlNode *) gIter-&gt;data;</a>
<a name="ln2104"> </a>
<a name="ln2105">        int interval = 0;</a>
<a name="ln2106">        char *key = NULL;</a>
<a name="ln2107">        const char *id = ID(rsc_op);</a>
<a name="ln2108">        const char *interval_s = NULL;</a>
<a name="ln2109"> </a>
<a name="ln2110">        counter++;</a>
<a name="ln2111"> </a>
<a name="ln2112">        if (node-&gt;details-&gt;online == FALSE) {</a>
<a name="ln2113">            pe_rsc_trace(rsc, &quot;Skipping %s/%s: node is offline&quot;, rsc-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln2114">            break;</a>
<a name="ln2115"> </a>
<a name="ln2116">            /* Need to check if there's a monitor for role=&quot;Stopped&quot; */</a>
<a name="ln2117">        } else if (start_index &lt; stop_index &amp;&amp; counter &lt;= stop_index) {</a>
<a name="ln2118">            pe_rsc_trace(rsc, &quot;Skipping %s/%s: resource is not active&quot;, id, node-&gt;details-&gt;uname);</a>
<a name="ln2119">            continue;</a>
<a name="ln2120"> </a>
<a name="ln2121">        } else if (counter &lt; start_index) {</a>
<a name="ln2122">            pe_rsc_trace(rsc, &quot;Skipping %s/%s: old %d&quot;, id, node-&gt;details-&gt;uname, counter);</a>
<a name="ln2123">            continue;</a>
<a name="ln2124">        }</a>
<a name="ln2125"> </a>
<a name="ln2126">        interval_s = crm_element_value(rsc_op, XML_LRM_ATTR_INTERVAL);</a>
<a name="ln2127">        interval = crm_parse_int(interval_s, &quot;0&quot;);</a>
<a name="ln2128">        if (interval == 0) {</a>
<a name="ln2129">            pe_rsc_trace(rsc, &quot;Skipping %s/%s: non-recurring&quot;, id, node-&gt;details-&gt;uname);</a>
<a name="ln2130">            continue;</a>
<a name="ln2131">        }</a>
<a name="ln2132"> </a>
<a name="ln2133">        status = crm_element_value(rsc_op, XML_LRM_ATTR_OPSTATUS);</a>
<a name="ln2134">        if (safe_str_eq(status, &quot;-1&quot;)) {</a>
<a name="ln2135">            pe_rsc_trace(rsc, &quot;Skipping %s/%s: status&quot;, id, node-&gt;details-&gt;uname);</a>
<a name="ln2136">            continue;</a>
<a name="ln2137">        }</a>
<a name="ln2138">        task = crm_element_value(rsc_op, XML_LRM_ATTR_TASK);</a>
<a name="ln2139">        /* create the action */</a>
<a name="ln2140">        key = generate_op_key(rsc-&gt;id, task, interval);</a>
<a name="ln2141">        pe_rsc_trace(rsc, &quot;Creating %s/%s&quot;, key, node-&gt;details-&gt;uname);</a>
<a name="ln2142">        custom_action(rsc, key, task, node, TRUE, TRUE, data_set);</a>
<a name="ln2143">    }</a>
<a name="ln2144">}</a>
<a name="ln2145"> </a>
<a name="ln2146">void</a>
<a name="ln2147">calculate_active_ops(GListPtr sorted_op_list, int *start_index, int *stop_index)</a>
<a name="ln2148">{</a>
<a name="ln2149">    int counter = -1;</a>
<a name="ln2150">    int implied_monitor_start = -1;</a>
<a name="ln2151">    int implied_master_start = -1;</a>
<a name="ln2152">    const char *task = NULL;</a>
<a name="ln2153">    const char *status = NULL;</a>
<a name="ln2154">    GListPtr gIter = sorted_op_list;</a>
<a name="ln2155"> </a>
<a name="ln2156">    *stop_index = -1;</a>
<a name="ln2157">    *start_index = -1;</a>
<a name="ln2158"> </a>
<a name="ln2159">    for (; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2160">        xmlNode *rsc_op = (xmlNode *) gIter-&gt;data;</a>
<a name="ln2161"> </a>
<a name="ln2162">        counter++;</a>
<a name="ln2163"> </a>
<a name="ln2164">        task = crm_element_value(rsc_op, XML_LRM_ATTR_TASK);</a>
<a name="ln2165">        status = crm_element_value(rsc_op, XML_LRM_ATTR_OPSTATUS);</a>
<a name="ln2166"> </a>
<a name="ln2167">        if (safe_str_eq(task, CRMD_ACTION_STOP)</a>
<a name="ln2168">            &amp;&amp; safe_str_eq(status, &quot;0&quot;)) {</a>
<a name="ln2169">            *stop_index = counter;</a>
<a name="ln2170"> </a>
<a name="ln2171">        } else if (safe_str_eq(task, CRMD_ACTION_START) || safe_str_eq(task, CRMD_ACTION_MIGRATED)) {</a>
<a name="ln2172">            *start_index = counter;</a>
<a name="ln2173"> </a>
<a name="ln2174">        } else if ((implied_monitor_start &lt;= *stop_index) &amp;&amp; safe_str_eq(task, CRMD_ACTION_STATUS)) {</a>
<a name="ln2175">            const char *rc = crm_element_value(rsc_op, XML_LRM_ATTR_RC);</a>
<a name="ln2176"> </a>
<a name="ln2177">            if (safe_str_eq(rc, &quot;0&quot;) || safe_str_eq(rc, &quot;8&quot;)) {</a>
<a name="ln2178">                implied_monitor_start = counter;</a>
<a name="ln2179">            }</a>
<a name="ln2180">        } else if (safe_str_eq(task, CRMD_ACTION_PROMOTE) || safe_str_eq(task, CRMD_ACTION_DEMOTE)) {</a>
<a name="ln2181">            implied_master_start = counter;</a>
<a name="ln2182">        }</a>
<a name="ln2183">    }</a>
<a name="ln2184"> </a>
<a name="ln2185">    if (*start_index == -1) {</a>
<a name="ln2186">        if (implied_master_start != -1) {</a>
<a name="ln2187">            *start_index = implied_master_start;</a>
<a name="ln2188">        } else if (implied_monitor_start != -1) {</a>
<a name="ln2189">            *start_index = implied_monitor_start;</a>
<a name="ln2190">        }</a>
<a name="ln2191">    }</a>
<a name="ln2192">}</a>
<a name="ln2193"> </a>
<a name="ln2194">static resource_t *</a>
<a name="ln2195">unpack_lrm_rsc_state(node_t * node, xmlNode * rsc_entry, pe_working_set_t * data_set)</a>
<a name="ln2196">{</a>
<a name="ln2197">    GListPtr gIter = NULL;</a>
<a name="ln2198">    int stop_index = -1;</a>
<a name="ln2199">    int start_index = -1;</a>
<a name="ln2200">    enum rsc_role_e req_role = RSC_ROLE_UNKNOWN;</a>
<a name="ln2201"> </a>
<a name="ln2202">    const char *task = NULL;</a>
<a name="ln2203">    const char *rsc_id = crm_element_value(rsc_entry, XML_ATTR_ID);</a>
<a name="ln2204"> </a>
<a name="ln2205">    resource_t *rsc = NULL;</a>
<a name="ln2206">    GListPtr op_list = NULL;</a>
<a name="ln2207">    GListPtr sorted_op_list = NULL;</a>
<a name="ln2208"> </a>
<a name="ln2209">    xmlNode *migrate_op = NULL;</a>
<a name="ln2210">    xmlNode *rsc_op = NULL;</a>
<a name="ln2211">    xmlNode *last_failure = NULL;</a>
<a name="ln2212"> </a>
<a name="ln2213">    enum action_fail_response on_fail = FALSE;</a>
<a name="ln2214">    enum rsc_role_e saved_role = RSC_ROLE_UNKNOWN;</a>
<a name="ln2215"> </a>
<a name="ln2216">    crm_trace(&quot;[%s] Processing %s on %s&quot;,</a>
<a name="ln2217">              crm_element_name(rsc_entry), rsc_id, node-&gt;details-&gt;uname);</a>
<a name="ln2218"> </a>
<a name="ln2219">    /* extract operations */</a>
<a name="ln2220">    op_list = NULL;</a>
<a name="ln2221">    sorted_op_list = NULL;</a>
<a name="ln2222"> </a>
<a name="ln2223">    for (rsc_op = __xml_first_child(rsc_entry); rsc_op != NULL; rsc_op = __xml_next_element(rsc_op)) {</a>
<a name="ln2224">        if (crm_str_eq((const char *)rsc_op-&gt;name, XML_LRM_TAG_RSC_OP, TRUE)) {</a>
<a name="ln2225">            op_list = g_list_prepend(op_list, rsc_op);</a>
<a name="ln2226">        }</a>
<a name="ln2227">    }</a>
<a name="ln2228"> </a>
<a name="ln2229">    if (op_list == NULL) {</a>
<a name="ln2230">        /* if there are no operations, there is nothing to do */</a>
<a name="ln2231">        return NULL;</a>
<a name="ln2232">    }</a>
<a name="ln2233"> </a>
<a name="ln2234">    /* find the resource */</a>
<a name="ln2235">    rsc = unpack_find_resource(data_set, node, rsc_id, rsc_entry);</a>
<a name="ln2236">    if (rsc == NULL) {</a>
<a name="ln2237">        rsc = process_orphan_resource(rsc_entry, node, data_set);</a>
<a name="ln2238">    }</a>
<a name="ln2239">    CRM_ASSERT(rsc != NULL);</a>
<a name="ln2240"> </a>
<a name="ln2241">    /* process operations */</a>
<a name="ln2242">    saved_role = rsc-&gt;role;</a>
<a name="ln2243">    on_fail = action_fail_ignore;</a>
<a name="ln2244">    rsc-&gt;role = RSC_ROLE_UNKNOWN;</a>
<a name="ln2245">    sorted_op_list = g_list_sort(op_list, sort_op_by_callid);</a>
<a name="ln2246"> </a>
<a name="ln2247">    for (gIter = sorted_op_list; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2248">        xmlNode *rsc_op = (xmlNode *) gIter-&gt;data;</a>
<a name="ln2249"> </a>
<a name="ln2250">        task = crm_element_value(rsc_op, XML_LRM_ATTR_TASK);</a>
<a name="ln2251">        if (safe_str_eq(task, CRMD_ACTION_MIGRATED)) {</a>
<a name="ln2252">            migrate_op = rsc_op;</a>
<a name="ln2253">        }</a>
<a name="ln2254"> </a>
<a name="ln2255">        unpack_rsc_op(rsc, node, rsc_op, &amp;last_failure, &amp;on_fail, data_set);</a>
<a name="ln2256">    }</a>
<a name="ln2257"> </a>
<a name="ln2258">    /* create active recurring operations as optional */</a>
<a name="ln2259">    calculate_active_ops(sorted_op_list, &amp;start_index, &amp;stop_index);</a>
<a name="ln2260">    process_recurring(node, rsc, start_index, stop_index, sorted_op_list, data_set);</a>
<a name="ln2261"> </a>
<a name="ln2262">    /* no need to free the contents */</a>
<a name="ln2263">    g_list_free(sorted_op_list);</a>
<a name="ln2264"> </a>
<a name="ln2265">    process_rsc_state(rsc, node, on_fail, migrate_op, data_set);</a>
<a name="ln2266"> </a>
<a name="ln2267">    if (get_target_role(rsc, &amp;req_role)) {</a>
<a name="ln2268">        if (rsc-&gt;next_role == RSC_ROLE_UNKNOWN || req_role &lt; rsc-&gt;next_role) {</a>
<a name="ln2269">            pe_rsc_debug(rsc, &quot;%s: Overwriting calculated next role %s&quot;</a>
<a name="ln2270">                         &quot; with requested next role %s&quot;,</a>
<a name="ln2271">                         rsc-&gt;id, role2text(rsc-&gt;next_role), role2text(req_role));</a>
<a name="ln2272">            rsc-&gt;next_role = req_role;</a>
<a name="ln2273"> </a>
<a name="ln2274">        } else if (req_role &gt; rsc-&gt;next_role) {</a>
<a name="ln2275">            pe_rsc_info(rsc, &quot;%s: Not overwriting calculated next role %s&quot;</a>
<a name="ln2276">                        &quot; with requested next role %s&quot;,</a>
<a name="ln2277">                        rsc-&gt;id, role2text(rsc-&gt;next_role), role2text(req_role));</a>
<a name="ln2278">        }</a>
<a name="ln2279">    }</a>
<a name="ln2280"> </a>
<a name="ln2281">    if (saved_role &gt; rsc-&gt;role) {</a>
<a name="ln2282">        rsc-&gt;role = saved_role;</a>
<a name="ln2283">    }</a>
<a name="ln2284"> </a>
<a name="ln2285">    return rsc;</a>
<a name="ln2286">}</a>
<a name="ln2287"> </a>
<a name="ln2288">static void</a>
<a name="ln2289">handle_orphaned_container_fillers(xmlNode * lrm_rsc_list, pe_working_set_t * data_set)</a>
<a name="ln2290">{</a>
<a name="ln2291">    xmlNode *rsc_entry = NULL;</a>
<a name="ln2292">    for (rsc_entry = __xml_first_child(lrm_rsc_list); rsc_entry != NULL;</a>
<a name="ln2293">        rsc_entry = __xml_next_element(rsc_entry)) {</a>
<a name="ln2294"> </a>
<a name="ln2295">        resource_t *rsc;</a>
<a name="ln2296">        resource_t *container;</a>
<a name="ln2297">        const char *rsc_id;</a>
<a name="ln2298">        const char *container_id;</a>
<a name="ln2299"> </a>
<a name="ln2300">        if (safe_str_neq((const char *)rsc_entry-&gt;name, XML_LRM_TAG_RESOURCE)) {</a>
<a name="ln2301">            continue;</a>
<a name="ln2302">        }</a>
<a name="ln2303"> </a>
<a name="ln2304">        container_id = crm_element_value(rsc_entry, XML_RSC_ATTR_CONTAINER);</a>
<a name="ln2305">        rsc_id = crm_element_value(rsc_entry, XML_ATTR_ID);</a>
<a name="ln2306">        if (container_id == NULL || rsc_id == NULL) {</a>
<a name="ln2307">            continue;</a>
<a name="ln2308">        }</a>
<a name="ln2309"> </a>
<a name="ln2310">        container = pe_find_resource(data_set-&gt;resources, container_id);</a>
<a name="ln2311">        if (container == NULL) {</a>
<a name="ln2312">            continue;</a>
<a name="ln2313">        }</a>
<a name="ln2314"> </a>
<a name="ln2315">        rsc = pe_find_resource(data_set-&gt;resources, rsc_id);</a>
<a name="ln2316">        if (rsc == NULL ||</a>
<a name="ln2317">            is_set(rsc-&gt;flags, pe_rsc_orphan_container_filler) == FALSE ||</a>
<a name="ln2318">            rsc-&gt;container != NULL) {</a>
<a name="ln2319">            continue;</a>
<a name="ln2320">        }</a>
<a name="ln2321"> </a>
<a name="ln2322">        pe_rsc_trace(rsc, &quot;Mapped orphaned rsc %s's container to  %s&quot;, rsc-&gt;id, container_id);</a>
<a name="ln2323">        rsc-&gt;container = container;</a>
<a name="ln2324">        container-&gt;fillers = g_list_append(container-&gt;fillers, rsc);</a>
<a name="ln2325">    }</a>
<a name="ln2326">}</a>
<a name="ln2327"> </a>
<a name="ln2328">gboolean</a>
<a name="ln2329">unpack_lrm_resources(node_t * node, xmlNode * lrm_rsc_list, pe_working_set_t * data_set)</a>
<a name="ln2330">{</a>
<a name="ln2331">    xmlNode *rsc_entry = NULL;</a>
<a name="ln2332">    gboolean found_orphaned_container_filler = FALSE;</a>
<a name="ln2333">    GListPtr unexpected_containers = NULL;</a>
<a name="ln2334">    GListPtr gIter = NULL;</a>
<a name="ln2335">    resource_t *remote = NULL;</a>
<a name="ln2336"> </a>
<a name="ln2337">    CRM_CHECK(node != NULL, return FALSE);</a>
<a name="ln2338"> </a>
<a name="ln2339">    crm_trace(&quot;Unpacking resources on %s&quot;, node-&gt;details-&gt;uname);</a>
<a name="ln2340"> </a>
<a name="ln2341">    for (rsc_entry = __xml_first_child(lrm_rsc_list); rsc_entry != NULL;</a>
<a name="ln2342">         rsc_entry = __xml_next_element(rsc_entry)) {</a>
<a name="ln2343"> </a>
<a name="ln2344">        if (crm_str_eq((const char *)rsc_entry-&gt;name, XML_LRM_TAG_RESOURCE, TRUE)) {</a>
<a name="ln2345">            resource_t *rsc;</a>
<a name="ln2346">            rsc = unpack_lrm_rsc_state(node, rsc_entry, data_set);</a>
<a name="ln2347">            if (!rsc) {</a>
<a name="ln2348">                continue;</a>
<a name="ln2349">            }</a>
<a name="ln2350">            if (is_set(rsc-&gt;flags, pe_rsc_orphan_container_filler)) {</a>
<a name="ln2351">                found_orphaned_container_filler = TRUE;</a>
<a name="ln2352">            }</a>
<a name="ln2353">            if (is_set(rsc-&gt;flags, pe_rsc_unexpectedly_running)) {</a>
<a name="ln2354">                remote = rsc_contains_remote_node(data_set, rsc);</a>
<a name="ln2355">                if (remote) {</a>
<a name="ln2356">                    unexpected_containers = g_list_append(unexpected_containers, remote);</a>
<a name="ln2357">                }</a>
<a name="ln2358">            }</a>
<a name="ln2359">        }</a>
<a name="ln2360">    }</a>
<a name="ln2361"> </a>
<a name="ln2362">    /* If a container resource is unexpectedly up... and the remote-node</a>
<a name="ln2363">     * connection resource for that container is not up, the entire container</a>
<a name="ln2364">     * must be recovered. */</a>
<a name="ln2365">    for (gIter = unexpected_containers; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln2366">        remote = (resource_t *) gIter-&gt;data;</a>
<a name="ln2367">        if (remote-&gt;role != RSC_ROLE_STARTED) {</a>
<a name="ln2368">            crm_warn(&quot;Recovering container resource %s. Resource is unexpectedly running and involves a remote-node.&quot;, remote-&gt;container-&gt;id);</a>
<a name="ln2369">            set_bit(remote-&gt;container-&gt;flags, pe_rsc_failed);</a>
<a name="ln2370">        }</a>
<a name="ln2371">    }</a>
<a name="ln2372"> </a>
<a name="ln2373">    /* now that all the resource state has been unpacked for this node</a>
<a name="ln2374">     * we have to go back and map any orphaned container fillers to their</a>
<a name="ln2375">     * container resource */</a>
<a name="ln2376">    if (found_orphaned_container_filler) {</a>
<a name="ln2377">        handle_orphaned_container_fillers(lrm_rsc_list, data_set);</a>
<a name="ln2378">    }</a>
<a name="ln2379">    g_list_free(unexpected_containers);</a>
<a name="ln2380">    return TRUE;</a>
<a name="ln2381">}</a>
<a name="ln2382"> </a>
<a name="ln2383">static void</a>
<a name="ln2384">set_active(resource_t * rsc)</a>
<a name="ln2385">{</a>
<a name="ln2386">    resource_t *top = uber_parent(rsc);</a>
<a name="ln2387"> </a>
<a name="ln2388">    if (top &amp;&amp; top-&gt;variant == pe_master) {</a>
<a name="ln2389">        rsc-&gt;role = RSC_ROLE_SLAVE;</a>
<a name="ln2390">    } else {</a>
<a name="ln2391">        rsc-&gt;role = RSC_ROLE_STARTED;</a>
<a name="ln2392">    }</a>
<a name="ln2393">}</a>
<a name="ln2394"> </a>
<a name="ln2395">static void</a>
<a name="ln2396">set_node_score(gpointer key, gpointer value, gpointer user_data)</a>
<a name="ln2397">{</a>
<a name="ln2398">    node_t *node = value;</a>
<a name="ln2399">    int *score = user_data;</a>
<a name="ln2400"> </a>
<a name="ln2401">    node-&gt;weight = *score;</a>
<a name="ln2402">}</a>
<a name="ln2403"> </a>
<a name="ln2404">#define STATUS_PATH_MAX 1024</a>
<a name="ln2405">static xmlNode *</a>
<a name="ln2406">find_lrm_op(const char *resource, const char *op, const char *node, const char *source,</a>
<a name="ln2407">            pe_working_set_t * data_set)</a>
<a name="ln2408">{</a>
<a name="ln2409">    int offset = 0;</a>
<a name="ln2410">    char xpath[STATUS_PATH_MAX];</a>
<a name="ln2411"> </a>
<a name="ln2412">    offset += snprintf(xpath + offset, STATUS_PATH_MAX - offset, &quot;//node_state[@uname='%s']&quot;, node);</a>
<a name="ln2413">    offset +=</a>
<a name="ln2414">        snprintf(xpath + offset, STATUS_PATH_MAX - offset, &quot;//&quot; XML_LRM_TAG_RESOURCE &quot;[@id='%s']&quot;,</a>
<a name="ln2415">                 resource);</a>
<a name="ln2416"> </a>
<a name="ln2417">    /* Need to check against transition_magic too? */</a>
<a name="ln2418">    if (source &amp;&amp; safe_str_eq(op, CRMD_ACTION_MIGRATE)) {</a>
<a name="ln2419">        offset +=</a>
<a name="ln2420">            snprintf(xpath + offset, STATUS_PATH_MAX - offset,</a>
<a name="ln2421">                     &quot;/&quot; XML_LRM_TAG_RSC_OP &quot;[@operation='%s' and @migrate_target='%s']&quot;, op,</a>
<a name="ln2422">                     source);</a>
<a name="ln2423">    } else if (source &amp;&amp; safe_str_eq(op, CRMD_ACTION_MIGRATED)) {</a>
<a name="ln2424">        offset +=</a>
<a name="ln2425">            snprintf(xpath + offset, STATUS_PATH_MAX - offset,</a>
<a name="ln2426">                     &quot;/&quot; XML_LRM_TAG_RSC_OP &quot;[@operation='%s' and @migrate_source='%s']&quot;, op,</a>
<a name="ln2427">                     source);</a>
<a name="ln2428">    } else {</a>
<a name="ln2429">        offset +=</a>
<a name="ln2430">            snprintf(xpath + offset, STATUS_PATH_MAX - offset,</a>
<a name="ln2431">                     &quot;/&quot; XML_LRM_TAG_RSC_OP &quot;[@operation='%s']&quot;, op);</a>
<a name="ln2432">    }</a>
<a name="ln2433"> </a>
<a name="ln2434">    CRM_LOG_ASSERT(offset &gt; 0);</a>
<a name="ln2435">    return get_xpath_object(xpath, data_set-&gt;input, LOG_DEBUG);</a>
<a name="ln2436">}</a>
<a name="ln2437"> </a>
<a name="ln2438">static void</a>
<a name="ln2439">unpack_rsc_migration(resource_t *rsc, node_t *node, xmlNode *xml_op, pe_working_set_t * data_set)</a>
<a name="ln2440">{</a>
<a name="ln2441"> </a>
<a name="ln2442">    /*</a>
<a name="ln2443">     * The normal sequence is (now): migrate_to(Src) -&gt; migrate_from(Tgt) -&gt; stop(Src)</a>
<a name="ln2444">     *</a>
<a name="ln2445">     * So if a migrate_to is followed by a stop, then we don't need to care what</a>
<a name="ln2446">     * happened on the target node</a>
<a name="ln2447">     *</a>
<a name="ln2448">     * Without the stop, we need to look for a successful migrate_from.</a>
<a name="ln2449">     * This would also imply we're no longer running on the source</a>
<a name="ln2450">     *</a>
<a name="ln2451">     * Without the stop, and without a migrate_from op we make sure the resource</a>
<a name="ln2452">     * gets stopped on both source and target (assuming the target is up)</a>
<a name="ln2453">     *</a>
<a name="ln2454">     */</a>
<a name="ln2455">    int stop_id = 0;</a>
<a name="ln2456">    int task_id = 0;</a>
<a name="ln2457">    xmlNode *stop_op =</a>
<a name="ln2458">        find_lrm_op(rsc-&gt;id, CRMD_ACTION_STOP, node-&gt;details-&gt;id, NULL, data_set);</a>
<a name="ln2459"> </a>
<a name="ln2460">    if (stop_op) {</a>
<a name="ln2461">        crm_element_value_int(stop_op, XML_LRM_ATTR_CALLID, &amp;stop_id);</a>
<a name="ln2462">    }</a>
<a name="ln2463"> </a>
<a name="ln2464">    crm_element_value_int(xml_op, XML_LRM_ATTR_CALLID, &amp;task_id);</a>
<a name="ln2465"> </a>
<a name="ln2466">    if (stop_op == NULL || stop_id &lt; task_id) {</a>
<a name="ln2467">        int from_rc = 0, from_status = 0;</a>
<a name="ln2468">        const char *migrate_source =</a>
<a name="ln2469">            crm_element_value(xml_op, XML_LRM_ATTR_MIGRATE_SOURCE);</a>
<a name="ln2470">        const char *migrate_target =</a>
<a name="ln2471">            crm_element_value(xml_op, XML_LRM_ATTR_MIGRATE_TARGET);</a>
<a name="ln2472"> </a>
<a name="ln2473">        node_t *target = pe_find_node(data_set-&gt;nodes, migrate_target);</a>
<a name="ln2474">        node_t *source = pe_find_node(data_set-&gt;nodes, migrate_source);</a>
<a name="ln2475">        xmlNode *migrate_from =</a>
<a name="ln2476">            find_lrm_op(rsc-&gt;id, CRMD_ACTION_MIGRATED, migrate_target, migrate_source,</a>
<a name="ln2477">                        data_set);</a>
<a name="ln2478"> </a>
<a name="ln2479">        rsc-&gt;role = RSC_ROLE_STARTED;       /* can be master? */</a>
<a name="ln2480">        if (migrate_from) {</a>
<a name="ln2481">            crm_element_value_int(migrate_from, XML_LRM_ATTR_RC, &amp;from_rc);</a>
<a name="ln2482">            crm_element_value_int(migrate_from, XML_LRM_ATTR_OPSTATUS, &amp;from_status);</a>
<a name="ln2483">            pe_rsc_trace(rsc, &quot;%s op on %s exited with status=%d, rc=%d&quot;,</a>
<a name="ln2484">                         ID(migrate_from), migrate_target, from_status, from_rc);</a>
<a name="ln2485">        }</a>
<a name="ln2486"> </a>
<a name="ln2487">        if (migrate_from &amp;&amp; from_rc == PCMK_OCF_OK</a>
<a name="ln2488">            &amp;&amp; from_status == PCMK_LRM_OP_DONE) {</a>
<a name="ln2489">            pe_rsc_trace(rsc, &quot;Detected dangling migration op: %s on %s&quot;, ID(xml_op),</a>
<a name="ln2490">                         migrate_source);</a>
<a name="ln2491"> </a>
<a name="ln2492">            /* all good</a>
<a name="ln2493">             * just need to arrange for the stop action to get sent</a>
<a name="ln2494">             * but _without_ affecting the target somehow</a>
<a name="ln2495">             */</a>
<a name="ln2496">            rsc-&gt;role = RSC_ROLE_STOPPED;</a>
<a name="ln2497">            rsc-&gt;dangling_migrations = g_list_prepend(rsc-&gt;dangling_migrations, node);</a>
<a name="ln2498"> </a>
<a name="ln2499">        } else if (migrate_from) {  /* Failed */</a>
<a name="ln2500">            if (target &amp;&amp; target-&gt;details-&gt;online) {</a>
<a name="ln2501">                pe_rsc_trace(rsc, &quot;Marking active on %s %p %d&quot;, migrate_target, target,</a>
<a name="ln2502">                             target-&gt;details-&gt;online);</a>
<a name="ln2503">                native_add_running(rsc, target, data_set);</a>
<a name="ln2504">            }</a>
<a name="ln2505"> </a>
<a name="ln2506">        } else {    /* Pending or complete but erased */</a>
<a name="ln2507">            if (target &amp;&amp; target-&gt;details-&gt;online) {</a>
<a name="ln2508">                pe_rsc_trace(rsc, &quot;Marking active on %s %p %d&quot;, migrate_target, target,</a>
<a name="ln2509">                             target-&gt;details-&gt;online);</a>
<a name="ln2510"> </a>
<a name="ln2511">                native_add_running(rsc, target, data_set);</a>
<a name="ln2512">                if (source &amp;&amp; source-&gt;details-&gt;online) {</a>
<a name="ln2513">                    /* If we make it here we have a partial migration.  The migrate_to</a>
<a name="ln2514">                     * has completed but the migrate_from on the target has not. Hold on</a>
<a name="ln2515">                     * to the target and source on the resource. Later on if we detect that</a>
<a name="ln2516">                     * the resource is still going to run on that target, we may continue</a>
<a name="ln2517">                     * the migration */</a>
<a name="ln2518">                    rsc-&gt;partial_migration_target = target;</a>
<a name="ln2519">                    rsc-&gt;partial_migration_source = source;</a>
<a name="ln2520">                }</a>
<a name="ln2521">            } else {</a>
<a name="ln2522">                /* Consider it failed here - forces a restart, prevents migration */</a>
<a name="ln2523">                set_bit(rsc-&gt;flags, pe_rsc_failed);</a>
<a name="ln2524">                clear_bit(rsc-&gt;flags, pe_rsc_allow_migrate);</a>
<a name="ln2525">            }</a>
<a name="ln2526">        }</a>
<a name="ln2527">    }</a>
<a name="ln2528">}</a>
<a name="ln2529"> </a>
<a name="ln2530">static void</a>
<a name="ln2531">unpack_rsc_migration_failure(resource_t *rsc, node_t *node, xmlNode *xml_op, pe_working_set_t * data_set) </a>
<a name="ln2532">{</a>
<a name="ln2533">    const char *task = crm_element_value(xml_op, XML_LRM_ATTR_TASK);</a>
<a name="ln2534"> </a>
<a name="ln2535">    CRM_ASSERT(rsc);</a>
<a name="ln2536">    if (safe_str_eq(task, CRMD_ACTION_MIGRATED)) {</a>
<a name="ln2537">        int stop_id = 0;</a>
<a name="ln2538">        int migrate_id = 0;</a>
<a name="ln2539">        const char *migrate_source = crm_element_value(xml_op, XML_LRM_ATTR_MIGRATE_SOURCE);</a>
<a name="ln2540">        const char *migrate_target = crm_element_value(xml_op, XML_LRM_ATTR_MIGRATE_TARGET);</a>
<a name="ln2541"> </a>
<a name="ln2542">        xmlNode *stop_op =</a>
<a name="ln2543">            find_lrm_op(rsc-&gt;id, CRMD_ACTION_STOP, migrate_source, NULL, data_set);</a>
<a name="ln2544">        xmlNode *migrate_op =</a>
<a name="ln2545">            find_lrm_op(rsc-&gt;id, CRMD_ACTION_MIGRATE, migrate_source, migrate_target,</a>
<a name="ln2546">                        data_set);</a>
<a name="ln2547"> </a>
<a name="ln2548">        if (stop_op) {</a>
<a name="ln2549">            crm_element_value_int(stop_op, XML_LRM_ATTR_CALLID, &amp;stop_id);</a>
<a name="ln2550">        }</a>
<a name="ln2551">        if (migrate_op) {</a>
<a name="ln2552">            crm_element_value_int(migrate_op, XML_LRM_ATTR_CALLID, &amp;migrate_id);</a>
<a name="ln2553">        }</a>
<a name="ln2554"> </a>
<a name="ln2555">        /* Get our state right */</a>
<a name="ln2556">        rsc-&gt;role = RSC_ROLE_STARTED;   /* can be master? */</a>
<a name="ln2557"> </a>
<a name="ln2558">        if (stop_op == NULL || stop_id &lt; migrate_id) {</a>
<a name="ln2559">            node_t *source = pe_find_node(data_set-&gt;nodes, migrate_source);</a>
<a name="ln2560"> </a>
<a name="ln2561">            if (source &amp;&amp; source-&gt;details-&gt;online) {</a>
<a name="ln2562">                native_add_running(rsc, source, data_set);</a>
<a name="ln2563">            }</a>
<a name="ln2564">        }</a>
<a name="ln2565"> </a>
<a name="ln2566">    } else if (safe_str_eq(task, CRMD_ACTION_MIGRATE)) {</a>
<a name="ln2567">        int stop_id = 0;</a>
<a name="ln2568">        int migrate_id = 0;</a>
<a name="ln2569">        const char *migrate_source = crm_element_value(xml_op, XML_LRM_ATTR_MIGRATE_SOURCE);</a>
<a name="ln2570">        const char *migrate_target = crm_element_value(xml_op, XML_LRM_ATTR_MIGRATE_TARGET);</a>
<a name="ln2571"> </a>
<a name="ln2572">        xmlNode *stop_op =</a>
<a name="ln2573">            find_lrm_op(rsc-&gt;id, CRMD_ACTION_STOP, migrate_target, NULL, data_set);</a>
<a name="ln2574">        xmlNode *migrate_op =</a>
<a name="ln2575">            find_lrm_op(rsc-&gt;id, CRMD_ACTION_MIGRATED, migrate_target, migrate_source,</a>
<a name="ln2576">                        data_set);</a>
<a name="ln2577"> </a>
<a name="ln2578">        if (stop_op) {</a>
<a name="ln2579">            crm_element_value_int(stop_op, XML_LRM_ATTR_CALLID, &amp;stop_id);</a>
<a name="ln2580">        }</a>
<a name="ln2581">        if (migrate_op) {</a>
<a name="ln2582">            crm_element_value_int(migrate_op, XML_LRM_ATTR_CALLID, &amp;migrate_id);</a>
<a name="ln2583">        }</a>
<a name="ln2584"> </a>
<a name="ln2585">        /* Get our state right */</a>
<a name="ln2586">        rsc-&gt;role = RSC_ROLE_STARTED;   /* can be master? */</a>
<a name="ln2587"> </a>
<a name="ln2588">        if (stop_op == NULL || stop_id &lt; migrate_id) {</a>
<a name="ln2589">            node_t *target = pe_find_node(data_set-&gt;nodes, migrate_target);</a>
<a name="ln2590"> </a>
<a name="ln2591">            pe_rsc_trace(rsc, &quot;Stop: %p %d, Migrated: %p %d&quot;, stop_op, stop_id, migrate_op,</a>
<a name="ln2592">                         migrate_id);</a>
<a name="ln2593">            if (target &amp;&amp; target-&gt;details-&gt;online) {</a>
<a name="ln2594">                native_add_running(rsc, target, data_set);</a>
<a name="ln2595">            }</a>
<a name="ln2596"> </a>
<a name="ln2597">        } else if (migrate_op == NULL) {</a>
<a name="ln2598">            /* Make sure it gets cleaned up, the stop may pre-date the migrate_from */</a>
<a name="ln2599">            rsc-&gt;dangling_migrations = g_list_prepend(rsc-&gt;dangling_migrations, node);</a>
<a name="ln2600">        }</a>
<a name="ln2601">    }</a>
<a name="ln2602">}</a>
<a name="ln2603"> </a>
<a name="ln2604">static void</a>
<a name="ln2605">record_failed_op(xmlNode *op, node_t* node, pe_working_set_t * data_set)</a>
<a name="ln2606">{</a>
<a name="ln2607">    xmlNode *xIter = NULL;</a>
<a name="ln2608">    const char *op_key = crm_element_value(op, XML_LRM_ATTR_TASK_KEY);</a>
<a name="ln2609"> </a>
<a name="ln2610">    if (node-&gt;details-&gt;online == FALSE) {</a>
<a name="ln2611">        return;</a>
<a name="ln2612">    }</a>
<a name="ln2613"> </a>
<a name="ln2614">    for (xIter = data_set-&gt;failed-&gt;children; xIter; xIter = xIter-&gt;next) {</a>
<a name="ln2615">        const char *key = crm_element_value(xIter, XML_LRM_ATTR_TASK_KEY);</a>
<a name="ln2616">        const char *uname = crm_element_value(xIter, XML_ATTR_UNAME);</a>
<a name="ln2617"> </a>
<a name="ln2618">        if(safe_str_eq(op_key, key) &amp;&amp; safe_str_eq(uname, node-&gt;details-&gt;uname)) {</a>
<a name="ln2619">            crm_trace(&quot;Skipping duplicate entry %s on %s&quot;, op_key, node-&gt;details-&gt;uname);</a>
<a name="ln2620">            return;</a>
<a name="ln2621">        }</a>
<a name="ln2622">    }</a>
<a name="ln2623"> </a>
<a name="ln2624">    crm_trace(&quot;Adding entry %s on %s&quot;, op_key, node-&gt;details-&gt;uname);</a>
<a name="ln2625">    crm_xml_add(op, XML_ATTR_UNAME, node-&gt;details-&gt;uname);</a>
<a name="ln2626">    add_node_copy(data_set-&gt;failed, op);</a>
<a name="ln2627">}</a>
<a name="ln2628"> </a>
<a name="ln2629">static const char *get_op_key(xmlNode *xml_op)</a>
<a name="ln2630">{</a>
<a name="ln2631">    const char *key = crm_element_value(xml_op, XML_LRM_ATTR_TASK_KEY);</a>
<a name="ln2632">    if(key == NULL) {</a>
<a name="ln2633">        key = ID(xml_op);</a>
<a name="ln2634">    }</a>
<a name="ln2635">    return key;</a>
<a name="ln2636">}</a>
<a name="ln2637"> </a>
<a name="ln2638">static void</a>
<a name="ln2639">unpack_rsc_op_failure(resource_t * rsc, node_t * node, int rc, xmlNode * xml_op, xmlNode ** last_failure,</a>
<a name="ln2640">                      enum action_fail_response * on_fail, pe_working_set_t * data_set)</a>
<a name="ln2641">{</a>
<a name="ln2642">    int interval = 0;</a>
<a name="ln2643">    bool is_probe = FALSE;</a>
<a name="ln2644">    action_t *action = NULL;</a>
<a name="ln2645"> </a>
<a name="ln2646">    const char *key = get_op_key(xml_op);</a>
<a name="ln2647">    const char *task = crm_element_value(xml_op, XML_LRM_ATTR_TASK);</a>
<a name="ln2648">    const char *op_version = crm_element_value(xml_op, XML_ATTR_CRM_VERSION);</a>
<a name="ln2649"> </a>
<a name="ln2650">    CRM_ASSERT(rsc);</a>
<a name="ln2651"> </a>
<a name="ln2652">    *last_failure = xml_op;</a>
<a name="ln2653"> </a>
<a name="ln2654">    crm_element_value_int(xml_op, XML_LRM_ATTR_INTERVAL, &amp;interval);</a>
<a name="ln2655">    if(interval == 0 &amp;&amp; safe_str_eq(task, CRMD_ACTION_STATUS)) {</a>
<a name="ln2656">        is_probe = TRUE;</a>
<a name="ln2657">        pe_rsc_trace(rsc, &quot;is a probe: %s&quot;, key);</a>
<a name="ln2658">    }</a>
<a name="ln2659"> </a>
<a name="ln2660">    if (rc != PCMK_OCF_NOT_INSTALLED || is_set(data_set-&gt;flags, pe_flag_symmetric_cluster)) {</a>
<a name="ln2661">        crm_warn(&quot;Processing failed op %s for %s on %s: %s (%d)&quot;,</a>
<a name="ln2662">                 task, rsc-&gt;id, node-&gt;details-&gt;uname, services_ocf_exitcode_str(rc),</a>
<a name="ln2663">                 rc);</a>
<a name="ln2664"> </a>
<a name="ln2665">        record_failed_op(xml_op, node, data_set);</a>
<a name="ln2666"> </a>
<a name="ln2667">    } else {</a>
<a name="ln2668">        crm_trace(&quot;Processing failed op %s for %s on %s: %s (%d)&quot;,</a>
<a name="ln2669">                 task, rsc-&gt;id, node-&gt;details-&gt;uname, services_ocf_exitcode_str(rc),</a>
<a name="ln2670">                 rc);</a>
<a name="ln2671">    }</a>
<a name="ln2672"> </a>
<a name="ln2673">    action = custom_action(rsc, strdup(key), task, NULL, TRUE, FALSE, data_set);</a>
<a name="ln2674">    if ((action-&gt;on_fail &lt;= action_fail_fence &amp;&amp; *on_fail &lt; action-&gt;on_fail) ||</a>
<a name="ln2675">        (action-&gt;on_fail == action_fail_reset_remote &amp;&amp; *on_fail &lt;= action_fail_recover) ||</a>
<a name="ln2676">        (action-&gt;on_fail == action_fail_restart_container &amp;&amp; *on_fail &lt;= action_fail_recover) ||</a>
<a name="ln2677">        (*on_fail == action_fail_restart_container &amp;&amp; action-&gt;on_fail &gt;= action_fail_migrate)) {</a>
<a name="ln2678">        pe_rsc_trace(rsc, &quot;on-fail %s -&gt; %s for %s (%s)&quot;, fail2text(*on_fail),</a>
<a name="ln2679">                     fail2text(action-&gt;on_fail), action-&gt;uuid, key);</a>
<a name="ln2680">        *on_fail = action-&gt;on_fail;</a>
<a name="ln2681">    }</a>
<a name="ln2682"> </a>
<a name="ln2683">    if (safe_str_eq(task, CRMD_ACTION_STOP)) {</a>
<a name="ln2684">        resource_location(rsc, node, -INFINITY, &quot;__stop_fail__&quot;, data_set);</a>
<a name="ln2685"> </a>
<a name="ln2686">    } else if (safe_str_eq(task, CRMD_ACTION_MIGRATE) || safe_str_eq(task, CRMD_ACTION_MIGRATED)) {</a>
<a name="ln2687">        unpack_rsc_migration_failure(rsc, node, xml_op, data_set);</a>
<a name="ln2688"> </a>
<a name="ln2689">    } else if (safe_str_eq(task, CRMD_ACTION_PROMOTE)) {</a>
<a name="ln2690">        rsc-&gt;role = RSC_ROLE_MASTER;</a>
<a name="ln2691"> </a>
<a name="ln2692">    } else if (safe_str_eq(task, CRMD_ACTION_DEMOTE)) {</a>
<a name="ln2693">        /*</a>
<a name="ln2694">         * staying in role=master ends up putting the PE/TE into a loop</a>
<a name="ln2695">         * setting role=slave is not dangerous because no master will be</a>
<a name="ln2696">         * promoted until the failed resource has been fully stopped</a>
<a name="ln2697">         */</a>
<a name="ln2698">        if (action-&gt;on_fail == action_fail_block) {</a>
<a name="ln2699">            rsc-&gt;role = RSC_ROLE_MASTER;</a>
<a name="ln2700">            rsc-&gt;next_role = RSC_ROLE_STOPPED;</a>
<a name="ln2701"> </a>
<a name="ln2702">        } else if(rc == PCMK_OCF_NOT_RUNNING) {</a>
<a name="ln2703">            rsc-&gt;role = RSC_ROLE_STOPPED;</a>
<a name="ln2704"> </a>
<a name="ln2705">        } else {</a>
<a name="ln2706">            crm_warn(&quot;Forcing %s to stop after a failed demote action&quot;, rsc-&gt;id);</a>
<a name="ln2707">            rsc-&gt;role = RSC_ROLE_SLAVE;</a>
<a name="ln2708">            rsc-&gt;next_role = RSC_ROLE_STOPPED;</a>
<a name="ln2709">        }</a>
<a name="ln2710"> </a>
<a name="ln2711">    } else if (compare_version(&quot;2.0&quot;, op_version) &gt; 0 &amp;&amp; safe_str_eq(task, CRMD_ACTION_START)) {</a>
<a name="ln2712">        crm_warn(&quot;Compatibility handling for failed op %s on %s&quot;, key, node-&gt;details-&gt;uname);</a>
<a name="ln2713">        resource_location(rsc, node, -INFINITY, &quot;__legacy_start__&quot;, data_set);</a>
<a name="ln2714">    }</a>
<a name="ln2715"> </a>
<a name="ln2716">    if(is_probe &amp;&amp; rc == PCMK_OCF_NOT_INSTALLED) {</a>
<a name="ln2717">        /* leave stopped */</a>
<a name="ln2718">        pe_rsc_trace(rsc, &quot;Leaving %s stopped&quot;, rsc-&gt;id);</a>
<a name="ln2719">        rsc-&gt;role = RSC_ROLE_STOPPED;</a>
<a name="ln2720"> </a>
<a name="ln2721">    } else if (rsc-&gt;role &lt; RSC_ROLE_STARTED) {</a>
<a name="ln2722">        pe_rsc_trace(rsc, &quot;Setting %s active&quot;, rsc-&gt;id);</a>
<a name="ln2723">        set_active(rsc);</a>
<a name="ln2724">    }</a>
<a name="ln2725"> </a>
<a name="ln2726">    pe_rsc_trace(rsc, &quot;Resource %s: role=%s, unclean=%s, on_fail=%s, fail_role=%s&quot;,</a>
<a name="ln2727">                 rsc-&gt;id, role2text(rsc-&gt;role),</a>
<a name="ln2728">                 node-&gt;details-&gt;unclean ? &quot;true&quot; : &quot;false&quot;,</a>
<a name="ln2729">                 fail2text(action-&gt;on_fail), role2text(action-&gt;fail_role));</a>
<a name="ln2730"> </a>
<a name="ln2731">    if (action-&gt;fail_role != RSC_ROLE_STARTED &amp;&amp; rsc-&gt;next_role &lt; action-&gt;fail_role) {</a>
<a name="ln2732">        rsc-&gt;next_role = action-&gt;fail_role;</a>
<a name="ln2733">    }</a>
<a name="ln2734"> </a>
<a name="ln2735">    if (action-&gt;fail_role == RSC_ROLE_STOPPED) {</a>
<a name="ln2736">        int score = -INFINITY;</a>
<a name="ln2737"> </a>
<a name="ln2738">        resource_t *fail_rsc = rsc;</a>
<a name="ln2739"> </a>
<a name="ln2740">        if (fail_rsc-&gt;parent) {</a>
<a name="ln2741">            resource_t *parent = uber_parent(fail_rsc);</a>
<a name="ln2742"> </a>
<a name="ln2743">            if (pe_rsc_is_clone(parent)</a>
<a name="ln2744">                &amp;&amp; is_not_set(parent-&gt;flags, pe_rsc_unique)) {</a>
<a name="ln2745">                /* for clone and master resources, if a child fails on an operation</a>
<a name="ln2746">                 * with on-fail = stop, all the resources fail.  Do this by preventing</a>
<a name="ln2747">                 * the parent from coming up again. */</a>
<a name="ln2748">                fail_rsc = parent;</a>
<a name="ln2749">            }</a>
<a name="ln2750">        }</a>
<a name="ln2751">        crm_warn(&quot;Making sure %s doesn't come up again&quot;, fail_rsc-&gt;id);</a>
<a name="ln2752">        /* make sure it doesn't come up again */</a>
<a name="ln2753">        g_hash_table_destroy(fail_rsc-&gt;allowed_nodes);</a>
<a name="ln2754">        fail_rsc-&gt;allowed_nodes = node_hash_from_list(data_set-&gt;nodes);</a>
<a name="ln2755">        g_hash_table_foreach(fail_rsc-&gt;allowed_nodes, set_node_score, &amp;score);</a>
<a name="ln2756">    }</a>
<a name="ln2757"> </a>
<a name="ln2758">    pe_free_action(action);</a>
<a name="ln2759">}</a>
<a name="ln2760"> </a>
<a name="ln2761">static int</a>
<a name="ln2762">determine_op_status(</a>
<a name="ln2763">    resource_t *rsc, int rc, int target_rc, node_t * node, xmlNode * xml_op, enum action_fail_response * on_fail, pe_working_set_t * data_set) </a>
<a name="ln2764">{</a>
<a name="ln2765">    int interval = 0;</a>
<a name="ln2766">    int result = PCMK_LRM_OP_DONE;</a>
<a name="ln2767"> </a>
<a name="ln2768">    const char *key = get_op_key(xml_op);</a>
<a name="ln2769">    const char *task = crm_element_value(xml_op, XML_LRM_ATTR_TASK);</a>
<a name="ln2770"> </a>
<a name="ln2771">    bool is_probe = FALSE;</a>
<a name="ln2772"> </a>
<a name="ln2773">    CRM_ASSERT(rsc);</a>
<a name="ln2774">    crm_element_value_int(xml_op, XML_LRM_ATTR_INTERVAL, &amp;interval);</a>
<a name="ln2775">    if (interval == 0 &amp;&amp; safe_str_eq(task, CRMD_ACTION_STATUS)) {</a>
<a name="ln2776">        is_probe = TRUE;</a>
<a name="ln2777">    }</a>
<a name="ln2778"> </a>
<a name="ln2779">    if (target_rc &gt;= 0 &amp;&amp; target_rc != rc) {</a>
<a name="ln2780">        result = PCMK_LRM_OP_ERROR;</a>
<a name="ln2781">        pe_rsc_debug(rsc, &quot;%s on %s returned '%s' (%d) instead of the expected value: '%s' (%d)&quot;,</a>
<a name="ln2782">                     key, node-&gt;details-&gt;uname,</a>
<a name="ln2783">                     services_ocf_exitcode_str(rc), rc,</a>
<a name="ln2784">                     services_ocf_exitcode_str(target_rc), target_rc);</a>
<a name="ln2785">    }</a>
<a name="ln2786"> </a>
<a name="ln2787">    /* we could clean this up significantly except for old LRMs and CRMs that</a>
<a name="ln2788">     * didn't include target_rc and liked to remap status</a>
<a name="ln2789">     */</a>
<a name="ln2790">    switch (rc) {</a>
<a name="ln2791">        case PCMK_OCF_OK:</a>
<a name="ln2792">            if (is_probe &amp;&amp; target_rc == 7) {</a>
<a name="ln2793">                result = PCMK_LRM_OP_DONE;</a>
<a name="ln2794">                set_bit(rsc-&gt;flags, pe_rsc_unexpectedly_running);</a>
<a name="ln2795">                pe_rsc_info(rsc, &quot;Operation %s found resource %s active on %s&quot;,</a>
<a name="ln2796">                            task, rsc-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln2797"> </a>
<a name="ln2798">                /* legacy code for pre-0.6.5 operations */</a>
<a name="ln2799">            } else if (target_rc &lt; 0 &amp;&amp; interval &gt; 0 &amp;&amp; rsc-&gt;role == RSC_ROLE_MASTER) {</a>
<a name="ln2800">                /* catch status ops that return 0 instead of 8 while they</a>
<a name="ln2801">                 *   are supposed to be in master mode</a>
<a name="ln2802">                 */</a>
<a name="ln2803">                result = PCMK_LRM_OP_ERROR;</a>
<a name="ln2804">            }</a>
<a name="ln2805">            break;</a>
<a name="ln2806"> </a>
<a name="ln2807">        case PCMK_OCF_NOT_RUNNING:</a>
<a name="ln2808">            if (is_probe || target_rc == rc || is_not_set(rsc-&gt;flags, pe_rsc_managed)) {</a>
<a name="ln2809">                result = PCMK_LRM_OP_DONE;</a>
<a name="ln2810">                rsc-&gt;role = RSC_ROLE_STOPPED;</a>
<a name="ln2811"> </a>
<a name="ln2812">                /* clear any previous failure actions */</a>
<a name="ln2813">                *on_fail = action_fail_ignore;</a>
<a name="ln2814">                rsc-&gt;next_role = RSC_ROLE_UNKNOWN;</a>
<a name="ln2815"> </a>
<a name="ln2816">            } else if (safe_str_neq(task, CRMD_ACTION_STOP)) {</a>
<a name="ln2817">                result = PCMK_LRM_OP_ERROR;</a>
<a name="ln2818">            }</a>
<a name="ln2819">            break;</a>
<a name="ln2820"> </a>
<a name="ln2821">        case PCMK_OCF_RUNNING_MASTER:</a>
<a name="ln2822">            if (is_probe) {</a>
<a name="ln2823">                result = PCMK_LRM_OP_DONE;</a>
<a name="ln2824">                pe_rsc_info(rsc, &quot;Operation %s found resource %s active in master mode on %s&quot;,</a>
<a name="ln2825">                            task, rsc-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln2826"> </a>
<a name="ln2827">            } else if (target_rc == rc) {</a>
<a name="ln2828">                /* nothing to do */</a>
<a name="ln2829"> </a>
<a name="ln2830">            } else if (target_rc &gt;= 0) {</a>
<a name="ln2831">                result = PCMK_LRM_OP_ERROR;</a>
<a name="ln2832"> </a>
<a name="ln2833">                /* legacy code for pre-0.6.5 operations */</a>
<a name="ln2834">            } else if (safe_str_neq(task, CRMD_ACTION_STATUS)</a>
<a name="ln2835">                       || rsc-&gt;role != RSC_ROLE_MASTER) {</a>
<a name="ln2836">                result = PCMK_LRM_OP_ERROR;</a>
<a name="ln2837">                if (rsc-&gt;role != RSC_ROLE_MASTER) {</a>
<a name="ln2838">                    crm_err(&quot;%s reported %s in master mode on %s&quot;,</a>
<a name="ln2839">                            key, rsc-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln2840">                }</a>
<a name="ln2841">            }</a>
<a name="ln2842">            rsc-&gt;role = RSC_ROLE_MASTER;</a>
<a name="ln2843">            break;</a>
<a name="ln2844"> </a>
<a name="ln2845">        case PCMK_OCF_DEGRADED_MASTER:</a>
<a name="ln2846">        case PCMK_OCF_FAILED_MASTER:</a>
<a name="ln2847">            rsc-&gt;role = RSC_ROLE_MASTER;</a>
<a name="ln2848">            result = PCMK_LRM_OP_ERROR;</a>
<a name="ln2849">            break;</a>
<a name="ln2850"> </a>
<a name="ln2851">        case PCMK_OCF_NOT_CONFIGURED:</a>
<a name="ln2852">            result = PCMK_LRM_OP_ERROR_FATAL;</a>
<a name="ln2853">            break;</a>
<a name="ln2854"> </a>
<a name="ln2855">        case PCMK_OCF_NOT_INSTALLED:</a>
<a name="ln2856">        case PCMK_OCF_INVALID_PARAM:</a>
<a name="ln2857">        case PCMK_OCF_INSUFFICIENT_PRIV:</a>
<a name="ln2858">        case PCMK_OCF_UNIMPLEMENT_FEATURE:</a>
<a name="ln2859">            if (rc == PCMK_OCF_UNIMPLEMENT_FEATURE &amp;&amp; interval &gt; 0) {</a>
<a name="ln2860">                result = PCMK_LRM_OP_NOTSUPPORTED;</a>
<a name="ln2861">                break;</a>
<a name="ln2862"> </a>
<a name="ln2863">            } else if (pe_can_fence(data_set, node) == FALSE</a>
<a name="ln2864">               &amp;&amp; safe_str_eq(task, CRMD_ACTION_STOP)) {</a>
<a name="ln2865">                /* If a stop fails and we can't fence, there's nothing else we can do */</a>
<a name="ln2866">                pe_proc_err(&quot;No further recovery can be attempted for %s: %s action failed with '%s' (%d)&quot;,</a>
<a name="ln2867">                            rsc-&gt;id, task, services_ocf_exitcode_str(rc), rc);</a>
<a name="ln2868">                clear_bit(rsc-&gt;flags, pe_rsc_managed);</a>
<a name="ln2869">                set_bit(rsc-&gt;flags, pe_rsc_block);</a>
<a name="ln2870">            }</a>
<a name="ln2871">            result = PCMK_LRM_OP_ERROR_HARD;</a>
<a name="ln2872">            break;</a>
<a name="ln2873"> </a>
<a name="ln2874">        default:</a>
<a name="ln2875">            if (result == PCMK_LRM_OP_DONE) {</a>
<a name="ln2876">                crm_info(&quot;Treating %s (rc=%d) on %s as an ERROR&quot;,</a>
<a name="ln2877">                         key, rc, node-&gt;details-&gt;uname);</a>
<a name="ln2878">                result = PCMK_LRM_OP_ERROR;</a>
<a name="ln2879">            }</a>
<a name="ln2880">    }</a>
<a name="ln2881"> </a>
<a name="ln2882">    return result;</a>
<a name="ln2883">}</a>
<a name="ln2884"> </a>
<a name="ln2885">static bool check_operation_expiry(resource_t *rsc, node_t *node, int rc, xmlNode *xml_op, pe_working_set_t * data_set)</a>
<a name="ln2886">{</a>
<a name="ln2887">    bool expired = FALSE;</a>
<a name="ln2888">    time_t last_failure = 0;</a>
<a name="ln2889">    int interval = 0;</a>
<a name="ln2890">    int failure_timeout = rsc-&gt;failure_timeout;</a>
<a name="ln2891">    const char *key = get_op_key(xml_op);</a>
<a name="ln2892">    const char *task = crm_element_value(xml_op, XML_LRM_ATTR_TASK);</a>
<a name="ln2893">    const char *clear_reason = NULL;</a>
<a name="ln2894"> </a>
<a name="ln2895">    /* clearing recurring monitor operation failures automatically</a>
<a name="ln2896">     * needs to be carefully considered */</a>
<a name="ln2897">    if (safe_str_eq(crm_element_value(xml_op, XML_LRM_ATTR_TASK), &quot;monitor&quot;) &amp;&amp;</a>
<a name="ln2898">        safe_str_neq(crm_element_value(xml_op, XML_LRM_ATTR_INTERVAL), &quot;0&quot;)) {</a>
<a name="ln2899"> </a>
<a name="ln2900">        /* TODO, in the future we should consider not clearing recurring monitor</a>
<a name="ln2901">         * op failures unless the last action for a resource was a &quot;stop&quot; action.</a>
<a name="ln2902">         * otherwise it is possible that clearing the monitor failure will result</a>
<a name="ln2903">         * in the resource being in an undeterministic state.</a>
<a name="ln2904">         *</a>
<a name="ln2905">         * For now we handle this potential undeterministic condition for remote</a>
<a name="ln2906">         * node connection resources by not clearing a recurring monitor op failure</a>
<a name="ln2907">         * until after the node has been fenced. */</a>
<a name="ln2908"> </a>
<a name="ln2909">        if (is_set(data_set-&gt;flags, pe_flag_stonith_enabled) &amp;&amp;</a>
<a name="ln2910">            (rsc-&gt;remote_reconnect_interval)) {</a>
<a name="ln2911"> </a>
<a name="ln2912">            node_t *remote_node = pe_find_node(data_set-&gt;nodes, rsc-&gt;id);</a>
<a name="ln2913">            if (remote_node &amp;&amp; remote_node-&gt;details-&gt;remote_was_fenced == 0) {</a>
<a name="ln2914">                if (strstr(ID(xml_op), &quot;last_failure&quot;)) {</a>
<a name="ln2915">                    crm_info(&quot;Waiting to clear monitor failure for remote node %s until fencing has occurred&quot;, rsc-&gt;id); </a>
<a name="ln2916">                }</a>
<a name="ln2917">                /* disabling failure timeout for this operation because we believe</a>
<a name="ln2918">                 * fencing of the remote node should occur first. */ </a>
<a name="ln2919">                failure_timeout = 0;</a>
<a name="ln2920">            }</a>
<a name="ln2921">        }</a>
<a name="ln2922">    }</a>
<a name="ln2923"> </a>
<a name="ln2924">    if (failure_timeout &gt; 0) {</a>
<a name="ln2925">        int last_run = 0;</a>
<a name="ln2926"> </a>
<a name="ln2927">        if (crm_element_value_int(xml_op, XML_RSC_OP_LAST_CHANGE, &amp;last_run) == 0) {</a>
<a name="ln2928">            time_t now = get_effective_time(data_set);</a>
<a name="ln2929"> </a>
<a name="ln2930">            if (now &gt; (last_run + failure_timeout)) {</a>
<a name="ln2931">                expired = TRUE;</a>
<a name="ln2932">            }</a>
<a name="ln2933">        }</a>
<a name="ln2934">    }</a>
<a name="ln2935"> </a>
<a name="ln2936">    if (expired) {</a>
<a name="ln2937">        if (failure_timeout &gt; 0) {</a>
<a name="ln2938">            int fc = get_failcount_full(node, rsc, &amp;last_failure, FALSE, xml_op, data_set);</a>
<a name="ln2939">            if(fc) {</a>
<a name="ln2940">                if (get_failcount_full(node, rsc, &amp;last_failure, TRUE, xml_op, data_set) == 0) {</a>
<a name="ln2941">                    clear_reason = &quot;it expired&quot;;</a>
<a name="ln2942"> </a>
<a name="ln2943">                } else {</a>
<a name="ln2944">                    expired = FALSE;</a>
<a name="ln2945">                }</a>
<a name="ln2946">            } else if (rsc-&gt;remote_reconnect_interval &amp;&amp; strstr(ID(xml_op), &quot;last_failure&quot;)) {</a>
<a name="ln2947">                /* always clear last failure when reconnect interval is set */</a>
<a name="ln2948">                clear_reason = &quot;reconnect interval is set&quot;;</a>
<a name="ln2949">            }</a>
<a name="ln2950">        }</a>
<a name="ln2951"> </a>
<a name="ln2952">    } else if (strstr(ID(xml_op), &quot;last_failure&quot;) &amp;&amp;</a>
<a name="ln2953">               ((strcmp(task, &quot;start&quot;) == 0) || (strcmp(task, &quot;monitor&quot;) == 0))) {</a>
<a name="ln2954"> </a>
<a name="ln2955">        op_digest_cache_t *digest_data = NULL;</a>
<a name="ln2956"> </a>
<a name="ln2957">        digest_data = rsc_action_digest_cmp(rsc, xml_op, node, data_set);</a>
<a name="ln2958"> </a>
<a name="ln2959">        if (digest_data-&gt;rc == RSC_DIGEST_UNKNOWN) {</a>
<a name="ln2960">            crm_trace(&quot;rsc op %s/%s on node %s does not have a op digest to compare against&quot;, rsc-&gt;id,</a>
<a name="ln2961">                      key, node-&gt;details-&gt;id);</a>
<a name="ln2962">        } else if (digest_data-&gt;rc != RSC_DIGEST_MATCH) {</a>
<a name="ln2963">            clear_reason = &quot;resource parameters have changed&quot;;</a>
<a name="ln2964">        }</a>
<a name="ln2965">    }</a>
<a name="ln2966"> </a>
<a name="ln2967">    if (clear_reason != NULL) {</a>
<a name="ln2968">        char *key = generate_op_key(rsc-&gt;id, CRM_OP_CLEAR_FAILCOUNT, 0);</a>
<a name="ln2969">        action_t *clear_op = custom_action(rsc, key, CRM_OP_CLEAR_FAILCOUNT,</a>
<a name="ln2970">                                           node, FALSE, TRUE, data_set);</a>
<a name="ln2971"> </a>
<a name="ln2972">        add_hash_param(clear_op-&gt;meta, XML_ATTR_TE_NOWAIT, XML_BOOLEAN_TRUE);</a>
<a name="ln2973"> </a>
<a name="ln2974">        crm_notice(&quot;Clearing failure of %s on %s because %s &quot; CRM_XS &quot; %s&quot;,</a>
<a name="ln2975">                   rsc-&gt;id, node-&gt;details-&gt;uname, clear_reason, clear_op-&gt;uuid);</a>
<a name="ln2976">    }</a>
<a name="ln2977"> </a>
<a name="ln2978">    crm_element_value_int(xml_op, XML_LRM_ATTR_INTERVAL, &amp;interval);</a>
<a name="ln2979">    if(expired &amp;&amp; interval == 0 &amp;&amp; safe_str_eq(task, CRMD_ACTION_STATUS)) {</a>
<a name="ln2980">        switch(rc) {</a>
<a name="ln2981">            case PCMK_OCF_OK:</a>
<a name="ln2982">            case PCMK_OCF_NOT_RUNNING:</a>
<a name="ln2983">            case PCMK_OCF_RUNNING_MASTER:</a>
<a name="ln2984">            case PCMK_OCF_DEGRADED:</a>
<a name="ln2985">            case PCMK_OCF_DEGRADED_MASTER:</a>
<a name="ln2986">                /* Don't expire probes that return these values */ </a>
<a name="ln2987">                expired = FALSE;</a>
<a name="ln2988">                break;</a>
<a name="ln2989">        }</a>
<a name="ln2990">    }</a>
<a name="ln2991">    </a>
<a name="ln2992">    return expired;</a>
<a name="ln2993">}</a>
<a name="ln2994"> </a>
<a name="ln2995">int get_target_rc(xmlNode *xml_op)</a>
<a name="ln2996">{</a>
<a name="ln2997">    int dummy = 0;</a>
<a name="ln2998">    int target_rc = 0;</a>
<a name="ln2999">    char *dummy_string = NULL;</a>
<a name="ln3000">    const char *key = crm_element_value(xml_op, XML_ATTR_TRANSITION_KEY);</a>
<a name="ln3001">    if (key == NULL) {</a>
<a name="ln3002">        return -1;</a>
<a name="ln3003">    }</a>
<a name="ln3004"> </a>
<a name="ln3005">    decode_transition_key(key, &amp;dummy_string, &amp;dummy, &amp;dummy, &amp;target_rc);</a>
<a name="ln3006">    free(dummy_string);</a>
<a name="ln3007"> </a>
<a name="ln3008">    return target_rc;</a>
<a name="ln3009">}</a>
<a name="ln3010"> </a>
<a name="ln3011">static enum action_fail_response</a>
<a name="ln3012">get_action_on_fail(resource_t *rsc, const char *key, const char *task, pe_working_set_t * data_set) </a>
<a name="ln3013">{</a>
<a name="ln3014">    int result = action_fail_recover;</a>
<a name="ln3015">    action_t *action = custom_action(rsc, strdup(key), task, NULL, TRUE, FALSE, data_set);</a>
<a name="ln3016"> </a>
<a name="ln3017">    result = action-&gt;on_fail;</a>
<a name="ln3018">    pe_free_action(action);</a>
<a name="ln3019"> </a>
<a name="ln3020">    return result;</a>
<a name="ln3021">}</a>
<a name="ln3022"> </a>
<a name="ln3023">static void</a>
<a name="ln3024">update_resource_state(resource_t * rsc, node_t * node, xmlNode * xml_op, const char * task, int rc,</a>
<a name="ln3025">                      xmlNode * last_failure, enum action_fail_response * on_fail, pe_working_set_t * data_set)</a>
<a name="ln3026">{</a>
<a name="ln3027">    gboolean clear_past_failure = FALSE;</a>
<a name="ln3028"> </a>
<a name="ln3029">    CRM_ASSERT(rsc);</a>
<a name="ln3030">    CRM_ASSERT(xml_op);</a>
<a name="ln3031"> </a>
<a name="ln3032">    if (rc == PCMK_OCF_NOT_RUNNING) {</a>
<a name="ln3033">        clear_past_failure = TRUE;</a>
<a name="ln3034"> </a>
<a name="ln3035">    } else if (rc == PCMK_OCF_NOT_INSTALLED) {</a>
<a name="ln3036">        rsc-&gt;role = RSC_ROLE_STOPPED;</a>
<a name="ln3037"> </a>
<a name="ln3038">    } else if (safe_str_eq(task, CRMD_ACTION_STATUS)) {</a>
<a name="ln3039">        if (last_failure) {</a>
<a name="ln3040">            const char *op_key = get_op_key(xml_op);</a>
<a name="ln3041">            const char *last_failure_key = get_op_key(last_failure);</a>
<a name="ln3042"> </a>
<a name="ln3043">            if (safe_str_eq(op_key, last_failure_key)) {</a>
<a name="ln3044">                clear_past_failure = TRUE;</a>
<a name="ln3045">            }</a>
<a name="ln3046">        }</a>
<a name="ln3047"> </a>
<a name="ln3048">        if (rsc-&gt;role &lt; RSC_ROLE_STARTED) {</a>
<a name="ln3049">            set_active(rsc);</a>
<a name="ln3050">        }</a>
<a name="ln3051"> </a>
<a name="ln3052">    } else if (safe_str_eq(task, CRMD_ACTION_START)) {</a>
<a name="ln3053">        rsc-&gt;role = RSC_ROLE_STARTED;</a>
<a name="ln3054">        clear_past_failure = TRUE;</a>
<a name="ln3055"> </a>
<a name="ln3056">    } else if (safe_str_eq(task, CRMD_ACTION_STOP)) {</a>
<a name="ln3057">        rsc-&gt;role = RSC_ROLE_STOPPED;</a>
<a name="ln3058">        clear_past_failure = TRUE;</a>
<a name="ln3059"> </a>
<a name="ln3060">    } else if (safe_str_eq(task, CRMD_ACTION_PROMOTE)) {</a>
<a name="ln3061">        rsc-&gt;role = RSC_ROLE_MASTER;</a>
<a name="ln3062">        clear_past_failure = TRUE;</a>
<a name="ln3063"> </a>
<a name="ln3064">    } else if (safe_str_eq(task, CRMD_ACTION_DEMOTE)) {</a>
<a name="ln3065">        /* Demote from Master does not clear an error */</a>
<a name="ln3066">        rsc-&gt;role = RSC_ROLE_SLAVE;</a>
<a name="ln3067"> </a>
<a name="ln3068">    } else if (safe_str_eq(task, CRMD_ACTION_MIGRATED)) {</a>
<a name="ln3069">        rsc-&gt;role = RSC_ROLE_STARTED;</a>
<a name="ln3070">        clear_past_failure = TRUE;</a>
<a name="ln3071"> </a>
<a name="ln3072">    } else if (safe_str_eq(task, CRMD_ACTION_MIGRATE)) {</a>
<a name="ln3073">        unpack_rsc_migration(rsc, node, xml_op, data_set);</a>
<a name="ln3074"> </a>
<a name="ln3075">    } else if (rsc-&gt;role &lt; RSC_ROLE_STARTED) {</a>
<a name="ln3076">        pe_rsc_trace(rsc, &quot;%s active on %s&quot;, rsc-&gt;id, node-&gt;details-&gt;uname);</a>
<a name="ln3077">        set_active(rsc);</a>
<a name="ln3078">    }</a>
<a name="ln3079"> </a>
<a name="ln3080">    /* clear any previous failure actions */</a>
<a name="ln3081">    if (clear_past_failure) {</a>
<a name="ln3082">        switch (*on_fail) {</a>
<a name="ln3083">            case action_fail_stop:</a>
<a name="ln3084">            case action_fail_fence:</a>
<a name="ln3085">            case action_fail_migrate:</a>
<a name="ln3086">            case action_fail_standby:</a>
<a name="ln3087">                pe_rsc_trace(rsc, &quot;%s.%s is not cleared by a completed stop&quot;,</a>
<a name="ln3088">                             rsc-&gt;id, fail2text(*on_fail));</a>
<a name="ln3089">                break;</a>
<a name="ln3090"> </a>
<a name="ln3091">            case action_fail_block:</a>
<a name="ln3092">            case action_fail_ignore:</a>
<a name="ln3093">            case action_fail_recover:</a>
<a name="ln3094">            case action_fail_restart_container:</a>
<a name="ln3095">                *on_fail = action_fail_ignore;</a>
<a name="ln3096">                rsc-&gt;next_role = RSC_ROLE_UNKNOWN;</a>
<a name="ln3097">                break;</a>
<a name="ln3098">            case action_fail_reset_remote:</a>
<a name="ln3099">                if (rsc-&gt;remote_reconnect_interval == 0) {</a>
<a name="ln3100">                    /* when reconnect delay is not in use, the connection is allowed</a>
<a name="ln3101">                     * to start again after the remote node is fenced and completely</a>
<a name="ln3102">                     * stopped. Otherwise, with reconnect delay we wait for the failure</a>
<a name="ln3103">                     * to be cleared entirely before reconnected can be attempted. */ </a>
<a name="ln3104">                    *on_fail = action_fail_ignore;</a>
<a name="ln3105">                    rsc-&gt;next_role = RSC_ROLE_UNKNOWN;</a>
<a name="ln3106">                }</a>
<a name="ln3107">                break;</a>
<a name="ln3108">        }</a>
<a name="ln3109">    }</a>
<a name="ln3110">}</a>
<a name="ln3111"> </a>
<a name="ln3112"> </a>
<a name="ln3113">gboolean</a>
<a name="ln3114">unpack_rsc_op(resource_t * rsc, node_t * node, xmlNode * xml_op, xmlNode ** last_failure,</a>
<a name="ln3115">              enum action_fail_response * on_fail, pe_working_set_t * data_set)</a>
<a name="ln3116">{</a>
<a name="ln3117">    int task_id = 0;</a>
<a name="ln3118"> </a>
<a name="ln3119">    const char *key = NULL;</a>
<a name="ln3120">    const char *task = NULL;</a>
<a name="ln3121">    const char *task_key = NULL;</a>
<a name="ln3122"> </a>
<a name="ln3123">    int rc = 0;</a>
<a name="ln3124">    int status = PCMK_LRM_OP_PENDING-1;</a>
<a name="ln3125">    int target_rc = get_target_rc(xml_op);</a>
<a name="ln3126">    int interval = 0;</a>
<a name="ln3127"> </a>
<a name="ln3128">    gboolean expired = FALSE;</a>
<a name="ln3129">    resource_t *parent = rsc;</a>
<a name="ln3130">    enum action_fail_response failure_strategy = action_fail_recover;</a>
<a name="ln3131"> </a>
<a name="ln3132">    CRM_CHECK(rsc != NULL, return FALSE);</a>
<a name="ln3133">    CRM_CHECK(node != NULL, return FALSE);</a>
<a name="ln3134">    CRM_CHECK(xml_op != NULL, return FALSE);</a>
<a name="ln3135"> </a>
<a name="ln3136">    task_key = get_op_key(xml_op);</a>
<a name="ln3137"> </a>
<a name="ln3138">    task = crm_element_value(xml_op, XML_LRM_ATTR_TASK);</a>
<a name="ln3139">    key = crm_element_value(xml_op, XML_ATTR_TRANSITION_KEY);</a>
<a name="ln3140"> </a>
<a name="ln3141">    crm_element_value_int(xml_op, XML_LRM_ATTR_RC, &amp;rc);</a>
<a name="ln3142">    crm_element_value_int(xml_op, XML_LRM_ATTR_CALLID, &amp;task_id);</a>
<a name="ln3143">    crm_element_value_int(xml_op, XML_LRM_ATTR_OPSTATUS, &amp;status);</a>
<a name="ln3144">    crm_element_value_int(xml_op, XML_LRM_ATTR_INTERVAL, &amp;interval);</a>
<a name="ln3145"> </a>
<a name="ln3146">    CRM_CHECK(task != NULL, return FALSE);</a>
<a name="ln3147">    CRM_CHECK(status &lt;= PCMK_LRM_OP_NOT_INSTALLED, return FALSE);</a>
<a name="ln3148">    CRM_CHECK(status &gt;= PCMK_LRM_OP_PENDING, return FALSE);</a>
<a name="ln3149"> </a>
<a name="ln3150">    if (safe_str_eq(task, CRMD_ACTION_NOTIFY) ||</a>
<a name="ln3151">        safe_str_eq(task, CRMD_ACTION_METADATA)) {</a>
<a name="ln3152">        /* safe to ignore these */</a>
<a name="ln3153">        return TRUE;</a>
<a name="ln3154">    }</a>
<a name="ln3155"> </a>
<a name="ln3156">    if (is_not_set(rsc-&gt;flags, pe_rsc_unique)) {</a>
<a name="ln3157">        parent = uber_parent(rsc);</a>
<a name="ln3158">    }</a>
<a name="ln3159"> </a>
<a name="ln3160">    pe_rsc_trace(rsc, &quot;Unpacking task %s/%s (call_id=%d, status=%d, rc=%d) on %s (role=%s)&quot;,</a>
<a name="ln3161">                 task_key, task, task_id, status, rc, node-&gt;details-&gt;uname, role2text(rsc-&gt;role));</a>
<a name="ln3162"> </a>
<a name="ln3163">    if (node-&gt;details-&gt;unclean) {</a>
<a name="ln3164">        pe_rsc_trace(rsc, &quot;Node %s (where %s is running) is unclean.&quot;</a>
<a name="ln3165">                     &quot; Further action depends on the value of the stop's on-fail attribute&quot;,</a>
<a name="ln3166">                     node-&gt;details-&gt;uname, rsc-&gt;id);</a>
<a name="ln3167">    }</a>
<a name="ln3168"> </a>
<a name="ln3169">    if (status == PCMK_LRM_OP_ERROR) {</a>
<a name="ln3170">        /* Older versions set this if rc != 0 but it's up to us to decide */</a>
<a name="ln3171">        status = PCMK_LRM_OP_DONE;</a>
<a name="ln3172">    }</a>
<a name="ln3173"> </a>
<a name="ln3174">    if(status != PCMK_LRM_OP_NOT_INSTALLED) {</a>
<a name="ln3175">        expired = check_operation_expiry(rsc, node, rc, xml_op, data_set);</a>
<a name="ln3176">    }</a>
<a name="ln3177"> </a>
<a name="ln3178">    /* Degraded results are informational only, re-map them to their error-free equivalents */</a>
<a name="ln3179">    if (rc == PCMK_OCF_DEGRADED &amp;&amp; safe_str_eq(task, CRMD_ACTION_STATUS)) {</a>
<a name="ln3180">        rc = PCMK_OCF_OK;</a>
<a name="ln3181"> </a>
<a name="ln3182">        /* Add them to the failed list to highlight them for the user */</a>
<a name="ln3183">        if ((node-&gt;details-&gt;shutdown == FALSE) || (node-&gt;details-&gt;online == TRUE)) {</a>
<a name="ln3184">            crm_trace(&quot;Remapping %d to %d&quot;, PCMK_OCF_DEGRADED, PCMK_OCF_OK);</a>
<a name="ln3185">            record_failed_op(xml_op, node, data_set);</a>
<a name="ln3186">        }</a>
<a name="ln3187"> </a>
<a name="ln3188">    } else if (rc == PCMK_OCF_DEGRADED_MASTER &amp;&amp; safe_str_eq(task, CRMD_ACTION_STATUS)) {</a>
<a name="ln3189">        rc = PCMK_OCF_RUNNING_MASTER;</a>
<a name="ln3190"> </a>
<a name="ln3191">        /* Add them to the failed list to highlight them for the user */</a>
<a name="ln3192">        if ((node-&gt;details-&gt;shutdown == FALSE) || (node-&gt;details-&gt;online == TRUE)) {</a>
<a name="ln3193">            crm_trace(&quot;Remapping %d to %d&quot;, PCMK_OCF_DEGRADED_MASTER, PCMK_OCF_RUNNING_MASTER);</a>
<a name="ln3194">            record_failed_op(xml_op, node, data_set);</a>
<a name="ln3195">        }</a>
<a name="ln3196">    }</a>
<a name="ln3197"> </a>
<a name="ln3198">    if (expired &amp;&amp; target_rc != rc) {</a>
<a name="ln3199">        const char *magic = crm_element_value(xml_op, XML_ATTR_TRANSITION_MAGIC);</a>
<a name="ln3200"> </a>
<a name="ln3201">        pe_rsc_debug(rsc, &quot;Expired operation '%s' on %s returned '%s' (%d) instead of the expected value: '%s' (%d)&quot;,</a>
<a name="ln3202">                     key, node-&gt;details-&gt;uname,</a>
<a name="ln3203">                     services_ocf_exitcode_str(rc), rc,</a>
<a name="ln3204">                     services_ocf_exitcode_str(target_rc), target_rc);</a>
<a name="ln3205"> </a>
<a name="ln3206">        if(interval == 0) {</a>
<a name="ln3207">            crm_notice(&quot;Ignoring expired calculated failure %s (rc=%d, magic=%s) on %s&quot;,</a>
<a name="ln3208">                       task_key, rc, magic, node-&gt;details-&gt;uname);</a>
<a name="ln3209">            goto done;</a>
<a name="ln3210"> </a>
<a name="ln3211">        } else if(node-&gt;details-&gt;online &amp;&amp; node-&gt;details-&gt;unclean == FALSE) {</a>
<a name="ln3212">            crm_notice(&quot;Re-initiated expired calculated failure %s (rc=%d, magic=%s) on %s&quot;,</a>
<a name="ln3213">                       task_key, rc, magic, node-&gt;details-&gt;uname);</a>
<a name="ln3214">            /* This is SO horrible, but we don't have access to CancelXmlOp() yet */</a>
<a name="ln3215">            crm_xml_add(xml_op, XML_LRM_ATTR_RESTART_DIGEST, &quot;calculated-failure-timeout&quot;);</a>
<a name="ln3216">            goto done;</a>
<a name="ln3217">        }</a>
<a name="ln3218">    }</a>
<a name="ln3219"> </a>
<a name="ln3220">    if(status == PCMK_LRM_OP_DONE || status == PCMK_LRM_OP_ERROR) {</a>
<a name="ln3221">        status = determine_op_status(rsc, rc, target_rc, node, xml_op, on_fail, data_set);</a>
<a name="ln3222">    }</a>
<a name="ln3223"> </a>
<a name="ln3224">    pe_rsc_trace(rsc, &quot;Handling status: %d&quot;, status);</a>
<a name="ln3225">    switch (status) {</a>
<a name="ln3226">        case PCMK_LRM_OP_CANCELLED:</a>
<a name="ln3227">            /* do nothing?? */</a>
<a name="ln3228">            pe_err(&quot;Don't know what to do for cancelled ops yet&quot;);</a>
<a name="ln3229">            break;</a>
<a name="ln3230"> </a>
<a name="ln3231">        case PCMK_LRM_OP_PENDING:</a>
<a name="ln3232">            if (safe_str_eq(task, CRMD_ACTION_START)) {</a>
<a name="ln3233">                set_bit(rsc-&gt;flags, pe_rsc_start_pending);</a>
<a name="ln3234">                set_active(rsc);</a>
<a name="ln3235"> </a>
<a name="ln3236">            } else if (safe_str_eq(task, CRMD_ACTION_PROMOTE)) {</a>
<a name="ln3237">                rsc-&gt;role = RSC_ROLE_MASTER;</a>
<a name="ln3238"> </a>
<a name="ln3239">            } else if (safe_str_eq(task, CRMD_ACTION_MIGRATE) &amp;&amp; node-&gt;details-&gt;unclean) {</a>
<a name="ln3240">                /* If a pending migrate_to action is out on a unclean node,</a>
<a name="ln3241">                 * we have to force the stop action on the target. */</a>
<a name="ln3242">                const char *migrate_target = crm_element_value(xml_op, XML_LRM_ATTR_MIGRATE_TARGET);</a>
<a name="ln3243">                node_t *target = pe_find_node(data_set-&gt;nodes, migrate_target);</a>
<a name="ln3244">                if (target) {</a>
<a name="ln3245">                    stop_action(rsc, target, FALSE);</a>
<a name="ln3246">                }</a>
<a name="ln3247">            }</a>
<a name="ln3248"> </a>
<a name="ln3249">            if (rsc-&gt;pending_task == NULL) {</a>
<a name="ln3250">                if (safe_str_eq(task, CRMD_ACTION_STATUS) &amp;&amp; interval == 0) {</a>
<a name="ln3251">                    /* Pending probes are not printed, even if pending</a>
<a name="ln3252">                     * operations are requested. If someone ever requests that</a>
<a name="ln3253">                     * behavior, uncomment this and the corresponding part of</a>
<a name="ln3254">                     * native.c:native_pending_task().</a>
<a name="ln3255">                     */</a>
<a name="ln3256">                    /*rsc-&gt;pending_task = strdup(&quot;probe&quot;);*/</a>
<a name="ln3257"> </a>
<a name="ln3258">                } else {</a>
<a name="ln3259">                    rsc-&gt;pending_task = strdup(task);</a>
<a name="ln3260">                }</a>
<a name="ln3261">            }</a>
<a name="ln3262">            break;</a>
<a name="ln3263"> </a>
<a name="ln3264">        case PCMK_LRM_OP_DONE:</a>
<a name="ln3265">            pe_rsc_trace(rsc, &quot;%s/%s completed on %s&quot;, rsc-&gt;id, task, node-&gt;details-&gt;uname);</a>
<a name="ln3266">            update_resource_state(rsc, node, xml_op, task, rc, *last_failure, on_fail, data_set);</a>
<a name="ln3267">            break;</a>
<a name="ln3268"> </a>
<a name="ln3269">        case PCMK_LRM_OP_NOT_INSTALLED:</a>
<a name="ln3270">            failure_strategy = get_action_on_fail(rsc, task_key, task, data_set);</a>
<a name="ln3271">            if (failure_strategy == action_fail_ignore) {</a>
<a name="ln3272">                crm_warn(&quot;Cannot ignore failed %s (status=%d, rc=%d) on %s: &quot;</a>
<a name="ln3273">                         &quot;Resource agent doesn't exist&quot;,</a>
<a name="ln3274">                         task_key, status, rc, node-&gt;details-&gt;uname);</a>
<a name="ln3275">                /* Also for printing it as &quot;FAILED&quot; by marking it as pe_rsc_failed later */</a>
<a name="ln3276">                *on_fail = action_fail_migrate;</a>
<a name="ln3277">            }</a>
<a name="ln3278">            resource_location(parent, node, -INFINITY, &quot;hard-error&quot;, data_set);</a>
<a name="ln3279">            unpack_rsc_op_failure(rsc, node, rc, xml_op, last_failure, on_fail, data_set);</a>
<a name="ln3280">            break;</a>
<a name="ln3281"> </a>
<a name="ln3282">        case PCMK_LRM_OP_ERROR:</a>
<a name="ln3283">        case PCMK_LRM_OP_ERROR_HARD:</a>
<a name="ln3284">        case PCMK_LRM_OP_ERROR_FATAL:</a>
<a name="ln3285">        case PCMK_LRM_OP_TIMEOUT:</a>
<a name="ln3286">        case PCMK_LRM_OP_NOTSUPPORTED:</a>
<a name="ln3287"> </a>
<a name="ln3288">            failure_strategy = get_action_on_fail(rsc, task_key, task, data_set);</a>
<a name="ln3289">            if ((failure_strategy == action_fail_ignore)</a>
<a name="ln3290">                || (failure_strategy == action_fail_restart_container</a>
<a name="ln3291">                    &amp;&amp; safe_str_eq(task, CRMD_ACTION_STOP))) {</a>
<a name="ln3292"> </a>
<a name="ln3293">                crm_warn(&quot;Pretending the failure of %s (rc=%d) on %s succeeded&quot;,</a>
<a name="ln3294">                         task_key, rc, node-&gt;details-&gt;uname);</a>
<a name="ln3295"> </a>
<a name="ln3296">                update_resource_state(rsc, node, xml_op, task, target_rc, *last_failure, on_fail, data_set);</a>
<a name="ln3297">                crm_xml_add(xml_op, XML_ATTR_UNAME, node-&gt;details-&gt;uname);</a>
<a name="ln3298">                set_bit(rsc-&gt;flags, pe_rsc_failure_ignored);</a>
<a name="ln3299"> </a>
<a name="ln3300">                record_failed_op(xml_op, node, data_set);</a>
<a name="ln3301"> </a>
<a name="ln3302">                if (failure_strategy == action_fail_restart_container &amp;&amp; *on_fail &lt;= action_fail_recover) {</a>
<a name="ln3303">                    *on_fail = failure_strategy;</a>
<a name="ln3304">                }</a>
<a name="ln3305"> </a>
<a name="ln3306">            } else {</a>
<a name="ln3307">                unpack_rsc_op_failure(rsc, node, rc, xml_op, last_failure, on_fail, data_set);</a>
<a name="ln3308"> </a>
<a name="ln3309">                if(status == PCMK_LRM_OP_ERROR_HARD) {</a>
<a name="ln3310">                    do_crm_log(rc != PCMK_OCF_NOT_INSTALLED?LOG_ERR:LOG_NOTICE,</a>
<a name="ln3311">                               &quot;Preventing %s from re-starting on %s: operation %s failed '%s' (%d)&quot;,</a>
<a name="ln3312">                               parent-&gt;id, node-&gt;details-&gt;uname,</a>
<a name="ln3313">                               task, services_ocf_exitcode_str(rc), rc);</a>
<a name="ln3314"> </a>
<a name="ln3315">                    resource_location(parent, node, -INFINITY, &quot;hard-error&quot;, data_set);</a>
<a name="ln3316"> </a>
<a name="ln3317">                } else if(status == PCMK_LRM_OP_ERROR_FATAL) {</a>
<a name="ln3318">                    crm_err(&quot;Preventing %s from re-starting anywhere: operation %s failed '%s' (%d)&quot;,</a>
<a name="ln3319">                            parent-&gt;id, task, services_ocf_exitcode_str(rc), rc);</a>
<a name="ln3320"> </a>
<a name="ln3321">                    resource_location(parent, NULL, -INFINITY, &quot;fatal-error&quot;, data_set);</a>
<a name="ln3322">                }</a>
<a name="ln3323">            }</a>
<a name="ln3324">            break;</a>
<a name="ln3325">    }</a>
<a name="ln3326"> </a>
<a name="ln3327">  done:</a>
<a name="ln3328">    pe_rsc_trace(rsc, &quot;Resource %s after %s: role=%s, next=%s&quot;, rsc-&gt;id, task, role2text(rsc-&gt;role), role2text(rsc-&gt;next_role));</a>
<a name="ln3329">    return TRUE;</a>
<a name="ln3330">}</a>
<a name="ln3331"> </a>
<a name="ln3332">gboolean</a>
<a name="ln3333">add_node_attrs(xmlNode * xml_obj, node_t * node, gboolean overwrite, pe_working_set_t * data_set)</a>
<a name="ln3334">{</a>
<a name="ln3335">    const char *cluster_name = NULL;</a>
<a name="ln3336"> </a>
<a name="ln3337">    g_hash_table_insert(node-&gt;details-&gt;attrs,</a>
<a name="ln3338">                        strdup(&quot;#uname&quot;), strdup(node-&gt;details-&gt;uname));</a>
<a name="ln3339"> </a>
<a name="ln3340">    g_hash_table_insert(node-&gt;details-&gt;attrs, strdup(&quot;#&quot; XML_ATTR_ID), strdup(node-&gt;details-&gt;id));</a>
<a name="ln3341">    if (safe_str_eq(node-&gt;details-&gt;id, data_set-&gt;dc_uuid)) {</a>
<a name="ln3342">        data_set-&gt;dc_node = node;</a>
<a name="ln3343">        node-&gt;details-&gt;is_dc = TRUE;</a>
<a name="ln3344">        g_hash_table_insert(node-&gt;details-&gt;attrs,</a>
<a name="ln3345">                            strdup(&quot;#&quot; XML_ATTR_DC), strdup(XML_BOOLEAN_TRUE));</a>
<a name="ln3346">    } else {</a>
<a name="ln3347">        g_hash_table_insert(node-&gt;details-&gt;attrs,</a>
<a name="ln3348">                            strdup(&quot;#&quot; XML_ATTR_DC), strdup(XML_BOOLEAN_FALSE));</a>
<a name="ln3349">    }</a>
<a name="ln3350"> </a>
<a name="ln3351">    cluster_name = g_hash_table_lookup(data_set-&gt;config_hash, &quot;cluster-name&quot;);</a>
<a name="ln3352">    if (cluster_name) {</a>
<a name="ln3353">        g_hash_table_insert(node-&gt;details-&gt;attrs, strdup(&quot;#cluster-name&quot;), strdup(cluster_name));</a>
<a name="ln3354">    }</a>
<a name="ln3355"> </a>
<a name="ln3356">    unpack_instance_attributes(data_set-&gt;input, xml_obj, XML_TAG_ATTR_SETS, NULL,</a>
<a name="ln3357">                               node-&gt;details-&gt;attrs, NULL, overwrite, data_set-&gt;now);</a>
<a name="ln3358"> </a>
<a name="ln3359">    if (g_hash_table_lookup(node-&gt;details-&gt;attrs, &quot;#site-name&quot;) == NULL) {</a>
<a name="ln3360">        const char *site_name = g_hash_table_lookup(node-&gt;details-&gt;attrs, &quot;site-name&quot;);</a>
<a name="ln3361"> </a>
<a name="ln3362">        if (site_name) {</a>
<a name="ln3363">            /* Prefix '#' to the key */</a>
<a name="ln3364">            g_hash_table_insert(node-&gt;details-&gt;attrs, strdup(&quot;#site-name&quot;), strdup(site_name));</a>
<a name="ln3365"> </a>
<a name="ln3366">        } else if (cluster_name) {</a>
<a name="ln3367">            /* Default to cluster-name if unset */</a>
<a name="ln3368">            g_hash_table_insert(node-&gt;details-&gt;attrs, strdup(&quot;#site-name&quot;), strdup(cluster_name));</a>
<a name="ln3369">        }</a>
<a name="ln3370">    }</a>
<a name="ln3371">    return TRUE;</a>
<a name="ln3372">}</a>
<a name="ln3373"> </a>
<a name="ln3374">static GListPtr</a>
<a name="ln3375">extract_operations(const char *node, const char *rsc, xmlNode * rsc_entry, gboolean active_filter)</a>
<a name="ln3376">{</a>
<a name="ln3377">    int counter = -1;</a>
<a name="ln3378">    int stop_index = -1;</a>
<a name="ln3379">    int start_index = -1;</a>
<a name="ln3380"> </a>
<a name="ln3381">    xmlNode *rsc_op = NULL;</a>
<a name="ln3382"> </a>
<a name="ln3383">    GListPtr gIter = NULL;</a>
<a name="ln3384">    GListPtr op_list = NULL;</a>
<a name="ln3385">    GListPtr sorted_op_list = NULL;</a>
<a name="ln3386"> </a>
<a name="ln3387">    /* extract operations */</a>
<a name="ln3388">    op_list = NULL;</a>
<a name="ln3389">    sorted_op_list = NULL;</a>
<a name="ln3390"> </a>
<a name="ln3391">    for (rsc_op = __xml_first_child(rsc_entry); rsc_op != NULL; rsc_op = __xml_next_element(rsc_op)) {</a>
<a name="ln3392">        if (crm_str_eq((const char *)rsc_op-&gt;name, XML_LRM_TAG_RSC_OP, TRUE)) {</a>
<a name="ln3393">            crm_xml_add(rsc_op, &quot;resource&quot;, rsc);</a>
<a name="ln3394">            crm_xml_add(rsc_op, XML_ATTR_UNAME, node);</a>
<a name="ln3395">            op_list = g_list_prepend(op_list, rsc_op);</a>
<a name="ln3396">        }</a>
<a name="ln3397">    }</a>
<a name="ln3398"> </a>
<a name="ln3399">    if (op_list == NULL) {</a>
<a name="ln3400">        /* if there are no operations, there is nothing to do */</a>
<a name="ln3401">        return NULL;</a>
<a name="ln3402">    }</a>
<a name="ln3403"> </a>
<a name="ln3404">    sorted_op_list = g_list_sort(op_list, sort_op_by_callid);</a>
<a name="ln3405"> </a>
<a name="ln3406">    /* create active recurring operations as optional */</a>
<a name="ln3407">    if (active_filter == FALSE) {</a>
<a name="ln3408">        return sorted_op_list;</a>
<a name="ln3409">    }</a>
<a name="ln3410"> </a>
<a name="ln3411">    op_list = NULL;</a>
<a name="ln3412"> </a>
<a name="ln3413">    calculate_active_ops(sorted_op_list, &amp;start_index, &amp;stop_index);</a>
<a name="ln3414"> </a>
<a name="ln3415">    for (gIter = sorted_op_list; gIter != NULL; gIter = gIter-&gt;next) {</a>
<a name="ln3416">        xmlNode *rsc_op = (xmlNode *) gIter-&gt;data;</a>
<a name="ln3417"> </a>
<a name="ln3418">        counter++;</a>
<a name="ln3419"> </a>
<a name="ln3420">        if (start_index &lt; stop_index) {</a>
<a name="ln3421">            crm_trace(&quot;Skipping %s: not active&quot;, ID(rsc_entry));</a>
<a name="ln3422">            break;</a>
<a name="ln3423"> </a>
<a name="ln3424">        } else if (counter &lt; start_index) {</a>
<a name="ln3425">            crm_trace(&quot;Skipping %s: old&quot;, ID(rsc_op));</a>
<a name="ln3426">            continue;</a>
<a name="ln3427">        }</a>
<a name="ln3428">        op_list = g_list_append(op_list, rsc_op);</a>
<a name="ln3429">    }</a>
<a name="ln3430"> </a>
<a name="ln3431">    g_list_free(sorted_op_list);</a>
<a name="ln3432">    return op_list;</a>
<a name="ln3433">}</a>
<a name="ln3434"> </a>
<a name="ln3435">GListPtr</a>
<a name="ln3436">find_operations(const char *rsc, const char *node, gboolean active_filter,</a>
<a name="ln3437">                pe_working_set_t * data_set)</a>
<a name="ln3438">{</a>
<a name="ln3439">    GListPtr output = NULL;</a>
<a name="ln3440">    GListPtr intermediate = NULL;</a>
<a name="ln3441"> </a>
<a name="ln3442">    xmlNode *tmp = NULL;</a>
<a name="ln3443">    xmlNode *status = find_xml_node(data_set-&gt;input, XML_CIB_TAG_STATUS, TRUE);</a>
<a name="ln3444"> </a>
<a name="ln3445">    node_t *this_node = NULL;</a>
<a name="ln3446"> </a>
<a name="ln3447">    xmlNode *node_state = NULL;</a>
<a name="ln3448"> </a>
<a name="ln3449">    for (node_state = __xml_first_child(status); node_state != NULL;</a>
<a name="ln3450">         node_state = __xml_next_element(node_state)) {</a>
<a name="ln3451"> </a>
<a name="ln3452">        if (crm_str_eq((const char *)node_state-&gt;name, XML_CIB_TAG_STATE, TRUE)) {</a>
<a name="ln3453">            const char *uname = crm_element_value(node_state, XML_ATTR_UNAME);</a>
<a name="ln3454"> </a>
<a name="ln3455">            if (node != NULL &amp;&amp; safe_str_neq(uname, node)) {</a>
<a name="ln3456">                continue;</a>
<a name="ln3457">            }</a>
<a name="ln3458"> </a>
<a name="ln3459">            this_node = pe_find_node(data_set-&gt;nodes, uname);</a>
<a name="ln3460">            if(this_node == NULL) {</a>
<a name="ln3461">                CRM_LOG_ASSERT(this_node != NULL);</a>
<a name="ln3462">                continue;</a>
<a name="ln3463"> </a>
<a name="ln3464">            } else if (is_remote_node(this_node)) {</a>
<a name="ln3465">                determine_remote_online_status(data_set, this_node);</a>
<a name="ln3466"> </a>
<a name="ln3467">            } else {</a>
<a name="ln3468">                determine_online_status(node_state, this_node, data_set);</a>
<a name="ln3469">            }</a>
<a name="ln3470"> </a>
<a name="ln3471">            if (this_node-&gt;details-&gt;online || is_set(data_set-&gt;flags, pe_flag_stonith_enabled)) {</a>
<a name="ln3472">                /* offline nodes run no resources...</a>
<a name="ln3473">                 * unless stonith is enabled in which case we need to</a>
<a name="ln3474">                 *   make sure rsc start events happen after the stonith</a>
<a name="ln3475">                 */</a>
<a name="ln3476">                xmlNode *lrm_rsc = NULL;</a>
<a name="ln3477"> </a>
<a name="ln3478">                tmp = find_xml_node(node_state, XML_CIB_TAG_LRM, FALSE);</a>
<a name="ln3479">                tmp = find_xml_node(tmp, XML_LRM_TAG_RESOURCES, FALSE);</a>
<a name="ln3480"> </a>
<a name="ln3481">                for (lrm_rsc = __xml_first_child(tmp); lrm_rsc != NULL;</a>
<a name="ln3482">                     lrm_rsc = __xml_next_element(lrm_rsc)) {</a>
<a name="ln3483">                    if (crm_str_eq((const char *)lrm_rsc-&gt;name, XML_LRM_TAG_RESOURCE, TRUE)) {</a>
<a name="ln3484"> </a>
<a name="ln3485">                        const char *rsc_id = crm_element_value(lrm_rsc, XML_ATTR_ID);</a>
<a name="ln3486"> </a>
<a name="ln3487">                        if (rsc != NULL &amp;&amp; safe_str_neq(rsc_id, rsc)) {</a>
<a name="ln3488">                            continue;</a>
<a name="ln3489">                        }</a>
<a name="ln3490"> </a>
<a name="ln3491">                        intermediate = extract_operations(uname, rsc_id, lrm_rsc, active_filter);</a>
<a name="ln3492">                        output = g_list_concat(output, intermediate);</a>
<a name="ln3493">                    }</a>
<a name="ln3494">                }</a>
<a name="ln3495">            }</a>
<a name="ln3496">        }</a>
<a name="ln3497">    }</a>
<a name="ln3498"> </a>
<a name="ln3499">    return output;</a>
<a name="ln3500">}</a>

</code></pre>
<div class="balloon" rel="362"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_insert' function. Inspect the second argument. Check lines: 362, 362.</p></div>
<div class="balloon" rel="364"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_insert' function. Inspect the second argument. Check lines: 364, 364.</p></div>
<div class="balloon" rel="399"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V547/" target="_blank">V547</a> Expression 'match' is always false.</p></div>
<div class="balloon" rel="753"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_replace' function. Inspect the second argument. Check lines: 753, 753.</p></div>
<div class="balloon" rel="788"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_insert' function. Inspect the second argument. Check lines: 788, 788.</p></div>
<div class="balloon" rel="912"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_replace' function. Inspect the second argument. Check lines: 912, 912.</p></div>
<div class="balloon" rel="1601"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1601, 1600.</p></div>
<div class="balloon" rel="1642"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'memcpy' function. Inspect the first argument. Check lines: 1642, 1641.</p></div>
<div class="balloon" rel="1654"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V1004/" target="_blank">V1004</a> The 'last_rsc_id' pointer was used unsafely after it was verified against nullptr. Check lines: 1620, 1654.</p></div>
<div class="balloon" rel="2434"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V562/" target="_blank">V562</a> It's odd to compare 0 or 1 with a value of 0: (offset > 0) == 0.</p></div>
<div class="balloon" rel="3337"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_insert' function. Inspect the second argument. Check lines: 3337, 3338.</p></div>
<div class="balloon" rel="3340"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_insert' function. Inspect the second argument. Check lines: 3340, 3340.</p></div>
<div class="balloon" rel="3344"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_insert' function. Inspect the second argument. Check lines: 3344, 3345.</p></div>
<div class="balloon" rel="3347"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_insert' function. Inspect the second argument. Check lines: 3347, 3348.</p></div>
<div class="balloon" rel="3353"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_insert' function. Inspect the second argument. Check lines: 3353, 3353.</p></div>
<div class="balloon" rel="3364"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_insert' function. Inspect the second argument. Check lines: 3364, 3364.</p></div>
<div class="balloon" rel="3368"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The potential null pointer is passed into 'g_hash_table_insert' function. Inspect the second argument. Check lines: 3368, 3368.</p></div>
<div class="balloon" rel="3492"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/V575/" target="_blank">V575</a> The null pointer is passed into 'g_list_concat' function. Inspect the first argument.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
